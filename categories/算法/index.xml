<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>算法 on Yang Blog</title>
    <link>https://jiyang.site/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Yang Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>©2023, All Rights Reserved</copyright>
    <lastBuildDate>Thu, 30 Jan 2020 20:35:12 +0000</lastBuildDate>
    
        <atom:link href="https://jiyang.site/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>打开转盘锁</title>
        <link>https://jiyang.site/posts/2020-01-30-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</link>
        <pubDate>Thu, 30 Jan 2020 20:35:12 +0000</pubDate>
        
        <atom:modified>Thu, 30 Jan 2020 20:35:12 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-01-30-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</guid>
        <description>问题 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo; 。每个拨轮可以自由旋转：例如把 &amp;lsquo;9&amp;rsquo; 变为 &amp;lsquo;0&amp;rs</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>岛屿数量</title>
        <link>https://jiyang.site/posts/2019-12-03-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
        <pubDate>Tue, 03 Dec 2019 10:03:12 +0000</pubDate>
        
        <atom:modified>Tue, 03 Dec 2019 10:03:12 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-12-03-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
        <description>&lt;p&gt;给定一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>BFS 广度优先搜索</title>
        <link>https://jiyang.site/posts/2019-11-30-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
        <pubDate>Sat, 30 Nov 2019 14:29:33 +0000</pubDate>
        
        <atom:modified>Sat, 30 Nov 2019 14:29:33 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-30-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
        <description>&lt;p&gt;之前看过的 BFS(Breadth First Search), 最近遇到类似问题时却没有想起. 在此再回顾一下, 并留下记录. 好记性毕竟不如坏笔头.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>洗牌-乱序一个数组</title>
        <link>https://jiyang.site/posts/2019-11-21-%E6%B4%97%E7%89%8C-%E4%B9%B1%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</link>
        <pubDate>Thu, 21 Nov 2019 21:06:23 +0000</pubDate>
        
        <atom:modified>Thu, 21 Nov 2019 21:06:23 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-21-%E6%B4%97%E7%89%8C-%E4%B9%B1%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</guid>
        <description>&lt;p&gt;设计一个方法, 把一个数组随机打乱, 每一个元素不能在原来的位置上&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>螺旋输出矩阵</title>
        <link>https://jiyang.site/posts/2019-11-07-%E8%9E%BA%E6%97%8B%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5/</link>
        <pubDate>Thu, 07 Nov 2019 21:09:59 +0000</pubDate>
        
        <atom:modified>Thu, 07 Nov 2019 21:09:59 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-07-%E8%9E%BA%E6%97%8B%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5/</guid>
        <description>&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;一个 m*n 的矩阵, 螺旋遍历输出每一项. 比如:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>LruCache缓存机制实现原理</title>
        <link>https://jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Wed, 24 May 2017 00:00:00 +0000</pubDate>
        
        <atom:modified>Wed, 24 May 2017 00:00:00 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>LRU 算法描述 当序列达到设置的内存上限时, 丢弃序列中最近最少使用的元素. LruCache Android SDK 提供的使用了(Least Recently Used)最近最少使用算法的缓存类. 编写</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>缓存算法</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>DNA合成问题</title>
        <link>https://jiyang.site/posts/2017-08-24-dna%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-24-dna%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</guid>
        <description>DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。 碱基互补配对原则：A和T是配对的，C和G是</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>QuickSort快排</title>
        <link>https://jiyang.site/posts/2017-08-12-quicksort%E5%BF%AB%E6%8E%92/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-12-quicksort%E5%BF%AB%E6%8E%92/</guid>
        <description>快速排序-维基百科 一次快排分区的结果 class QuickSort { private int[] mArray; public QuickSort(int[] array) { this.mArray = array; } private void swap(int from, int to) { int t = mArray[from]; mArray[from] = mArray[to]; mArray[to] = t; } /** * 分区(原地版本) * * @param left 数组左侧 * @param</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>斐波拉契数列</title>
        <link>https://jiyang.site/posts/2017-08-12-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-12-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/</guid>
        <description>斐波拉契数列的第n项 斐波拉契数列: a(0) = 0 a(1) = 1 a(2) = 1 a(n) = a(n-1) + a(n-2) 递归实现 1 2 3 4 5 6 7 8 long fab1(int n) { if (n &amp;lt; 3) { return 1; } return fab1(n - 2) + fab1(n - 1); } 「遍历数组」</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>进制均值</title>
        <link>https://jiyang.site/posts/2017-09-08-%E8%BF%9B%E5%88%B6%E5%9D%87%E5%80%BC/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-09-08-%E8%BF%9B%E5%88%B6%E5%9D%87%E5%80%BC/</guid>
        <description>一个数A，如果按2到A-1进制表达时，各个位数之和的均值是多少? 结果用最简分数表示。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>连续整数</title>
        <link>https://jiyang.site/posts/2017-07-24-%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-07-24-%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0/</guid>
        <description>牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>求最大公约数、幂运算</title>
        <link>https://jiyang.site/posts/2017-10-24-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E5%B9%82%E8%BF%90%E7%AE%97-%E9%98%B6%E4%B9%98/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-10-24-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E5%B9%82%E8%BF%90%E7%AE%97-%E9%98%B6%E4%B9%98/</guid>
        <description>求两个数的最大公约数 1 2 3 4 5 6 7 8 long gcd(long m, long n) { while (n != 0) { long ren = m % n; m = n; n = ren; } return m; } 幂运算 时间复杂度为O(logN)的算法 1 2 3 4 5 6</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>循环单词问题</title>
        <link>https://jiyang.site/posts/2017-07-24-%E5%BE%AA%E7%8E%AF%E5%8D%95%E8%AF%8D%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-07-24-%E5%BE%AA%E7%8E%AF%E5%8D%95%E8%AF%8D%E9%97%AE%E9%A2%98/</guid>
        <description>如果一个单词通过循环右移获得的单词，我们称这些单词都为一种循环单词。 例如：picture 和 turepic 就是属于同一种循环单词。 现在给出n个单词，需要统</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>
