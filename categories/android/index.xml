<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Android on Yang Blog</title>
    <link>https://jiyang.site/categories/android/</link>
    <description>Recent content in Android on Yang Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>©2023, All Rights Reserved</copyright>
    <lastBuildDate>Wed, 28 Jul 2021 21:32:56 +0800</lastBuildDate>
    
        <atom:link href="https://jiyang.site/categories/android/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>Android MediaCodec OpenGL Video Render &amp;&amp; Unity</title>
        <link>https://jiyang.site/posts/android_mediacodec_opengl_video_render_with_unity/</link>
        <pubDate>Wed, 28 Jul 2021 21:32:56 +0800</pubDate>
        
        <atom:modified>Wed, 28 Jul 2021 21:32:56 +0800</atom:modified>
        <guid>https://jiyang.site/posts/android_mediacodec_opengl_video_render_with_unity/</guid>
        <description>上图描述了这样的一个场景：通过 Android MediaCodec 将视频解码，解码的过程中通过 Unity Engine 在视频的每帧添加一些特殊的效果。 (The above figure describes such a scene: the video is decoded through Android MediaCodec, and some special effects are added to</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>MediaCodec</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>通过分析mobile Ffmpeg解析如何优雅的集成ffmpeg到Android应用中</title>
        <link>https://jiyang.site/posts/mobile_ffmpeg_compile/</link>
        <pubDate>Sun, 21 Mar 2021 20:34:57 +0800</pubDate>
        
        <atom:modified>Sun, 21 Mar 2021 20:34:57 +0800</atom:modified>
        <guid>https://jiyang.site/posts/mobile_ffmpeg_compile/</guid>
        <description>背景 FFmpeg 是一个开源的、强大的音视频工具库，平常情况下的使用方法一般是利用编译好的 ffmpeg 程序，在 PC 上使用，需要不同的功能时只需传递不同的参数即可，而</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>FFmpeg</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>音频波形图绘制</title>
        <link>https://jiyang.site/posts/audio_waveform/</link>
        <pubDate>Mon, 08 Mar 2021 21:13:34 +0800</pubDate>
        
        <atom:modified>Mon, 08 Mar 2021 21:13:34 +0800</atom:modified>
        <guid>https://jiyang.site/posts/audio_waveform/</guid>
        <description>背景 最近需要上线一个音乐编辑功能，需要展示音乐的波形图(如下图)。 期待效果 初步效果 首先这样的波形图，是根据音频在采样点的采样值来绘制的。像 mp3</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Audio</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>解决 Unity 2020 导出项目到 Android 中 So 加载问题</title>
        <link>https://jiyang.site/posts/unity-export-android-library-so-not-found/</link>
        <pubDate>Wed, 20 Jan 2021 18:17:41 +0800</pubDate>
        
        <atom:modified>Wed, 20 Jan 2021 18:17:41 +0800</atom:modified>
        <guid>https://jiyang.site/posts/unity-export-android-library-so-not-found/</guid>
        <description>问题 Unity 项目将版本从 2018 升级到 2020 版本之后，导出集成到 Android 项目时，运行时报错找不到 libmain.so。 java.lang.UnsatisfiedLinkError: dlopen failed: library &amp;#34;/data/app/xxx/lib/arm/libmain.so&amp;#34; not found 原因 最终找到了根本原因： Unity 2020 版</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 上 FFMpeg 和 MediaCodec 视频解码效率对比</title>
        <link>https://jiyang.site/posts/android-ffmpeg-vs-mediacodec-video-decode/</link>
        <pubDate>Sat, 05 Sep 2020 22:41:45 +0800</pubDate>
        
        <atom:modified>Sat, 05 Sep 2020 22:41:45 +0800</atom:modified>
        <guid>https://jiyang.site/posts/android-ffmpeg-vs-mediacodec-video-decode/</guid>
        <description>视频编码格式为: H264, 封装格式为: mp4 外部参考: 手机CPU性能天梯图 手机Soc性能排行榜 能耗对比: 解码1080P 编码1080P 左边是硬件Codec</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>FFmpeg</category>
            
          
            
              <category>MediaCodec</category>
            
          
            
              <category>Video</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 处理 Native Crash</title>
        <link>https://jiyang.site/posts/collect-android-so-crash/</link>
        <pubDate>Sun, 14 Jun 2020 21:03:54 +0800</pubDate>
        
        <atom:modified>Sun, 14 Jun 2020 21:03:54 +0800</atom:modified>
        <guid>https://jiyang.site/posts/collect-android-so-crash/</guid>
        <description>在 Android 上，native 层的代码出现问题时，系统内核将会发送一些信号到应用进程，应用进程可以通过自定义信号的处理过程来实现 native crash 的收集等工作。 Linux 信</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>ELF</category>
            
          
            
              <category>DWARF</category>
            
          
            
              <category>Signal</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>使用 OnFrameMetricsAvailableListener 统计绘制耗时</title>
        <link>https://jiyang.site/posts/2020-04-21-%E4%BD%BF%E7%94%A8-onframemetricsavailablelistener-%E7%BB%9F%E8%AE%A1%E7%BB%98%E5%88%B6%E8%80%97%E6%97%B6/</link>
        <pubDate>Tue, 21 Apr 2020 22:12:00 +0800</pubDate>
        
        <atom:modified>Tue, 21 Apr 2020 22:12:00 +0800</atom:modified>
        <guid>https://jiyang.site/posts/2020-04-21-%E4%BD%BF%E7%94%A8-onframemetricsavailablelistener-%E7%BB%9F%E8%AE%A1%E7%BB%98%E5%88%B6%E8%80%97%E6%97%B6/</guid>
        <description>在 Android 7.0, 增加了一个 Api 可以方便的统计一个 Window 的 View 树的绘制耗时。 功能 统计渲染子系统报告的帧生命周期中各个里程碑的时序数据。可以通过其相应的标识符查询</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>AnimatorSet Cancel 在 Android 8 和以下版的行为不一致坑</title>
        <link>https://jiyang.site/posts/2020-04-16-animatorset-cancel-android8-%E5%92%8C%E4%BB%A5%E4%B8%8B%E7%89%88%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9D%91/</link>
        <pubDate>Thu, 16 Apr 2020 23:57:42 +0000</pubDate>
        
        <atom:modified>Thu, 16 Apr 2020 23:57:42 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-04-16-animatorset-cancel-android8-%E5%92%8C%E4%BB%A5%E4%B8%8B%E7%89%88%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9D%91/</guid>
        <description>问题背景： 有个动画在 onAnimatorEnd 回调中间接调用了 Animator#cancel。在 Android 8 没有问题，但是在 Android 5, Android 6 等版本出现了下面的递归调用。 java.lang.StackOverflowError: stack size 8MB ... at</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>TextView 的布局细节</title>
        <link>https://jiyang.site/posts/2020-04-10-textview-%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/</link>
        <pubDate>Fri, 10 Apr 2020 23:14:33 +0000</pubDate>
        
        <atom:modified>Fri, 10 Apr 2020 23:14:33 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-04-10-textview-%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/</guid>
        <description>TextView 在布局方面提供了一些特别的属性来控制文本的布局。比如现在要显示一个句子 What is a good time for you?。 TextView 在发现一行布局不足以显示整个文本内容时，会进</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>让 Annotation Processor 支持增量编译</title>
        <link>https://jiyang.site/posts/2020-03-24-%E8%AE%A9annotation-processor-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</link>
        <pubDate>Tue, 24 Mar 2020 21:08:39 +0000</pubDate>
        
        <atom:modified>Tue, 24 Mar 2020 21:08:39 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-03-24-%E8%AE%A9annotation-processor-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</guid>
        <description>Java 的增量编译 Gradle 在 5.0 增加了对 Java 增量编译的支持，通过增量编译，我们能够获得一些优点： 更少的编译耗时 更少的字节码修改 增量编译概览： Gradle 会重新编译受更</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android VM 的启动流程以及 JNI 的通信原理</title>
        <link>https://jiyang.site/posts/2020-03-06-androidruntime%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Fri, 06 Mar 2020 23:36:51 +0000</pubDate>
        
        <atom:modified>Fri, 06 Mar 2020 23:36:51 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-03-06-androidruntime%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        <description>详细分析在 zygote 的启动流程中, Android 的 Art/Dalvik VM 是如果启动的；以及 Android 为支持 JNI 调用做了哪些工作。 Init Android 系统在启动之后, Linux 内核的启动进程 init 进程将会启动 system/bin/app_process 程序, 其</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>一种 Android 项目的模块化开发机制</title>
        <link>https://jiyang.site/posts/2020-02-05-%E4%B8%80%E7%A7%8D-android-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Wed, 05 Feb 2020 23:35:19 +0000</pubDate>
        
        <atom:modified>Wed, 05 Feb 2020 23:35:19 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-02-05-%E4%B8%80%E7%A7%8D-android-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        <description>在 Android 开发中，当项目增加一定规模之后，一般都会采用多模块的项目结构。当然也能采用插件化的开发模式，具体采用什么开发模式，开发者可以自行定夺。这</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>ViewModel 的实现原理</title>
        <link>https://jiyang.site/posts/2020-01-12-viewmodel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 12 Jan 2020 16:26:07 +0000</pubDate>
        
        <atom:modified>Sun, 12 Jan 2020 16:26:07 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-01-12-viewmodel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>Android Jetpack 提供了 ViewModel, 以用来维护 Activity 或 Fragment 中需要的数据。其能够在因配置改变(比如屏幕旋转)造成的 Activity 和 Fragment 重建时, 依然维护其内部的数据。 背景 首先，根据官方文档</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android Binder</title>
        <link>https://jiyang.site/posts/2020-01-06-android-binder/</link>
        <pubDate>Mon, 06 Jan 2020 23:03:06 +0000</pubDate>
        
        <atom:modified>Mon, 06 Jan 2020 23:03:06 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-01-06-android-binder/</guid>
        <description>一篇对 Android 主要的 IPC 机制(Binder) 的记录，理解自一份 RUB(https://en.wikipedia.org/wiki/Ruhr_Univ</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解 WorkManager 的实现</title>
        <link>https://jiyang.site/posts/2019-12-07-%E7%90%86%E8%A7%A3-workmanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 07 Dec 2019 19:17:41 +0000</pubDate>
        
        <atom:modified>Sat, 07 Dec 2019 19:17:41 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-12-07-%E7%90%86%E8%A7%A3-workmanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;p&gt;最近使用 Android Jetpack 中 WorkManager 组件做了一个上报一些做分析用途数据的需求, 用着感觉挺香的. 于是想看下其内部的实现原理.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Java 和 Android 的异常处理流程</title>
        <link>https://jiyang.site/posts/2019-11-22-java-%E5%92%8C-android-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Fri, 22 Nov 2019 19:08:59 +0000</pubDate>
        
        <atom:modified>Fri, 22 Nov 2019 19:08:59 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-22-java-%E5%92%8C-android-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</guid>
        <description>&lt;p&gt;理清 Java 和 Android 的线程异常处理&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解 Fragment</title>
        <link>https://jiyang.site/posts/2019-11-08-%E7%90%86%E8%A7%A3-fragment/</link>
        <pubDate>Fri, 08 Nov 2019 21:53:37 +0000</pubDate>
        
        <atom:modified>Fri, 08 Nov 2019 21:53:37 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-08-%E7%90%86%E8%A7%A3-fragment/</guid>
        <description>&lt;p&gt;理解 Fragment 的实现原理, FragmentTransaction 的事务机制等.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>记一次 DialogFragment 造成的内存泄漏</title>
        <link>https://jiyang.site/posts/2019-11-01-%E8%AE%B0%E4%B8%80%E6%AC%A1-dialogfragment-%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
        <pubDate>Fri, 01 Nov 2019 21:18:19 +0000</pubDate>
        
        <atom:modified>Fri, 01 Nov 2019 21:18:19 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-11-01-%E8%AE%B0%E4%B8%80%E6%AC%A1-dialogfragment-%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</guid>
        <description>&lt;p&gt;最近 Leak Canrray 检测出了 Activity/ReportFragment 被泄漏。发现引用其的 GC Root 竟然是一个 HandlerThread。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>内存泄漏</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 中 MessageQueue 的 nativePollOnce</title>
        <link>https://jiyang.site/posts/2019-10-19-android%E4%B8%ADmessagequeue%E7%9A%84nativepollonce/</link>
        <pubDate>Sat, 19 Oct 2019 20:53:02 +0000</pubDate>
        
        <atom:modified>Sat, 19 Oct 2019 20:53:02 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-10-19-android%E4%B8%ADmessagequeue%E7%9A%84nativepollonce/</guid>
        <description>&lt;p&gt;Android SDK 中的事件循环已经是一个老生常谈的问题了, 像 &lt;code&gt;Handler&lt;/code&gt; &lt;code&gt;Looper&lt;/code&gt; &lt;code&gt;MessageQueue&lt;/code&gt; 这几个类也是被大家研究透彻了.&lt;br /&gt;
但是再回头看以前自己的分析, 总感觉差点什么, 不够透彻. 心里隐隐感觉自己没有把事情完全吃透, 于是今日又回顾 Android 中的事件循环机制, 注意到&lt;br /&gt;
&lt;code&gt;MessageQueue&lt;/code&gt; 中获取下一条消息时会执行一个 native 调用 &lt;code&gt;nativePollOnce&lt;/code&gt;, 翻看 Android 系统源码发现有内容.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>优化 ObjectOutputStream 的使用</title>
        <link>https://jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</link>
        <pubDate>Fri, 18 Oct 2019 14:42:25 +0000</pubDate>
        
        <atom:modified>Fri, 18 Oct 2019 14:42:25 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;p&gt;最近阅读《Android移动性能实战》看到手机QQ测试团队给出的一个案列 「Object Ouput Stream 4000 多次的写操作」,&lt;br /&gt;
其原因就是直接使用了 &lt;code&gt;ObjectOutputStream&lt;/code&gt; + &lt;code&gt;FileOutputStream&lt;/code&gt; 做对象的序列化到磁盘。印象中我们的项目中也有这样的代码&lt;br /&gt;
&lt;code&gt;SerializeUtil#serializeObject&lt;/code&gt;:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android init 进程的启动过程</title>
        <link>https://jiyang.site/posts/2019-09-12-android-init-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
        <pubDate>Thu, 12 Sep 2019 13:28:41 +0000</pubDate>
        
        <atom:modified>Thu, 12 Sep 2019 13:28:41 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-09-12-android-init-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程是 Android 系统中用户空间的第一个进程，进程号为 1。作为第一个进程，它被赋予了很多重要的职责，比如创建 &lt;code&gt;Zygote&lt;/code&gt; 进程和属性服务等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程由多个源文件共同组成，这些文件位于源码目录 &lt;code&gt;system/core/init&lt;/code&gt; 中。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>LifeCycle 原理</title>
        <link>https://jiyang.site/posts/2019-07-14-lifecycle-%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 14 Jul 2019 11:27:50 +0000</pubDate>
        
        <atom:modified>Sun, 14 Jul 2019 11:27:50 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-07-14-lifecycle-%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/android/arch/lifecycle/Lifecycle&#34; target=&#34;_blank&#34;&gt;LifeCycle&lt;/a&gt; Android 架构组件。&lt;/p&gt;
&lt;p&gt;其目的是: 方便开发者能从 Activity Fragment 的生命周期回调中解放，让开发者能自由的创建监听生命周期回调的组件。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>使用Android Studio Code 模板提高编码效率</title>
        <link>https://jiyang.site/posts/2019-06-23-%E4%BD%BF%E7%94%A8android-studio-code-%E6%A8%A1%E6%9D%BF%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87/</link>
        <pubDate>Sun, 23 Jun 2019 15:50:41 +0000</pubDate>
        
        <atom:modified>Sun, 23 Jun 2019 15:50:41 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-06-23-%E4%BD%BF%E7%94%A8android-studio-code-%E6%A8%A1%E6%9D%BF%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87/</guid>
        <description>&lt;p&gt;在工作中最近的一个业务上，每次新加一个同一类的功能时，发现会创建许多类似的类，写类似的代码。就思考能否通过模板的方式提高新建同类功能的效率，于是通过搜索发现 IDE 支持的 FreeMaker.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>How to be a better android developer</title>
        <link>https://jiyang.site/posts/2019-01-14-how-to-be-a-better-android-developer/</link>
        <pubDate>Mon, 14 Jan 2019 08:34:03 +0000</pubDate>
        
        <atom:modified>Mon, 14 Jan 2019 08:34:03 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-01-14-how-to-be-a-better-android-developer/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android系统启动简介</title>
        <link>https://jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Tue, 01 Jan 2019 18:53:19 +0000</pubDate>
        
        <atom:modified>Tue, 01 Jan 2019 18:53:19 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>图像处理基础</title>
        <link>https://jiyang.site/posts/2018-12-14-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Fri, 14 Dec 2018 23:00:30 +0000</pubDate>
        
        <atom:modified>Fri, 14 Dec 2018 23:00:30 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-12-14-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</guid>
        <description>图像的数字化过程 图像的数字化主要分两个过程，采样和量化。 采样 用多少点来描述一张图像 例如一张 600x400 尺寸的图, 会采样 240000 个点, 又叫 24 万像素 量化 把采样点</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>图像处理</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android IPC 相关</title>
        <link>https://jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Tue, 04 Dec 2018 23:06:09 +0000</pubDate>
        
        <atom:modified>Tue, 04 Dec 2018 23:06:09 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</guid>
        <description>&lt;h2 id=&#34;android-上的多进程情景&#34;&gt;Android 上的多进程情景&lt;/h2&gt;
&lt;p&gt;Android 中每个应用的进程都 fork 自 Zygote 进程， Zygote 进程在启动时自己会创建一个虚拟机，从而也就让每个应用拥有了自己的虚拟机。&lt;br /&gt;
当应用涉及多进程时，想当于启动了多个虚拟机，在单进程情况下的一些情景将会失效:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>MMKV分析</title>
        <link>https://jiyang.site/posts/2018-10-19-mmkv%E5%88%86%E6%9E%90/</link>
        <pubDate>Fri, 19 Oct 2018 19:03:42 +0000</pubDate>
        
        <atom:modified>Fri, 19 Oct 2018 19:03:42 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-10-19-mmkv%E5%88%86%E6%9E%90/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;基于 mmap 的高性能通用 key-value 组件, 底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。 &lt;a href=&#34;https://github.com/Tencent/MMKV&#34; target=&#34;_blank&#34;&gt;https://github.com/Tencent/MMKV&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>模拟系统内存不足时应用崩溃问题</title>
        <link>https://jiyang.site/posts/2018-10-07-%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</link>
        <pubDate>Sun, 07 Oct 2018 16:27:06 +0000</pubDate>
        
        <atom:modified>Sun, 07 Oct 2018 16:27:06 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-10-07-%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</guid>
        <description>问题 线上一直会报一个 Crash，通过日志发现用户的操作路径： 将一个展示结果的 Activity 退到了后台 然后当回到这个 Activity 时，发生了 NPE 错误导致 Crash 一开始，我预测</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Retrofit Source Code</title>
        <link>https://jiyang.site/posts/2018-09-19-retrofit-source-code/</link>
        <pubDate>Wed, 19 Sep 2018 08:30:30 +0000</pubDate>
        
        <atom:modified>Wed, 19 Sep 2018 08:30:30 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-09-19-retrofit-source-code/</guid>
        <description>&lt;h1 id=&#34;retrofit&#34;&gt;Retrofit&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官话: A type-safe HTTP client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解: 它提供了一种方便的 HTTP 请求编写方式. 它通过解析接口方法的注解, 构造出对应的 HTTP 请求方法, 并且支持添加自己的 CallAdapter 和 Converter 定制化请求的创建和结果的解析.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>CoordinatorLayout Behavior</title>
        <link>https://jiyang.site/posts/2018-09-07-coordinatorlayout-behavior/</link>
        <pubDate>Fri, 07 Sep 2018 09:41:28 +0000</pubDate>
        
        <atom:modified>Fri, 07 Sep 2018 09:41:28 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-09-07-coordinatorlayout-behavior/</guid>
        <description>&lt;h2 id=&#34;step1-简单介绍-coordinatorlayout&#34;&gt;Step1 简单介绍 CoordinatorLayout&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：&lt;em&gt;协调子 View&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使用核心: &lt;strong&gt;Behavior&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;布局属性类似 FrameLayout&lt;/li&gt;
&lt;/ul&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>RxJava&#39;s Thread Dispatch</title>
        <link>https://jiyang.site/posts/2018-08-13-rxjava-thread-dispatch/</link>
        <pubDate>Fri, 17 Aug 2018 21:24:42 +0000</pubDate>
        
        <atom:modified>Fri, 17 Aug 2018 21:24:42 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-08-13-rxjava-thread-dispatch/</guid>
        <description>简单的使用 RxJava，并结合线程切换: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Observable.create(new ObservableOnSubscribe&amp;lt;Object&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;Object&amp;gt; emitter) { Log.d(&amp;#34;TAG&amp;#34;, &amp;#34;[subscribe]&amp;#34; + Thread.currentThread().getName()); emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidScheduler.mainThread()) .subscribe(new Observer&amp;lt;Object&amp;gt;() {</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Rx</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>RxJava Observer Observable(Not With Thread Dispatch) Source Code</title>
        <link>https://jiyang.site/posts/2018-08-10-rxjava-observer-observable/</link>
        <pubDate>Fri, 10 Aug 2018 23:20:50 +0000</pubDate>
        
        <atom:modified>Fri, 10 Aug 2018 23:20:50 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-08-10-rxjava-observer-observable/</guid>
        <description>众所周知 RxJava 是基于观察者模式的响应式编程框架。其中主要有2个主要对象： Observable 被观察者 Observer 观察者 不带线程切换的基本用法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Rx</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 源码中的单例模式</title>
        <link>https://jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 21 Jul 2018 11:23:53 +0000</pubDate>
        
        <atom:modified>Sat, 21 Jul 2018 11:23:53 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;经常使用 &lt;code&gt;Context.getSystemService(String name)&lt;/code&gt; 获取一些系统服务。 其实这些服务都是以单例的方式注册在系统中的。 获取到的都是单例对象。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>ListView原理分析</title>
        <link>https://jiyang.site/posts/2018-07-12-listview%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
        <pubDate>Thu, 12 Jul 2018 11:31:07 +0000</pubDate>
        
        <atom:modified>Thu, 12 Jul 2018 11:31:07 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-07-12-listview%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-7-12/60411659.jpg&#34; alt=&#34;先上张图&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android控件架构</title>
        <link>https://jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</link>
        <pubDate>Mon, 09 Jul 2018 22:38:12 +0000</pubDate>
        
        <atom:modified>Mon, 09 Jul 2018 22:38:12 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-7-9/65379561.jpg&#34; alt=&#34;View树结构&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>绘制SimpleProgressBar</title>
        <link>https://jiyang.site/posts/2018-06-05-%E7%BB%98%E5%88%B6simpleprogressbar/</link>
        <pubDate>Tue, 05 Jun 2018 23:59:20 +0000</pubDate>
        
        <atom:modified>Tue, 05 Jun 2018 23:59:20 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-06-05-%E7%BB%98%E5%88%B6simpleprogressbar/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;继承 View 实现 ProgressBar, 练习使用 Kotlin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://github.com/lingochamp/MagicProgressWidget&#34; target=&#34;_blank&#34;&gt;https://github.com/lingochamp/MagicProgressWidget&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>ADB-Shell-Commands</title>
        <link>https://jiyang.site/posts/2017-08-22-adb-shell-commands/</link>
        <pubDate>Tue, 22 Aug 2017 09:58:00 +0000</pubDate>
        
        <atom:modified>Tue, 22 Aug 2017 09:58:00 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2017-08-22-adb-shell-commands/</guid>
        <description>ADB:Android Debug Bridge 是能够和手机或模拟器通信的一个命令行工具。下载地址 命令分类 1. ADB Debugging 1 adb devices 输出连接的模拟器/真机列表 1 adb forward tcp:8000 tcp:9000 实现PC和Android设备</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android TouchEvent Dispatch 再分析</title>
        <link>https://jiyang.site/posts/2017-06-07-android-touchevent-dispatch-%E5%86%8D%E5%88%86%E6%9E%90/</link>
        <pubDate>Wed, 07 Jun 2017 17:19:50 +0000</pubDate>
        
        <atom:modified>Wed, 07 Jun 2017 17:19:50 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2017-06-07-android-touchevent-dispatch-%E5%86%8D%E5%88%86%E6%9E%90/</guid>
        <description>在 Android 中，一次点击完成实际会产生多个事件，比如一个按钮的点击是: TouchDown → TouchUp → 按钮的 onClickListener 回调触发。 Touch Down Event Touch Down 事件在Parent View 和 View 是否是 clickable 的情况下都</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>LruCache缓存机制实现原理</title>
        <link>https://jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Wed, 24 May 2017 00:00:00 +0000</pubDate>
        
        <atom:modified>Wed, 24 May 2017 00:00:00 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>LRU 算法描述 当序列达到设置的内存上限时, 丢弃序列中最近最少使用的元素. LruCache Android SDK 提供的使用了(Least Recently Used)最近最少使用算法的缓存类. 编写</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>缓存算法</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Anddroid媒体解码学习MediaCodec-MediaExtractor</title>
        <link>https://jiyang.site/posts/2017-07-07-anddroid%E5%AA%92%E4%BD%93%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0mediacodec-mediaextractor/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-07-07-anddroid%E5%AA%92%E4%BD%93%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0mediacodec-mediaextractor/</guid>
        <description>Android提供了MediaPlayer播放器播放媒体文件，其实MediaPlyer只是对Android Media包下的MediaCode</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android性能优化</title>
        <link>https://jiyang.site/posts/2017-08-18-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-18-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        <description>Android程序不能无限制的使用设备的内存和CPU。正如经典所说，设备的资源不是给程序员用的，是给用户用的。在编写程序时，应该经常注意内存</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android消息机制</title>
        <link>https://jiyang.site/posts/2017-06-08-android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-06-08-android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
        <description>在非UI线程使用Handler进行线程通信时，一般都需要进行3个步骤： 创建Looper Looper.prepar() 创建Handler 启动消息循环Looper.loop</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>AsyncTask Source Code</title>
        <link>https://jiyang.site/posts/2017-08-06-asynctask%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-06-asynctask%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
        <description>AsyncTask类的初始化过程 初始化阶段： 初始化线程池THREAD_POOL_EXECUTOR。用于执行任务。 构造一个负责调度线程的线程池</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>IntentFilter匹配规则</title>
        <link>https://jiyang.site/posts/2017-08-05-intentfilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-05-intentfilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</guid>
        <description>Activity的启动方式分为两种: 显式启动 通过指明启动的Activity类 隐式启动 通过Intent匹配目标组件的IntentFilter中</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>OkHttp拦截器使用</title>
        <link>https://jiyang.site/posts/okhttp_interceptor/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/okhttp_interceptor/</guid>
        <description>在Android上进行网络请求时，经常需要维持登录之后的session和cookie状态。session和cookie是加在HTTP请求的h</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>OpenGL-ES-Line</title>
        <link>https://jiyang.site/posts/2017-07-01-opengl-es-line/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-07-01-opengl-es-line/</guid>
        <description>绘制了x,y坐标轴 绘制了4条直线 一些函数说明: gl.glLoadIdentity(): 将当前画布矩阵的状态回归初始状态。 因为Translate``Rotate等操作都是基于当前画</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>ThreadLocal理解</title>
        <link>https://jiyang.site/posts/2017-08-02-threadlocal%E7%90%86%E8%A7%A3/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-02-threadlocal%E7%90%86%E8%A7%A3/</guid>
        <description>不同的线程可以通过同一个 ThreadLocal 对象获取只属于自己的数据。 ThreadLocal.ThreadLocalMap ThreadLocal的内部类。是以ThreadLocal的 hash 值为数组下标，Entry</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Java</category>
            
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Volley Source Code</title>
        <link>https://jiyang.site/posts/2017-08-09-volley%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2017-08-09-volley%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        <description>以StringRequest为例子，分析Volley是怎样执行一个网络请求的。 先看实现Request抽象类的StringRequest 1 2 3</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>分析实现Android自定义View之扇形图</title>
        <link>https://jiyang.site/posts/2016-12-25-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E6%89%87%E5%BD%A2%E5%9B%BE/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2016-12-25-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E6%89%87%E5%BD%A2%E5%9B%BE/</guid>
        <description>继承View基类，画了这样的扇形图 直接来步骤吧 (参考了GcsSloop的教程) 1.分析 自定义View需要认真的分析下，里面还是会用到一些数学</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>分析实现Android自定义View之递增直方图</title>
        <link>https://jiyang.site/posts/2016-12-30-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E9%80%92%E5%A2%9E%E7%9B%B4%E6%96%B9%E5%9B%BE/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://jiyang.site/posts/2016-12-30-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E9%80%92%E5%A2%9E%E7%9B%B4%E6%96%B9%E5%9B%BE/</guid>
        <description>继上次分析实现Android自定义View之扇形图之后，自己又画了下面的这个递增直方图，本来是想做个静态的直方图就完了，结果想想静态的没啥趣</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>
