<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>读书笔记 on Yang Blog</title>
    <link>https://jiyang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 读书笔记 on Yang Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>©2023, All Rights Reserved</copyright>
    <lastBuildDate>Sun, 14 Jun 2020 00:08:04 +0800</lastBuildDate>
    
        <atom:link href="https://jiyang.site/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>GNU C 避免宏定义产生副作用</title>
        <link>https://jiyang.site/posts/gnu-c-%E9%81%BF%E5%85%8D%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BA%A7%E7%94%9F%E5%89%AF%E4%BD%9C%E7%94%A8/</link>
        <pubDate>Sun, 14 Jun 2020 00:08:04 +0800</pubDate>
        
        <atom:modified>Sun, 14 Jun 2020 00:08:04 +0800</atom:modified>
        <guid>https://jiyang.site/posts/gnu-c-%E9%81%BF%E5%85%8D%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BA%A7%E7%94%9F%E5%89%AF%E4%BD%9C%E7%94%A8/</guid>
        <description>在编写 c/c++ 代码时，我们通常使用 #define 定义一些宏，然后编译器在 预处理 阶段会把用到宏的地方替换为宏的内容，由于宏的替换完全是一种文本替换，所以在一些情</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>代码工程</category>
            
          
        
        
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>C库的IO缓存机制</title>
        <link>https://jiyang.site/posts/libc-io-cache/</link>
        <pubDate>Sat, 30 May 2020 21:53:39 +0800</pubDate>
        
        <atom:modified>Sat, 30 May 2020 21:53:39 +0800</atom:modified>
        <guid>https://jiyang.site/posts/libc-io-cache/</guid>
        <description>缓存分类 块缓存 一般用于访问真正的磁盘文件。C库会为文件访问申请一块内存，只有当文件内容将缓存块填满或执行冲刷函数flush时，C库才会将缓存</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>libc</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解Linux内部网络实现之关键数据结构 net_device</title>
        <link>https://jiyang.site/posts/2020-01-05-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-net_device/</link>
        <pubDate>Sun, 05 Jan 2020 11:15:35 +0000</pubDate>
        
        <atom:modified>Sun, 05 Jan 2020 11:15:35 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-01-05-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-net_device/</guid>
        <description>Understanding Linux Networking internal 系列之 Critical Data Structures 背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>读书笔记</category>
            
          
            
              <category>Linux</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解Linux内部网络实现之关键数据结构 sk_buff</title>
        <link>https://jiyang.site/posts/2020-01-02-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-sk_buff/</link>
        <pubDate>Thu, 02 Jan 2020 23:49:09 +0000</pubDate>
        
        <atom:modified>Thu, 02 Jan 2020 23:49:09 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2020-01-02-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-sk_buff/</guid>
        <description>Understanding Linux Networking internal 系列之 Critical Data Structures 背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>Linux</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>优化 ObjectOutputStream 的使用</title>
        <link>https://jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</link>
        <pubDate>Fri, 18 Oct 2019 14:42:25 +0000</pubDate>
        
        <atom:modified>Fri, 18 Oct 2019 14:42:25 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;p&gt;最近阅读《Android移动性能实战》看到手机QQ测试团队给出的一个案列 「Object Ouput Stream 4000 多次的写操作」,&lt;br /&gt;
其原因就是直接使用了 &lt;code&gt;ObjectOutputStream&lt;/code&gt; + &lt;code&gt;FileOutputStream&lt;/code&gt; 做对象的序列化到磁盘。印象中我们的项目中也有这样的代码&lt;br /&gt;
&lt;code&gt;SerializeUtil#serializeObject&lt;/code&gt;:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>装饰者模式</title>
        <link>https://jiyang.site/posts/2019-06-29-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 29 Jun 2019 14:22:44 +0000</pubDate>
        
        <atom:modified>Sat, 29 Jun 2019 14:22:44 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-06-29-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;使用装饰者模式代替单纯的继承，更好的实现功能的扩展&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>工厂方法模式</title>
        <link>https://jiyang.site/posts/2019-05-19-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sun, 19 May 2019 19:56:52 +0000</pubDate>
        
        <atom:modified>Sun, 19 May 2019 19:56:52 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-05-19-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;在需要生成复杂对象的地方，可以使用工厂方法模式。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>使程序运行更高效-原型模式</title>
        <link>https://jiyang.site/posts/2019-04-27-%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 27 Apr 2019 09:45:31 +0000</pubDate>
        
        <atom:modified>Sat, 27 Apr 2019 09:45:31 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-04-27-%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>通过 Wireshark 看网络分层</title>
        <link>https://jiyang.site/posts/2019-04-13-%E9%80%9A%E8%BF%87wireshark%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</link>
        <pubDate>Sat, 13 Apr 2019 13:23:06 +0000</pubDate>
        
        <atom:modified>Sat, 13 Apr 2019 13:23:06 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-04-13-%E9%80%9A%E8%BF%87wireshark%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>时势造英雄-策略模式</title>
        <link>https://jiyang.site/posts/2019-04-01-%E6%97%B6%E5%8A%BF%E9%80%A0%E8%8B%B1%E9%9B%84-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Mon, 01 Apr 2019 22:41:06 +0000</pubDate>
        
        <atom:modified>Mon, 01 Apr 2019 22:41:06 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-04-01-%E6%97%B6%E5%8A%BF%E9%80%A0%E8%8B%B1%E9%9B%84-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>应用最广的模式-单例模式</title>
        <link>https://jiyang.site/posts/2019-03-22-%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E7%9A%84%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Fri, 22 Mar 2019 20:09:17 +0000</pubDate>
        
        <atom:modified>Fri, 22 Mar 2019 20:09:17 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-03-22-%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E7%9A%84%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>面向对象六大原则</title>
        <link>https://jiyang.site/posts/2019-02-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</link>
        <pubDate>Thu, 21 Feb 2019 12:16:57 +0000</pubDate>
        
        <atom:modified>Thu, 21 Feb 2019 12:16:57 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-02-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</guid>
        <description>六大原则简单描述 单一职责原则：一个类中应该是相关性很强的一类函数。 开闭原则：对扩展开放，对修改封闭。实现扩展的方法是使用抽象和依赖注入。将可</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android系统启动简介</title>
        <link>https://jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Tue, 01 Jan 2019 18:53:19 +0000</pubDate>
        
        <atom:modified>Tue, 01 Jan 2019 18:53:19 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android IPC 相关</title>
        <link>https://jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Tue, 04 Dec 2018 23:06:09 +0000</pubDate>
        
        <atom:modified>Tue, 04 Dec 2018 23:06:09 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</guid>
        <description>&lt;h2 id=&#34;android-上的多进程情景&#34;&gt;Android 上的多进程情景&lt;/h2&gt;
&lt;p&gt;Android 中每个应用的进程都 fork 自 Zygote 进程， Zygote 进程在启动时自己会创建一个虚拟机，从而也就让每个应用拥有了自己的虚拟机。&lt;br /&gt;
当应用涉及多进程时，想当于启动了多个虚拟机，在单进程情况下的一些情景将会失效:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 源码中的单例模式</title>
        <link>https://jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 21 Jul 2018 11:23:53 +0000</pubDate>
        
        <atom:modified>Sat, 21 Jul 2018 11:23:53 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;经常使用 &lt;code&gt;Context.getSystemService(String name)&lt;/code&gt; 获取一些系统服务。 其实这些服务都是以单例的方式注册在系统中的。 获取到的都是单例对象。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android控件架构</title>
        <link>https://jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</link>
        <pubDate>Mon, 09 Jul 2018 22:38:12 +0000</pubDate>
        
        <atom:modified>Mon, 09 Jul 2018 22:38:12 +0000</atom:modified>
        <guid>https://jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-7-9/65379561.jpg&#34; alt=&#34;View树结构&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>
