<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Posts on Yang Blog</title>
    <link>https://blog.jiyang.site/posts/</link>
    <description>Recent content in Posts on Yang Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>©{year}, All Rights Reserved</copyright>
    <lastBuildDate>Fri, 02 Jul 2021 09:08:07 +0800</lastBuildDate>
    
        <atom:link href="https://blog.jiyang.site/posts/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>Android Opengl OES 纹理渲染到 GL_TEXTURE_2D</title>
        <link>https://blog.jiyang.site/posts/android_opengl_oes_to_2d/</link>
        <pubDate>Fri, 02 Jul 2021 09:08:07 +0800</pubDate>
        
        <atom:modified>Fri, 02 Jul 2021 09:08:07 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/android_opengl_oes_to_2d/</guid>
        <description>背景 在客户端中存在一种应用场景：需要将 MediaCodec 或者 Camera 产生的图像，通过 OpenGL 交给算法做特效，由于算法可能是基于普通的 Texture2D 纹理实现的，而 Android 上更常用的则是 GL_TEXTURE_EXTERNAL_OES 纹</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
          
        
        
          
            
          
        
        
      </item>
      
      <item>
        <title>通过分析mobile Ffmpeg解析如何优雅的集成ffmpeg到Android应用中</title>
        <link>https://blog.jiyang.site/posts/mobile_ffmpeg_compile/</link>
        <pubDate>Sun, 21 Mar 2021 20:34:57 +0800</pubDate>
        
        <atom:modified>Sun, 21 Mar 2021 20:34:57 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/mobile_ffmpeg_compile/</guid>
        <description>背景 FFmpeg 是一个开源的、强大的音视频工具库，平常情况下的使用方法一般是利用编译好的 ffmpeg 程序，在 PC 上使用，需要不同的功能时只需传递不同的参数即可，而</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>FFmpeg</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>音频波形图绘制</title>
        <link>https://blog.jiyang.site/posts/audio_waveform/</link>
        <pubDate>Mon, 08 Mar 2021 21:13:34 +0800</pubDate>
        
        <atom:modified>Mon, 08 Mar 2021 21:13:34 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/audio_waveform/</guid>
        <description>背景 最近需要上线一个音乐编辑功能，需要展示音乐的波形图(如下图)。 期待效果 初步效果 首先这样的波形图，是根据音频在采样点的采样值来绘制的。像 mp3</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Audio</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>解决 Unity 2020 导出项目到 Android 中 So 加载问题</title>
        <link>https://blog.jiyang.site/posts/unity-export-android-library-so-not-found/</link>
        <pubDate>Wed, 20 Jan 2021 18:17:41 +0800</pubDate>
        
        <atom:modified>Wed, 20 Jan 2021 18:17:41 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/unity-export-android-library-so-not-found/</guid>
        <description>问题 Unity 项目将版本从 2018 升级到 2020 版本之后，导出集成到 Android 项目时，运行时报错找不到 libmain.so。 java.lang.UnsatisfiedLinkError: dlopen failed: library &amp;quot;/data/app/xxx/lib/arm/libmain.so&amp;quot; not found 原因 最终找到了根本原因： Unity 2020 版</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Compile And Run FFmpeg Examples</title>
        <link>https://blog.jiyang.site/posts/compile-and-run-ffmpeg-examples/</link>
        <pubDate>Thu, 26 Nov 2020 22:20:19 +0800</pubDate>
        
        <atom:modified>Thu, 26 Nov 2020 22:20:19 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/compile-and-run-ffmpeg-examples/</guid>
        <description>FFmpeg 的源码仓库在 doc/examples 目录中提供了一些基本的 FFmpeg Api 使用方法。但是在我想运行这些例子时，却尝试了很久才编译出来可运行的例子。因为 FFmpeg 的 readme 中只大概提到了如</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>FFmpeg</category>
            
          
        
        
          
            
          
        
        
      </item>
      
      <item>
        <title>Android 上 FFMpeg 和 MediaCodec 视频解码效率对比</title>
        <link>https://blog.jiyang.site/posts/android-ffmpeg-vs-mediacodec-video-decode/</link>
        <pubDate>Sat, 05 Sep 2020 22:41:45 +0800</pubDate>
        
        <atom:modified>Sat, 05 Sep 2020 22:41:45 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/android-ffmpeg-vs-mediacodec-video-decode/</guid>
        <description>视频编码格式为: H264, 封装格式为: mp4 外部参考: 手机CPU性能天梯图 手机Soc性能排行榜 能耗对比: 解码1080P 编码1080P 左边是硬件Codec</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>FFmpeg</category>
            
          
            
              <category>MediaCodec</category>
            
          
            
              <category>Video</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 处理 Native Crash</title>
        <link>https://blog.jiyang.site/posts/collect-android-so-crash/</link>
        <pubDate>Sun, 14 Jun 2020 21:03:54 +0800</pubDate>
        
        <atom:modified>Sun, 14 Jun 2020 21:03:54 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/collect-android-so-crash/</guid>
        <description>在 Android 上，native 层的代码出现问题时，系统内核将会发送一些信号到应用进程，应用进程可以通过自定义信号的处理过程来实现 native crash 的收集等工作。 Linux 信</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>ELF</category>
            
          
            
              <category>DWARF</category>
            
          
            
              <category>Signal</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>GNU C 避免宏定义产生副作用</title>
        <link>https://blog.jiyang.site/posts/gnu-c-%E9%81%BF%E5%85%8D%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BA%A7%E7%94%9F%E5%89%AF%E4%BD%9C%E7%94%A8/</link>
        <pubDate>Sun, 14 Jun 2020 00:08:04 +0800</pubDate>
        
        <atom:modified>Sun, 14 Jun 2020 00:08:04 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/gnu-c-%E9%81%BF%E5%85%8D%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BA%A7%E7%94%9F%E5%89%AF%E4%BD%9C%E7%94%A8/</guid>
        <description>在编写 c/c++ 代码时，我们通常使用 #define 定义一些宏，然后编译器在 预处理 阶段会把用到宏的地方替换为宏的内容，由于宏的替换完全是一种文本替换，所以在一些情</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>代码工程</category>
            
          
        
        
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>C库的IO缓存机制</title>
        <link>https://blog.jiyang.site/posts/libc-io-cache/</link>
        <pubDate>Sat, 30 May 2020 21:53:39 +0800</pubDate>
        
        <atom:modified>Sat, 30 May 2020 21:53:39 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/libc-io-cache/</guid>
        <description>缓存分类 块缓存 一般用于访问真正的磁盘文件。C库会为文件访问申请一块内存，只有当文件内容将缓存块填满或执行冲刷函数flush时，C库才会将缓存</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>libc</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Kotlin 协程的实现原理简析</title>
        <link>https://blog.jiyang.site/posts/kotlin-coroutine-inner/</link>
        <pubDate>Sun, 10 May 2020 23:14:27 +0800</pubDate>
        
        <atom:modified>Sun, 10 May 2020 23:14:27 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/kotlin-coroutine-inner/</guid>
        <description>背景: 使用 Kotlin Coroutine 的使用方法，参照官方文档食用即可。这里只简单给出一些概念。 suspend ​使用 suspend 表示函数支持挂起操作，目的在于告诉编译器，该方法可能产生阻</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Kotlin</category>
            
          
        
        
      </item>
      
      <item>
        <title>树莓派OS#0x02 处理器初始化</title>
        <link>https://blog.jiyang.site/posts/rpios-processor-init/</link>
        <pubDate>Mon, 04 May 2020 09:10:45 +0800</pubDate>
        
        <atom:modified>Mon, 04 May 2020 09:10:45 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/rpios-processor-init/</guid>
        <description>Exception Level https://developer.arm.com/docs/ddi0488/d/programmers-model/armv8-architecture-concepts/exception-levels 在 ARMv8 处理器中，处理器的运行总是发生在 4 个异常级别之中的一个。异常级别决定了权限级别(privilege level)，每个异常级别(EL</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>RPI_OS</category>
            
          
        
        
          
            
              <category>操作系统</category>
            
          
        
        
      </item>
      
      <item>
        <title>使用 OnFrameMetricsAvailableListener 统计绘制耗时</title>
        <link>https://blog.jiyang.site/posts/%E4%BD%BF%E7%94%A8-onframemetricsavailablelistener-%E7%BB%9F%E8%AE%A1%E7%BB%98%E5%88%B6%E8%80%97%E6%97%B6/</link>
        <pubDate>Tue, 21 Apr 2020 22:12:00 +0800</pubDate>
        
        <atom:modified>Tue, 21 Apr 2020 22:12:00 +0800</atom:modified>
        <guid>https://blog.jiyang.site/posts/%E4%BD%BF%E7%94%A8-onframemetricsavailablelistener-%E7%BB%9F%E8%AE%A1%E7%BB%98%E5%88%B6%E8%80%97%E6%97%B6/</guid>
        <description>在 Android 7.0, 增加了一个 Api 可以方便的统计一个 Window 的 View 树的绘制耗时。 功能 统计渲染子系统报告的帧生命周期中各个里程碑的时序数据。可以通过其相应的标识符查询</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>AnimatorSet Cancel 在 Android 8 和以下版的行为不一致坑</title>
        <link>https://blog.jiyang.site/posts/2020-04-16-animatorset-cancel-android8-%E5%92%8C%E4%BB%A5%E4%B8%8B%E7%89%88%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9D%91/</link>
        <pubDate>Thu, 16 Apr 2020 23:57:42 +0000</pubDate>
        
        <atom:modified>Thu, 16 Apr 2020 23:57:42 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-04-16-animatorset-cancel-android8-%E5%92%8C%E4%BB%A5%E4%B8%8B%E7%89%88%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9D%91/</guid>
        <description>问题背景： 有个动画在 onAnimatorEnd 回调中间接调用了 Animator#cancel。在 Android 8 没有问题，但是在 Android 5, Android 6 等版本出现了下面的递归调用。 java.lang.StackOverflowError: stack size 8MB ... at</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>TextView 的布局细节</title>
        <link>https://blog.jiyang.site/posts/2020-04-10-textview-%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/</link>
        <pubDate>Fri, 10 Apr 2020 23:14:33 +0000</pubDate>
        
        <atom:modified>Fri, 10 Apr 2020 23:14:33 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-04-10-textview-%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/</guid>
        <description>TextView 在布局方面提供了一些特别的属性来控制文本的布局。比如现在要显示一个句子 What is a good time for you?。 TextView 在发现一行布局不足以显示整个文本内容时，会进</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>记最近做的冷启动耗时优化</title>
        <link>https://blog.jiyang.site/posts/2020-03-28-%E8%AE%B0%E6%9C%80%E8%BF%91%E5%81%9A%E7%9A%84%E5%86%B7%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E4%BC%98%E5%8C%96/</link>
        <pubDate>Sat, 28 Mar 2020 19:39:43 +0000</pubDate>
        
        <atom:modified>Sat, 28 Mar 2020 19:39:43 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-28-%E8%AE%B0%E6%9C%80%E8%BF%91%E5%81%9A%E7%9A%84%E5%86%B7%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E4%BC%98%E5%8C%96/</guid>
        <description>背景 最近公司 Client Infra 开始专项整治各业务线的应用启动耗时，我负责和架构组同事对接我们业务组的启动耗时优化工作。 整个优化工作大致的流程如下: 定位耗时</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>树莓派OS-#0x01-理解Linux内核的初始化流程</title>
        <link>https://blog.jiyang.site/posts/2020-03-28-%E5%AE%9E%E7%8E%B0rpi-os-b-%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Sat, 28 Mar 2020 14:23:25 +0000</pubDate>
        
        <atom:modified>Sat, 28 Mar 2020 14:23:25 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-28-%E5%AE%9E%E7%8E%B0rpi-os-b-%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</guid>
        <description>源码结构 1 2 3 4 5 6 7 8 9 10 11 12 ➜ linux-master tree -L 1 . ├── Kbuild ├── Kconfig ├── Makefile ├── arch ├── drivers ├── fs ├── include ├── init ├── kernel ├── mm 与内核初始化过程</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>RPI_OS</category>
            
          
        
        
          
            
              <category>操作系统</category>
            
          
        
        
      </item>
      
      <item>
        <title>让 Annotation Processor 支持增量编译</title>
        <link>https://blog.jiyang.site/posts/2020-03-24-%E8%AE%A9annotation-processor-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</link>
        <pubDate>Tue, 24 Mar 2020 21:08:39 +0000</pubDate>
        
        <atom:modified>Tue, 24 Mar 2020 21:08:39 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-24-%E8%AE%A9annotation-processor-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</guid>
        <description>Java 的增量编译 Gradle 在 5.0 增加了对 Java 增量编译的支持，通过增量编译，我们能够获得一些优点： 更少的编译耗时 更少的字节码修改 增量编译概览： Gradle 会重新编译受更</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>当我尝试自己实现TLS时，我遇到了这些问题</title>
        <link>https://blog.jiyang.site/posts/2020-03-15-%E5%BD%93%E6%88%91%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0tls%E6%97%B6%E6%88%91%E9%81%87%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98/</link>
        <pubDate>Sun, 15 Mar 2020 13:23:43 +0000</pubDate>
        
        <atom:modified>Sun, 15 Mar 2020 13:23:43 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-15-%E5%BD%93%E6%88%91%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0tls%E6%97%B6%E6%88%91%E9%81%87%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98/</guid>
        <description>花费接近一周的业余时间，基本实现了基于 TLS 1.2 的通信过程。在这期间遇到了许多问题，在此记录。 实现的源码在: https://github.com/stefanJi/CNP/tree/master/TLSImpl 字节序问题 由于我代码使用基于 JVM 的语言</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>TLS</category>
            
          
        
        
          
            
              <category>计算机网络</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android VM 的启动流程以及 JNI 的通信原理</title>
        <link>https://blog.jiyang.site/posts/2020-03-06-androidruntime%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Fri, 06 Mar 2020 23:36:51 +0000</pubDate>
        
        <atom:modified>Fri, 06 Mar 2020 23:36:51 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-06-androidruntime%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        <description>详细分析在 zygote 的启动流程中, Android 的 Art/Dalvik VM 是如果启动的；以及 Android 为支持 JNI 调用做了哪些工作。 Init Android 系统在启动之后, Linux 内核的启动进程 init 进程将会启动 system/bin/app_process 程序, 其</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Java的动态分派和静态分派</title>
        <link>https://blog.jiyang.site/posts/2020-03-03-java%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE/</link>
        <pubDate>Tue, 03 Mar 2020 21:17:54 +0000</pubDate>
        
        <atom:modified>Tue, 03 Mar 2020 21:17:54 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-03-java%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE/</guid>
        <description>Java 方法执行时的动态分派和静态分派是 Java 实现多态的本质 背景 Java 的动态分派和静态分派也是 Java 方法的执行原理。 Java 源代码的编译之后，方法之间的调用是使用符</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>JVM</category>
            
          
        
        
      </item>
      
      <item>
        <title>树莓派OS-#0x00-自制系统镜像并控制处理器的运行</title>
        <link>https://blog.jiyang.site/posts/2020-03-01-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B6%85%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Sun, 01 Mar 2020 00:14:42 +0000</pubDate>
        
        <atom:modified>Sun, 01 Mar 2020 00:14:42 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-03-01-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B6%85%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>raspberry-pi-os 项目记录了从头实现一个适用于树莓派3B(处理器 ARMv8 架构)的操作系统的过程。这篇文章记录了我按照项目的 lesson01 学习的过程，另外再加上自己的修改。 内容</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>RPI_OS</category>
            
          
        
        
          
            
              <category>操作系统</category>
            
          
        
        
      </item>
      
      <item>
        <title>一种 Android 项目的模块化开发机制</title>
        <link>https://blog.jiyang.site/posts/2020-02-05-%E4%B8%80%E7%A7%8D-android-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Wed, 05 Feb 2020 23:35:19 +0000</pubDate>
        
        <atom:modified>Wed, 05 Feb 2020 23:35:19 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-02-05-%E4%B8%80%E7%A7%8D-android-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        <description>在 Android 开发中，当项目增加一定规模之后，一般都会采用多模块的项目结构。当然也能采用插件化的开发模式，具体采用什么开发模式，开发者可以自行定夺。这</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>打开转盘锁</title>
        <link>https://blog.jiyang.site/posts/2020-01-30-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</link>
        <pubDate>Thu, 30 Jan 2020 20:35:12 +0000</pubDate>
        
        <atom:modified>Thu, 30 Jan 2020 20:35:12 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-30-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</guid>
        <description>问题 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &amp;lsquo;0&amp;rsquo;, &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;, &amp;lsquo;3&amp;rsquo;, &amp;lsquo;4&amp;rsquo;, &amp;lsquo;5&amp;rsquo;, &amp;lsquo;6&amp;rsquo;, &amp;lsquo;7&amp;rsquo;, &amp;lsquo;8&amp;rsquo;, &amp;lsquo;9&amp;rsquo; 。每个拨轮可以自由旋转：例如把 &amp;lsquo;9&amp;rsquo; 变为 &amp;lsquo;0&amp;rs</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>使用Java解析class字节码结构</title>
        <link>https://blog.jiyang.site/posts/2020-01-20-%E4%BD%BF%E7%94%A8java%E8%A7%A3%E6%9E%90class%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/</link>
        <pubDate>Mon, 20 Jan 2020 17:59:51 +0000</pubDate>
        
        <atom:modified>Mon, 20 Jan 2020 17:59:51 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-20-%E4%BD%BF%E7%94%A8java%E8%A7%A3%E6%9E%90class%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/</guid>
        <description>按照JVM 字节码的存储格式 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html 规范，实现了一段程序解析字节码结构。 结果输出 ========== Start Parse========= == Magic Number ====================================== MagicNumber{b1=CA, b2=FE, b3=BA, b4=BE} == Version ====================================== Version{minorVersion=0, majorVersion=52} == Constant Pool ====================================== ConstantPool{poolCount=214, constantsSize=2376, mConstantItems= #1 MethodRef{classInfoIndex=65, nameAndTypeIndex=130} #2 String{index=131} ... #213 Utf8{attributeLength=20, value=&#39;()Ljava/lang/String;&#39;} } ==</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>ViewModel 的实现原理</title>
        <link>https://blog.jiyang.site/posts/2020-01-12-viewmodel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 12 Jan 2020 16:26:07 +0000</pubDate>
        
        <atom:modified>Sun, 12 Jan 2020 16:26:07 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-12-viewmodel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>Android Jetpack 提供了 ViewModel, 以用来维护 Activity 或 Fragment 中需要的数据。其能够在因配置改变(比如屏幕旋转)造成的 Activity 和 Fragment 重建时, 依然维护其内部的数据。 背景 首先，根据官方文档</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android Binder</title>
        <link>https://blog.jiyang.site/posts/2020-01-06-android-binder/</link>
        <pubDate>Mon, 06 Jan 2020 23:03:06 +0000</pubDate>
        
        <atom:modified>Mon, 06 Jan 2020 23:03:06 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-06-android-binder/</guid>
        <description>一篇对 Android 主要的 IPC 机制(Binder) 的记录，理解自一份 RUB(https://en.wikipedia.org/wiki/Ruhr_Univ</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解Linux内部网络实现之关键数据结构 net_device</title>
        <link>https://blog.jiyang.site/posts/2020-01-05-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-net_device/</link>
        <pubDate>Sun, 05 Jan 2020 11:15:35 +0000</pubDate>
        
        <atom:modified>Sun, 05 Jan 2020 11:15:35 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-05-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-net_device/</guid>
        <description>Understanding Linux Networking internal 系列之 Critical Data Structures 背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>读书笔记</category>
            
          
            
              <category>Linux</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解Linux内部网络实现之关键数据结构 sk_buff</title>
        <link>https://blog.jiyang.site/posts/2020-01-02-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-sk_buff/</link>
        <pubDate>Thu, 02 Jan 2020 23:49:09 +0000</pubDate>
        
        <atom:modified>Thu, 02 Jan 2020 23:49:09 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2020-01-02-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-sk_buff/</guid>
        <description>Understanding Linux Networking internal 系列之 Critical Data Structures 背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>Linux</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>实现Arp报文发送和接收</title>
        <link>https://blog.jiyang.site/posts/2019-12-27-%E5%AE%9E%E7%8E%B0arp%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6/</link>
        <pubDate>Fri, 27 Dec 2019 20:33:51 +0000</pubDate>
        
        <atom:modified>Fri, 27 Dec 2019 20:33:51 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-12-27-%E5%AE%9E%E7%8E%B0arp%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6/</guid>
        <description>继上次实现了 Ping 之后，尝试进入更底层的网络接口层实现局域网的 ARP 报文收发 ARP 协议概述 ARP(Address Resolution Protocol) 地址解析协议是用来通过网络层地址(IP地址)去寻找数据链</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>ARP</category>
            
          
        
        
          
            
              <category>计算机网络</category>
            
          
        
        
      </item>
      
      <item>
        <title>实现 ping Utility</title>
        <link>https://blog.jiyang.site/posts/2019-12-15-%E5%AE%9E%E7%8E%B0-ping-utility/</link>
        <pubDate>Sun, 15 Dec 2019 22:25:43 +0000</pubDate>
        
        <atom:modified>Sun, 15 Dec 2019 22:25:43 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-12-15-%E5%AE%9E%E7%8E%B0-ping-utility/</guid>
        <description>为了加深自己对计算机网络的理解, 想自己实现一些操作系统提供的网络工具, 于是先从 ping 开始 首先, ping 命令的作用是检测两个网络设备在 TCP/IP 网络下是否能连通</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>ICMP</category>
            
          
        
        
          
            
              <category>计算机网络</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解 WorkManager 的实现</title>
        <link>https://blog.jiyang.site/posts/2019-12-07-%E7%90%86%E8%A7%A3-workmanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 07 Dec 2019 19:17:41 +0000</pubDate>
        
        <atom:modified>Sat, 07 Dec 2019 19:17:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-12-07-%E7%90%86%E8%A7%A3-workmanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;p&gt;最近使用 Android Jetpack 中 WorkManager 组件做了一个上报一些做分析用途数据的需求, 用着感觉挺香的. 于是想看下其内部的实现原理.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>岛屿数量</title>
        <link>https://blog.jiyang.site/posts/2019-12-03-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
        <pubDate>Tue, 03 Dec 2019 10:03:12 +0000</pubDate>
        
        <atom:modified>Tue, 03 Dec 2019 10:03:12 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-12-03-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
        <description>&lt;p&gt;给定一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>BFS 广度优先搜索</title>
        <link>https://blog.jiyang.site/posts/2019-11-30-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</link>
        <pubDate>Sat, 30 Nov 2019 14:29:33 +0000</pubDate>
        
        <atom:modified>Sat, 30 Nov 2019 14:29:33 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-30-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</guid>
        <description>&lt;p&gt;之前看过的 BFS(Breadth First Search), 最近遇到类似问题时却没有想起. 在此再回顾一下, 并留下记录. 好记性毕竟不如坏笔头.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>BFS</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>Java 和 Android 的异常处理流程</title>
        <link>https://blog.jiyang.site/posts/2019-11-22-java-%E5%92%8C-android-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Fri, 22 Nov 2019 19:08:59 +0000</pubDate>
        
        <atom:modified>Fri, 22 Nov 2019 19:08:59 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-22-java-%E5%92%8C-android-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</guid>
        <description>&lt;p&gt;理清 Java 和 Android 的线程异常处理&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>洗牌-乱序一个数组</title>
        <link>https://blog.jiyang.site/posts/2019-11-21-%E6%B4%97%E7%89%8C-%E4%B9%B1%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</link>
        <pubDate>Thu, 21 Nov 2019 21:06:23 +0000</pubDate>
        
        <atom:modified>Thu, 21 Nov 2019 21:06:23 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-21-%E6%B4%97%E7%89%8C-%E4%B9%B1%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/</guid>
        <description>&lt;p&gt;设计一个方法, 把一个数组随机打乱, 每一个元素不能在原来的位置上&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解 Fragment</title>
        <link>https://blog.jiyang.site/posts/2019-11-08-%E7%90%86%E8%A7%A3-fragment/</link>
        <pubDate>Fri, 08 Nov 2019 21:53:37 +0000</pubDate>
        
        <atom:modified>Fri, 08 Nov 2019 21:53:37 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-08-%E7%90%86%E8%A7%A3-fragment/</guid>
        <description>&lt;p&gt;理解 Fragment 的实现原理, FragmentTransaction 的事务机制等.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>螺旋输出矩阵</title>
        <link>https://blog.jiyang.site/posts/2019-11-07-%E8%9E%BA%E6%97%8B%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5/</link>
        <pubDate>Thu, 07 Nov 2019 21:09:59 +0000</pubDate>
        
        <atom:modified>Thu, 07 Nov 2019 21:09:59 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-07-%E8%9E%BA%E6%97%8B%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5/</guid>
        <description>&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;一个 m*n 的矩阵, 螺旋遍历输出每一项. 比如:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>HTTPS 的 TLS 握手</title>
        <link>https://blog.jiyang.site/posts/2019-11-05-https-%E7%9A%84-tls-%E6%8F%A1%E6%89%8B/</link>
        <pubDate>Tue, 05 Nov 2019 16:30:30 +0000</pubDate>
        
        <atom:modified>Tue, 05 Nov 2019 16:30:30 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-05-https-%E7%9A%84-tls-%E6%8F%A1%E6%89%8B/</guid>
        <description>&lt;p&gt;通过 Wireshark 抓包理解 HTTPS 的 SSL/TLS 握手&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>TLS</category>
            
          
        
        
          
            
              <category>计算机网络</category>
            
          
        
        
      </item>
      
      <item>
        <title>记一次 DialogFragment 造成的内存泄漏</title>
        <link>https://blog.jiyang.site/posts/2019-11-01-%E8%AE%B0%E4%B8%80%E6%AC%A1-dialogfragment-%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</link>
        <pubDate>Fri, 01 Nov 2019 21:18:19 +0000</pubDate>
        
        <atom:modified>Fri, 01 Nov 2019 21:18:19 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-11-01-%E8%AE%B0%E4%B8%80%E6%AC%A1-dialogfragment-%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</guid>
        <description>&lt;p&gt;最近 Leak Canrray 检测出了 Activity/ReportFragment 被泄漏。发现引用其的 GC Root 竟然是一个 HandlerThread。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>内存泄漏</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>关于 std::move</title>
        <link>https://blog.jiyang.site/posts/2019-10-27-%E5%85%B3%E4%BA%8E-std-move/</link>
        <pubDate>Sun, 27 Oct 2019 14:34:11 +0000</pubDate>
        
        <atom:modified>Sun, 27 Oct 2019 14:34:11 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-10-27-%E5%85%B3%E4%BA%8E-std-move/</guid>
        <description>&lt;p&gt;最近在看一些框架的 c++ 源码中, 发现它们在许多函数传参时会使用 &lt;code&gt;std::move&lt;/code&gt; 调用, 于是想弄清这个目的是什么.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>cpp</category>
            
          
        
        
      </item>
      
      <item>
        <title>小根堆-大根堆</title>
        <link>https://blog.jiyang.site/posts/2019-10-24-%E5%B0%8F%E6%A0%B9%E5%A0%86/</link>
        <pubDate>Thu, 24 Oct 2019 22:41:02 +0000</pubDate>
        
        <atom:modified>Thu, 24 Oct 2019 22:41:02 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-10-24-%E5%B0%8F%E6%A0%B9%E5%A0%86/</guid>
        <description>&lt;p&gt;理解堆的定义, 使用堆实现一个优先级队列, 查看 &lt;code&gt;java.util.Timer&lt;/code&gt; 中的小根堆实现&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>树</category>
            
          
            
              <category>堆</category>
            
          
        
        
          
            
              <category>数据结构</category>
            
          
        
        
      </item>
      
      <item>
        <title>Flutter 在 Android 上是如何运行起来的</title>
        <link>https://blog.jiyang.site/posts/2019-10-20-flutter-%E5%9C%A8-android-%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/</link>
        <pubDate>Sun, 20 Oct 2019 20:35:05 +0000</pubDate>
        
        <atom:modified>Sun, 20 Oct 2019 20:35:05 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-10-20-flutter-%E5%9C%A8-android-%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/</guid>
        <description>Flutter 应用运行的本质还是原生应用的运行。那么在 Android 上, Flutter 框架是如何运行起来的呢? 本文基于 Flutter v1.10.5 版本源码 先回想下编写一个纯 Flutter 应用的场景: 创建项目, flutter create</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Flutter</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 中 MessageQueue 的 nativePollOnce</title>
        <link>https://blog.jiyang.site/posts/2019-10-19-android%E4%B8%ADmessagequeue%E7%9A%84nativepollonce/</link>
        <pubDate>Sat, 19 Oct 2019 20:53:02 +0000</pubDate>
        
        <atom:modified>Sat, 19 Oct 2019 20:53:02 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-10-19-android%E4%B8%ADmessagequeue%E7%9A%84nativepollonce/</guid>
        <description>&lt;p&gt;Android SDK 中的事件循环已经是一个老生常谈的问题了, 像 &lt;code&gt;Handler&lt;/code&gt; &lt;code&gt;Looper&lt;/code&gt; &lt;code&gt;MessageQueue&lt;/code&gt; 这几个类也是被大家研究透彻了.&lt;br /&gt;
但是再回头看以前自己的分析, 总感觉差点什么, 不够透彻. 心里隐隐感觉自己没有把事情完全吃透, 于是今日又回顾 Android 中的事件循环机制, 注意到&lt;br /&gt;
&lt;code&gt;MessageQueue&lt;/code&gt; 中获取下一条消息时会执行一个 native 调用 &lt;code&gt;nativePollOnce&lt;/code&gt;, 翻看 Android 系统源码发现有内容.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>优化 ObjectOutputStream 的使用</title>
        <link>https://blog.jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</link>
        <pubDate>Fri, 18 Oct 2019 14:42:25 +0000</pubDate>
        
        <atom:modified>Fri, 18 Oct 2019 14:42:25 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;p&gt;最近阅读《Android移动性能实战》看到手机QQ测试团队给出的一个案列 「Object Ouput Stream 4000 多次的写操作」,&lt;br /&gt;
其原因就是直接使用了 &lt;code&gt;ObjectOutputStream&lt;/code&gt; + &lt;code&gt;FileOutputStream&lt;/code&gt; 做对象的序列化到磁盘。印象中我们的项目中也有这样的代码&lt;br /&gt;
&lt;code&gt;SerializeUtil#serializeObject&lt;/code&gt;:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android init 进程的启动过程</title>
        <link>https://blog.jiyang.site/posts/2019-09-12-android-init-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link>
        <pubDate>Thu, 12 Sep 2019 13:28:41 +0000</pubDate>
        
        <atom:modified>Thu, 12 Sep 2019 13:28:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-09-12-android-init-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程是 Android 系统中用户空间的第一个进程，进程号为 1。作为第一个进程，它被赋予了很多重要的职责，比如创建 &lt;code&gt;Zygote&lt;/code&gt; 进程和属性服务等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; 进程由多个源文件共同组成，这些文件位于源码目录 &lt;code&gt;system/core/init&lt;/code&gt; 中。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>LifeCycle 原理</title>
        <link>https://blog.jiyang.site/posts/2019-07-14-lifecycle-%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 14 Jul 2019 11:27:50 +0000</pubDate>
        
        <atom:modified>Sun, 14 Jul 2019 11:27:50 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-07-14-lifecycle-%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;p&gt;&lt;a href=&#34;https://developer.android.com/reference/android/arch/lifecycle/Lifecycle&#34;&gt;LifeCycle&lt;/a&gt; Android 架构组件。&lt;/p&gt;
&lt;p&gt;其目的是: 方便开发者能从 Activity Fragment 的生命周期回调中解放，让开发者能自由的创建监听生命周期回调的组件。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>装饰者模式</title>
        <link>https://blog.jiyang.site/posts/2019-06-29-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 29 Jun 2019 14:22:44 +0000</pubDate>
        
        <atom:modified>Sat, 29 Jun 2019 14:22:44 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-06-29-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;使用装饰者模式代替单纯的继承，更好的实现功能的扩展&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>使用Android Studio Code 模板提高编码效率</title>
        <link>https://blog.jiyang.site/posts/2019-06-23-%E4%BD%BF%E7%94%A8android-studio-code-%E6%A8%A1%E6%9D%BF%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87/</link>
        <pubDate>Sun, 23 Jun 2019 15:50:41 +0000</pubDate>
        
        <atom:modified>Sun, 23 Jun 2019 15:50:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-06-23-%E4%BD%BF%E7%94%A8android-studio-code-%E6%A8%A1%E6%9D%BF%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87/</guid>
        <description>&lt;p&gt;在工作中最近的一个业务上，每次新加一个同一类的功能时，发现会创建许多类似的类，写类似的代码。就思考能否通过模板的方式提高新建同类功能的效率，于是通过搜索发现 IDE 支持的 FreeMaker.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>理解 Flutter 中的 Key</title>
        <link>https://blog.jiyang.site/posts/2019-06-01-%E7%90%86%E8%A7%A3-flutter-%E4%B8%AD%E7%9A%84-key/</link>
        <pubDate>Sat, 01 Jun 2019 13:43:49 +0000</pubDate>
        
        <atom:modified>Sat, 01 Jun 2019 13:43:49 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-06-01-%E7%90%86%E8%A7%A3-flutter-%E4%B8%AD%E7%9A%84-key/</guid>
        <description>&lt;p&gt;通过实际案列理解 Flutter 中 Key 在其渲染机制中起到的作用，从而达到能在合理的时间和地点使用合理的 Key&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Flutter</category>
            
          
        
        
      </item>
      
      <item>
        <title>Ubuntu 新建用户并配置SSH Key登录</title>
        <link>https://blog.jiyang.site/posts/2019-05-25-ubuntu-%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%85%8D%E7%BD%AEssh-key%E7%99%BB%E5%BD%95/</link>
        <pubDate>Sat, 25 May 2019 09:26:27 +0000</pubDate>
        
        <atom:modified>Sat, 25 May 2019 09:26:27 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-05-25-ubuntu-%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%85%8D%E7%BD%AEssh-key%E7%99%BB%E5%BD%95/</guid>
        <description>&lt;p&gt;记录在 Ubuntu Server 上创建用户，并配置其通过 SSH Key File 登录的操作&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Ubuntu</category>
            
          
        
        
      </item>
      
      <item>
        <title>工厂方法模式</title>
        <link>https://blog.jiyang.site/posts/2019-05-19-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sun, 19 May 2019 19:56:52 +0000</pubDate>
        
        <atom:modified>Sun, 19 May 2019 19:56:52 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-05-19-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;在需要生成复杂对象的地方，可以使用工厂方法模式。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Kotlin 必须要知道的 inline noinline crossinline</title>
        <link>https://blog.jiyang.site/posts/2019-04-30-kotlin-inline-noinline-crossinline/</link>
        <pubDate>Tue, 30 Apr 2019 10:55:41 +0000</pubDate>
        
        <atom:modified>Tue, 30 Apr 2019 10:55:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-04-30-kotlin-inline-noinline-crossinline/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Kotlin</category>
            
          
        
        
      </item>
      
      <item>
        <title>使程序运行更高效-原型模式</title>
        <link>https://blog.jiyang.site/posts/2019-04-27-%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 27 Apr 2019 09:45:31 +0000</pubDate>
        
        <atom:modified>Sat, 27 Apr 2019 09:45:31 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-04-27-%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>通过 Wireshark 看网络分层</title>
        <link>https://blog.jiyang.site/posts/2019-04-13-%E9%80%9A%E8%BF%87wireshark%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</link>
        <pubDate>Sat, 13 Apr 2019 13:23:06 +0000</pubDate>
        
        <atom:modified>Sat, 13 Apr 2019 13:23:06 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-04-13-%E9%80%9A%E8%BF%87wireshark%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>计算机网络</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>时势造英雄-策略模式</title>
        <link>https://blog.jiyang.site/posts/2019-04-01-%E6%97%B6%E5%8A%BF%E9%80%A0%E8%8B%B1%E9%9B%84-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Mon, 01 Apr 2019 22:41:06 +0000</pubDate>
        
        <atom:modified>Mon, 01 Apr 2019 22:41:06 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-04-01-%E6%97%B6%E5%8A%BF%E9%80%A0%E8%8B%B1%E9%9B%84-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>应用最广的模式-单例模式</title>
        <link>https://blog.jiyang.site/posts/2019-03-22-%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E7%9A%84%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Fri, 22 Mar 2019 20:09:17 +0000</pubDate>
        
        <atom:modified>Fri, 22 Mar 2019 20:09:17 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-03-22-%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E7%9A%84%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Flutter 自定义绘制控件</title>
        <link>https://blog.jiyang.site/posts/2019-03-16-flutter-custom-paint/</link>
        <pubDate>Sat, 16 Mar 2019 15:42:50 +0000</pubDate>
        
        <atom:modified>Sat, 16 Mar 2019 15:42:50 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-03-16-flutter-custom-paint/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Flutter</category>
            
          
        
        
      </item>
      
      <item>
        <title>Dart中的异步编程</title>
        <link>https://blog.jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Fri, 15 Mar 2019 22:45:42 +0000</pubDate>
        
        <atom:modified>Fri, 15 Mar 2019 22:45:42 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Dart</category>
            
          
        
        
      </item>
      
      <item>
        <title>Dart中的Mixin</title>
        <link>https://blog.jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84mixin/</link>
        <pubDate>Fri, 15 Mar 2019 22:06:38 +0000</pubDate>
        
        <atom:modified>Fri, 15 Mar 2019 22:06:38 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84mixin/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Dart</category>
            
          
        
        
      </item>
      
      <item>
        <title>Dartlang</title>
        <link>https://blog.jiyang.site/posts/2019-03-01-dartlang/</link>
        <pubDate>Fri, 01 Mar 2019 15:09:34 +0000</pubDate>
        
        <atom:modified>Fri, 01 Mar 2019 15:09:34 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-03-01-dartlang/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Dart</category>
            
          
        
        
      </item>
      
      <item>
        <title>面向对象六大原则</title>
        <link>https://blog.jiyang.site/posts/2019-02-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</link>
        <pubDate>Thu, 21 Feb 2019 12:16:57 +0000</pubDate>
        
        <atom:modified>Thu, 21 Feb 2019 12:16:57 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-02-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</guid>
        <description>六大原则简单描述 单一职责原则：一个类中应该是相关性很强的一类函数。 开闭原则：对扩展开放，对修改封闭。实现扩展的方法是使用抽象和依赖注入。将可</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>设计模式</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>How to be a better android developer</title>
        <link>https://blog.jiyang.site/posts/2019-01-14-how-to-be-a-better-android-developer/</link>
        <pubDate>Mon, 14 Jan 2019 08:34:03 +0000</pubDate>
        
        <atom:modified>Mon, 14 Jan 2019 08:34:03 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-01-14-how-to-be-a-better-android-developer/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android系统启动简介</title>
        <link>https://blog.jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</link>
        <pubDate>Tue, 01 Jan 2019 18:53:19 +0000</pubDate>
        
        <atom:modified>Tue, 01 Jan 2019 18:53:19 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>2019年度计划</title>
        <link>https://blog.jiyang.site/posts/2018-12-31-2019%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/</link>
        <pubDate>Mon, 31 Dec 2018 16:58:43 +0000</pubDate>
        
        <atom:modified>Mon, 31 Dec 2018 16:58:43 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-12-31-2019%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/</guid>
        <description></description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>计划</category>
            
          
        
        
          
            
              <category>个人</category>
            
          
        
        
      </item>
      
      <item>
        <title>为服务器配置自动更新SSL证书</title>
        <link>https://blog.jiyang.site/posts/2018-12-27-%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0ssl%E8%AF%81%E4%B9%A6/</link>
        <pubDate>Thu, 27 Dec 2018 08:46:40 +0000</pubDate>
        
        <atom:modified>Thu, 27 Dec 2018 08:46:40 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-12-27-%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0ssl%E8%AF%81%E4%B9%A6/</guid>
        <description>&lt;p&gt;以我 youcute.cn 为例，首先安装 &lt;code&gt;acme&lt;/code&gt; 脚本 &lt;a href=&#34;https://github.com/Neilpang/acme.sh&#34;&gt;https://github.com/Neilpang/acme.sh&lt;/a&gt;。然后生成证书，将证书拷贝到相应的目录。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Nginx</category>
            
          
        
        
          
            
              <category>Linux</category>
            
          
        
        
      </item>
      
      <item>
        <title>图像处理基础</title>
        <link>https://blog.jiyang.site/posts/2018-12-14-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Fri, 14 Dec 2018 23:00:30 +0000</pubDate>
        
        <atom:modified>Fri, 14 Dec 2018 23:00:30 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-12-14-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</guid>
        <description>图像的数字化过程 图像的数字化主要分两个过程，采样和量化。 采样 用多少点来描述一张图像 例如一张 600x400 尺寸的图, 会采样 240000 个点, 又叫 24 万像素 量化 把采样点</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>图像处理</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android IPC 相关</title>
        <link>https://blog.jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Tue, 04 Dec 2018 23:06:09 +0000</pubDate>
        
        <atom:modified>Tue, 04 Dec 2018 23:06:09 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/</guid>
        <description>&lt;h2 id=&#34;android-上的多进程情景&#34;&gt;Android 上的多进程情景&lt;/h2&gt;
&lt;p&gt;Android 中每个应用的进程都 fork 自 Zygote 进程， Zygote 进程在启动时自己会创建一个虚拟机，从而也就让每个应用拥有了自己的虚拟机。&lt;br /&gt;
当应用涉及多进程时，想当于启动了多个虚拟机，在单进程情况下的一些情景将会失效:&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>Jvm垃圾收集和内存分配</title>
        <link>https://blog.jiyang.site/posts/2018-11-17-jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</link>
        <pubDate>Sat, 17 Nov 2018 21:40:35 +0000</pubDate>
        
        <atom:modified>Sat, 17 Nov 2018 21:40:35 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-11-17-jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&#34;&gt;Java Garbage Collection Basics&lt;/a&gt; 和 《周志明. 深入理解Java虚拟机》&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>JVM</category>
            
          
        
        
      </item>
      
      <item>
        <title>Jvm运行时数据区</title>
        <link>https://blog.jiyang.site/posts/2018-10-20-jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</link>
        <pubDate>Sat, 20 Oct 2018 11:30:03 +0000</pubDate>
        
        <atom:modified>Sat, 20 Oct 2018 11:30:03 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-10-20-jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-12-2/42746474.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>JVM</category>
            
          
        
        
      </item>
      
      <item>
        <title>MMKV分析</title>
        <link>https://blog.jiyang.site/posts/2018-10-19-mmkv%E5%88%86%E6%9E%90/</link>
        <pubDate>Fri, 19 Oct 2018 19:03:42 +0000</pubDate>
        
        <atom:modified>Fri, 19 Oct 2018 19:03:42 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-10-19-mmkv%E5%88%86%E6%9E%90/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;基于 mmap 的高性能通用 key-value 组件, 底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。 &lt;a href=&#34;https://github.com/Tencent/MMKV&#34;&gt;https://github.com/Tencent/MMKV&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>模拟系统内存不足时应用崩溃问题</title>
        <link>https://blog.jiyang.site/posts/2018-10-07-%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</link>
        <pubDate>Sun, 07 Oct 2018 16:27:06 +0000</pubDate>
        
        <atom:modified>Sun, 07 Oct 2018 16:27:06 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-10-07-%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</guid>
        <description>问题 线上一直会报一个 Crash，通过日志发现用户的操作路径： 将一个展示结果的 Activity 退到了后台 然后当回到这个 Activity 时，发生了 NPE 错误导致 Crash 一开始，我预测</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Kotlin let run apply with 方法</title>
        <link>https://blog.jiyang.site/posts/2018-09-19-kotlin-let-run-apply-with%E6%96%B9%E6%B3%95/</link>
        <pubDate>Wed, 19 Sep 2018 10:55:40 +0000</pubDate>
        
        <atom:modified>Wed, 19 Sep 2018 10:55:40 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-09-19-kotlin-let-run-apply-with%E6%96%B9%E6%B3%95/</guid>
        <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Test { data class Man(val name: String, val argOne: String = &amp;#34;456&amp;#34;) private val argOne = &amp;#34;123&amp;#34; fun print() { Man(&amp;#34;stefan&amp;#34;).let { println(it.name) // it 代表 let 的调用方: Man println(this.argOne) //123 this</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Kotlin</category>
            
          
        
        
      </item>
      
      <item>
        <title>Retrofit Source Code</title>
        <link>https://blog.jiyang.site/posts/2018-09-19-retrofit-source-code/</link>
        <pubDate>Wed, 19 Sep 2018 08:30:30 +0000</pubDate>
        
        <atom:modified>Wed, 19 Sep 2018 08:30:30 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-09-19-retrofit-source-code/</guid>
        <description>&lt;h1 id=&#34;retrofit&#34;&gt;Retrofit&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官话: A type-safe HTTP client for Android and Java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的理解: 它提供了一种方便的 HTTP 请求编写方式. 它通过解析接口方法的注解, 构造出对应的 HTTP 请求方法, 并且支持添加自己的 CallAdapter 和 Converter 定制化请求的创建和结果的解析.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>CoordinatorLayout Behavior</title>
        <link>https://blog.jiyang.site/posts/2018-09-07-coordinatorlayout-behavior/</link>
        <pubDate>Fri, 07 Sep 2018 09:41:28 +0000</pubDate>
        
        <atom:modified>Fri, 07 Sep 2018 09:41:28 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-09-07-coordinatorlayout-behavior/</guid>
        <description>&lt;h2 id=&#34;step1-简单介绍-coordinatorlayout&#34;&gt;Step1 简单介绍 CoordinatorLayout&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用：&lt;em&gt;协调子 View&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使用核心: &lt;strong&gt;Behavior&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;布局属性类似 FrameLayout&lt;/li&gt;
&lt;/ul&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>RxJava&#39;s Thread Dispatch</title>
        <link>https://blog.jiyang.site/posts/2018-08-13-rxjava-thread-dispatch/</link>
        <pubDate>Fri, 17 Aug 2018 21:24:42 +0000</pubDate>
        
        <atom:modified>Fri, 17 Aug 2018 21:24:42 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-08-13-rxjava-thread-dispatch/</guid>
        <description>简单的使用 RxJava，并结合线程切换: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Observable.create(new ObservableOnSubscribe&amp;lt;Object&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;Object&amp;gt; emitter) { Log.d(&amp;#34;TAG&amp;#34;, &amp;#34;[subscribe]&amp;#34; + Thread.currentThread().getName()); emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidScheduler.mainThread()) .subscribe(new Observer&amp;lt;Object&amp;gt;() {</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Rx</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>RxJava Observer Observable(Not With Thread Dispatch) Source Code</title>
        <link>https://blog.jiyang.site/posts/2018-08-10-rxjava-observer-observable/</link>
        <pubDate>Fri, 10 Aug 2018 23:20:50 +0000</pubDate>
        
        <atom:modified>Fri, 10 Aug 2018 23:20:50 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-08-10-rxjava-observer-observable/</guid>
        <description>众所周知 RxJava 是基于观察者模式的响应式编程框架。其中主要有2个主要对象： Observable 被观察者 Observer 观察者 不带线程切换的基本用法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>Rx</category>
            
          
        
        
          
            
              <category>Android</category>
            
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>一个罐子，一堂人生哲学</title>
        <link>https://blog.jiyang.site/posts/2018-08-05-%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E4%B8%80%E5%A0%82%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/</link>
        <pubDate>Sun, 05 Aug 2018 14:07:07 +0000</pubDate>
        
        <atom:modified>Sun, 05 Aug 2018 14:07:07 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-08-05-%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E4%B8%80%E5%A0%82%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/</guid>
        <description>&lt;p&gt;大学的第一堂哲学课，教授拿出一个空的&lt;code&gt;透明罐子&lt;/code&gt;。说：“人的一生都要活一次，虽然对于广大的宇宙来说我们不过是一个小小过客，但我们有能力去完成任何事情。真的，任何事情。如果，我们善用时间的话。”&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>计划</category>
            
          
        
        
          
            
              <category>个人</category>
            
          
        
        
      </item>
      
      <item>
        <title>树莓派控制继电器</title>
        <link>https://blog.jiyang.site/posts/2018-07-22-%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/</link>
        <pubDate>Sun, 22 Jul 2018 21:31:44 +0000</pubDate>
        
        <atom:modified>Sun, 22 Jul 2018 21:31:44 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-07-22-%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/</guid>
        <description>&lt;p&gt;树莓派控制继电器，从而控制大电流的通与断。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>树莓派</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android 源码中的单例模式</title>
        <link>https://blog.jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Sat, 21 Jul 2018 11:23:53 +0000</pubDate>
        
        <atom:modified>Sat, 21 Jul 2018 11:23:53 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;经常使用 &lt;code&gt;Context.getSystemService(String name)&lt;/code&gt; 获取一些系统服务。 其实这些服务都是以单例的方式注册在系统中的。 获取到的都是单例对象。&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>ListView原理分析</title>
        <link>https://blog.jiyang.site/posts/2018-07-12-listview%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
        <pubDate>Thu, 12 Jul 2018 11:31:07 +0000</pubDate>
        
        <atom:modified>Thu, 12 Jul 2018 11:31:07 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-07-12-listview%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-7-12/60411659.jpg&#34; alt=&#34;先上张图&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android控件架构</title>
        <link>https://blog.jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</link>
        <pubDate>Mon, 09 Jul 2018 22:38:12 +0000</pubDate>
        
        <atom:modified>Mon, 09 Jul 2018 22:38:12 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/</guid>
        <description>&lt;p&gt;&lt;img src=&#34;https://image.youcute.cn/18-7-9/65379561.jpg&#34; alt=&#34;View树结构&#34; /&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
            
              <category>读书笔记</category>
            
          
        
        
      </item>
      
      <item>
        <title>绘制SimpleProgressBar</title>
        <link>https://blog.jiyang.site/posts/2018-06-05-%E7%BB%98%E5%88%B6simpleprogressbar/</link>
        <pubDate>Tue, 05 Jun 2018 23:59:20 +0000</pubDate>
        
        <atom:modified>Tue, 05 Jun 2018 23:59:20 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-06-05-%E7%BB%98%E5%88%B6simpleprogressbar/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;继承 View 实现 ProgressBar, 练习使用 Kotlin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;https://github.com/lingochamp/MagicProgressWidget&#34;&gt;https://github.com/lingochamp/MagicProgressWidget&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Flask自带的Session</title>
        <link>https://blog.jiyang.site/posts/2018-05-28-flask%E8%87%AA%E5%B8%A6%E7%9A%84session/</link>
        <pubDate>Mon, 28 May 2018 00:32:41 +0000</pubDate>
        
        <atom:modified>Mon, 28 May 2018 00:32:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-05-28-flask%E8%87%AA%E5%B8%A6%E7%9A%84session/</guid>
        <description>&lt;p&gt;今天才搞懂 Flask 自带的 session 竟然是完全依靠客户端的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当写入值到 session 中后， session 就会比加密成一个字符串，然后写入到 cookie 里&lt;/li&gt;
&lt;li&gt;当一个请求来时，获取请求的 cookie 里拿到 session 字符串，然后解析到 session 字典里&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前还使用自带的 session 做用户登录，现在看来不安全，用户是否登录完全依赖了客户端呀。本以为 Flask 自带的 session 是储存在内存中的，结果现在清楚了，内存中没有存，都是每次从请求的 cookie 中拿到，然后解析成 dict.&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Python</category>
            
          
        
        
      </item>
      
      <item>
        <title>单词高亮TextView</title>
        <link>https://blog.jiyang.site/posts/2018-05-25-%E5%8D%95%E8%AF%8D%E9%AB%98%E4%BA%AEtextview/</link>
        <pubDate>Fri, 25 May 2018 22:26:58 +0000</pubDate>
        
        <atom:modified>Fri, 25 May 2018 22:26:58 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-05-25-%E5%8D%95%E8%AF%8D%E9%AB%98%E4%BA%AEtextview/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;单词高亮的TextView控件。额，为什么做这个&amp;hellip;. 好吧，之前面试时公司要求的题目&lt;/p&gt;
&lt;/blockquote&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>Linux 权限 124</title>
        <link>https://blog.jiyang.site/posts/2018-05-21-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90124/</link>
        <pubDate>Mon, 21 May 2018 01:59:41 +0000</pubDate>
        
        <atom:modified>Mon, 21 May 2018 01:59:41 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-05-21-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90124/</guid>
        <description>&lt;h2 id=&#34;权限字符&#34;&gt;权限字符&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;drwxrwxrwx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;拆分为4部分，d rwx rwx rwx，分别表示：文件类型、属主权限(文件拥有者)、属组权限(与文件拥有者同用户组的其他用户)、其他用户组用户权限&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Linux</category>
            
          
        
        
      </item>
      
      <item>
        <title>Ubuntu制作windows启动盘-WoeUSB</title>
        <link>https://blog.jiyang.site/posts/2018-04-27-ubuntu%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8%E7%9B%98-woeusb/</link>
        <pubDate>Fri, 27 Apr 2018 14:11:59 +0000</pubDate>
        
        <atom:modified>Fri, 27 Apr 2018 14:11:59 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-04-27-ubuntu%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8%E7%9B%98-woeusb/</guid>
        <description>&lt;p&gt;参照 &lt;a href=&#34;https://ubuntu.pkgs.org/17.10/webupd8-amd64/winusb_3.1.4-1~webupd8~artful0_all.deb.html&#34;&gt;https://ubuntu.pkgs.org/17.10/webupd8-amd64/winusb_3.1.4-1~webupd8~artful0_all.deb.html&lt;/a&gt;&lt;/p&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Ubuntu</category>
            
          
        
        
      </item>
      
      <item>
        <title>Python新旧类的方法查找区别</title>
        <link>https://blog.jiyang.site/posts/2018-04-20-python%E6%96%B0%E6%97%A7%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%8C%BA%E5%88%AB/</link>
        <pubDate>Fri, 20 Apr 2018 21:59:38 +0000</pubDate>
        
        <atom:modified>Fri, 20 Apr 2018 21:59:38 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2018-04-20-python%E6%96%B0%E6%97%A7%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%8C%BA%E5%88%AB/</guid>
        <description>&lt;p&gt;Python 中现在存在两种类的定义方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1  旧式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;A foo&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;2 新式( Python 3 默认的方式)&lt;/li&gt;
&lt;/ul&gt;</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Python</category>
            
          
        
        
      </item>
      
      <item>
        <title>ADB-Shell-Commands</title>
        <link>https://blog.jiyang.site/posts/2017-08-22-adb-shell-commands/</link>
        <pubDate>Tue, 22 Aug 2017 09:58:00 +0000</pubDate>
        
        <atom:modified>Tue, 22 Aug 2017 09:58:00 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2017-08-22-adb-shell-commands/</guid>
        <description>ADB:Android Debug Bridge 是能够和手机或模拟器通信的一个命令行工具。下载地址 命令分类 1. ADB Debugging 1 adb devices 输出连接的模拟器/真机列表 1 adb forward tcp:8000 tcp:9000 实现PC和Android设备</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android TouchEvent Dispatch 再分析</title>
        <link>https://blog.jiyang.site/posts/2017-06-07-android-touchevent-dispatch-%E5%86%8D%E5%88%86%E6%9E%90/</link>
        <pubDate>Wed, 07 Jun 2017 17:19:50 +0000</pubDate>
        
        <atom:modified>Wed, 07 Jun 2017 17:19:50 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2017-06-07-android-touchevent-dispatch-%E5%86%8D%E5%88%86%E6%9E%90/</guid>
        <description>在 Android 中，一次点击完成实际会产生多个事件，比如一个按钮的点击是: TouchDown → TouchUp → 按钮的 onClickListener 回调触发。 Touch Down Event Touch Down 事件在Parent View 和 View 是否是 clickable 的情况下都</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>LruCache缓存机制实现原理</title>
        <link>https://blog.jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <pubDate>Wed, 24 May 2017 00:00:00 +0000</pubDate>
        
        <atom:modified>Wed, 24 May 2017 00:00:00 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        <description>LRU 算法描述 当序列达到设置的内存上限时, 丢弃序列中最近最少使用的元素. LruCache Android SDK 提供的使用了(Least Recently Used)最近最少使用算法的缓存类. 编写</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>缓存算法</category>
            
          
        
        
          
            
              <category>算法</category>
            
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>拍摄闪电⚡️</title>
        <link>https://blog.jiyang.site/posts/2015-04-01-%E6%8B%8D%E6%91%84%E9%97%AA%E7%94%B5%EF%B8%8F/</link>
        <pubDate>Wed, 01 Apr 2015 22:20:00 +0000</pubDate>
        
        <atom:modified>Wed, 01 Apr 2015 22:20:00 +0000</atom:modified>
        <guid>https://blog.jiyang.site/posts/2015-04-01-%E6%8B%8D%E6%91%84%E9%97%AA%E7%94%B5%EF%B8%8F/</guid>
        <description>拍了 100 多张之后，终于拍到了几张闪电。</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
          
            
              <category>雷电</category>
            
          
        
        
          
            
              <category>个人</category>
            
          
        
        
      </item>
      
      <item>
        <title>Anddroid媒体解码学习MediaCodec-MediaExtractor</title>
        <link>https://blog.jiyang.site/posts/2017-07-07-anddroid%E5%AA%92%E4%BD%93%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0mediacodec-mediaextractor/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-07-07-anddroid%E5%AA%92%E4%BD%93%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0mediacodec-mediaextractor/</guid>
        <description>Android提供了MediaPlayer播放器播放媒体文件，其实MediaPlyer只是对Android Media包下的MediaCode</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android和IOS等效MD5加密</title>
        <link>https://blog.jiyang.site/posts/2017-03-26-android%E5%92%8Cios%E7%AD%89%E6%95%88md5%E5%8A%A0%E5%AF%86/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-03-26-android%E5%92%8Cios%E7%AD%89%E6%95%88md5%E5%8A%A0%E5%AF%86/</guid>
        <description>最近在Android和IOS上都需要对用户的某些输入进行简单的加密，于是采用MD5加密方式。 首先将目的字符串加密一次，获得32位字符串 然后将</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
        
      </item>
      
      <item>
        <title>Android性能优化</title>
        <link>https://blog.jiyang.site/posts/2017-08-18-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-08-18-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        <description>Android程序不能无限制的使用设备的内存和CPU。正如经典所说，设备的资源不是给程序员用的，是给用户用的。在编写程序时，应该经常注意内存</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Android消息机制</title>
        <link>https://blog.jiyang.site/posts/2017-06-08-android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-06-08-android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</guid>
        <description>在非UI线程使用Handler进行线程通信时，一般都需要进行3个步骤： 创建Looper Looper.prepar() 创建Handler 启动消息循环Looper.loop</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>AsyncTask Source Code</title>
        <link>https://blog.jiyang.site/posts/2017-08-06-asynctask%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-08-06-asynctask%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
        <description>AsyncTask类的初始化过程 初始化阶段： 初始化线程池THREAD_POOL_EXECUTOR。用于执行任务。 构造一个负责调度线程的线程池</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>BlockingQueue-CountDownLatch</title>
        <link>https://blog.jiyang.site/posts/2017-07-25-blockingqueue-countdownlatch/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-07-25-blockingqueue-countdownlatch/</guid>
        <description>BlockingQueue:Java提供的线程安全的队列接口。 CountDownWatch:可用来让一个线程一直等待watch的值为0,另一</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Java</category>
            
          
        
        
      </item>
      
      <item>
        <title>DNA合成问题</title>
        <link>https://blog.jiyang.site/posts/2017-08-24-dna%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-08-24-dna%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</guid>
        <description>DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。 碱基互补配对原则：A和T是配对的，C和G是</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>算法</category>
            
          
        
        
      </item>
      
      <item>
        <title>IntentFilter匹配规则</title>
        <link>https://blog.jiyang.site/posts/2017-08-05-intentfilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-08-05-intentfilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</guid>
        <description>Activity的启动方式分为两种: 显式启动 通过指明启动的Activity类 隐式启动 通过Intent匹配目标组件的IntentFilter中</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Android</category>
            
          
        
        
      </item>
      
      <item>
        <title>Java 单例实现</title>
        <link>https://blog.jiyang.site/posts/2017-08-19-%E5%8D%95%E4%BE%8B%E5%88%86%E6%9E%90/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        
        <guid>https://blog.jiyang.site/posts/2017-08-19-%E5%8D%95%E4%BE%8B%E5%88%86%E6%9E%90/</guid>
        <description>单例常见实现方式 饿汉式：在类被加载时就初始化单例 懒汉式：在需要的地方才初始化单例 饿汉式加载问题 传统的在类加载时就创建单例的方法存在一些问题：</description>
        
        <dc:creator>Yang</dc:creator>
        
        
        
        
        
          
            
              <category>Java</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>