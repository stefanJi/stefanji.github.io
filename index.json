[{"content":"Step1 Picker data structrure 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  class IdentifiableString: Identifiable { internal init(s: String) { self.str = s self.id = s } let str: String var id: String } open class MPickerData\u0026lt;Content\u0026gt; { public init(title: String, key: String, values: [Content]) { self.title = title self.key = key self.values = values self.select = KV.shared.get(key: key) } let title: String let key: String let values: [Content] var select: Content? var idValues: [IdentifiableString] { values.map { item in IdentifiableString(s: \u0026#34;\\(item)\u0026#34;) } } open func binding() -\u0026gt; Binding\u0026lt;String\u0026gt;? { return nil } func updateSelect(_ newValue: Content) { self.select = newValue KV.shared.set(key: self.key, value: newValue) } }    KV: UserDefaults wraper class  Step2 Implement for any type Int Picker 1 2 3 4 5 6 7 8 9 10 11 12 13  public class MIntPicker: MPickerData\u0026lt;Int\u0026gt; { public override func binding() -\u0026gt; Binding\u0026lt;String\u0026gt; { let binding = Binding\u0026lt;String\u0026gt; { return \u0026#34;\\(self.select ?? KV.shared.get(key: self.key) ?? 0)\u0026#34; } set: { newValue in if let nInt = Int(newValue) { self.updateSelect(nInt) } } return binding } }   String Picker 1 2 3 4 5 6 7 8 9 10 11  public class MStringPicker: MPickerData\u0026lt;String\u0026gt; { public override func binding() -\u0026gt; Binding\u0026lt;String\u0026gt; { let binding = Binding\u0026lt;String\u0026gt; { return self.select ?? KV.shared.get(key: self.key) ?? \u0026#34;\u0026#34; } set: { newValue in self.updateSelect(newValue) } return binding } }   Step3 Implement Picker View 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import SwiftUI struct MPickerView\u0026lt;Content\u0026gt;: View { @State var pickerData: MPickerData\u0026lt;Content\u0026gt; var body: some View { VStack { Text(pickerData.title).font(.title) if let binding = pickerData.binding() { Picker(pickerData.title, selection: binding) { ForEach(pickerData.idValues) { idV in Text(idV.str) } }.pickerStyle(WheelPickerStyle()) } } } }   Usage 1 2 3 4 5 6 7 8  let pickers = [ MIntPicker(title: \u0026#34;Select Int\u0026#34;, key: \u0026#34;key_int\u0026#34;, values: [1, 2, 3, 4]), MFloatPicker(title: \u0026#34;Select Float\u0026#34;, key: \u0026#34;key_float\u0026#34;, values: [1.0, 2.4, 3.5, 4.6]), MDoublePicker(title: \u0026#34;Select Double\u0026#34;, key: \u0026#34;key_double\u0026#34;, values: [1.1, 2.2, 3.3333, 4.56]), MStringPicker(title: \u0026#34;Select String\u0026#34;, key: \u0026#34;key_string\u0026#34;, values: [\u0026#34;aaa\u0026#34;, \u0026#34;bbb\u0026#34;, \u0026#34;ccc\u0026#34;, \u0026#34;ddd\u0026#34;]) ] let pickerView = MPickerView(pickerData: pickers)   ","description":"","id":0,"section":"posts","tags":[""],"title":"SwiftUI Picker 支持不同类型数据","uri":"https://jiyang.site/posts/swiftui_picker/"},{"content":" https://karinprater.medium.com/on-the-road-to-learn-swiftui-8b26b528199c\n ","description":"","id":1,"section":"posts","tags":[""],"title":"SwiftUI 学习路线","uri":"https://jiyang.site/posts/swiftui_learn_roadmap/"},{"content":"背景 在客户端中存在一种应用场景：需要将 MediaCodec 或者 Camera 产生的图像，通过 OpenGL 交给算法做特效，由于算法可能是基于普通的 Texture2D 纹理实现的，而 Android 上更常用的则是 GL_TEXTURE_EXTERNAL_OES 纹理，算法一般都是基于 OpenGL 而不是 OpenGLES 环境实现的，所以就需要客户端这边做一个转换工作。这个转换工作当然最好是在 GPU 中能完成的，因为如果通过 CPU 从 OES 纹理中读出图像数据，再提交到 2D 纹理中，这一来一回，即浪费 CPU 页占有了内存，很不划算。所以就出现了这篇文章，如何利用 OpenGL 将 OES 纹理渲染到普通 2D 纹理上。\nGL_TEXTURE_EXTERNAL_OES 纹理  首先，简单了解下什么是 OES 纹理 https://source.android.google.cn/devices/graphics/arch-st?hl=zh-c\n 外部 GLES 纹理 (GL_TEXTURE_EXTERNAL_OES) 与传统 GLES 纹理 (GL_TEXTURE_2D) 的区别如下：\n 外部纹理直接在从 BufferQueue 接收的数据中渲染纹理多边形。 外部纹理渲染程序的配置与传统的 GLES 纹理渲染程序不同。 外部纹理不一定可以执行所有传统的 GLES 纹理活动。  外部纹理的主要优势是它们能够直接从 BufferQueue 数据进行渲染。在 Android 平台上，BufferQueue 是连接图形数据生产方和消费方的队列，也就表示 OES 纹理能直接拿到某些生产方产生的图形数据进行渲染。\nOES Texture 渲染到 TEXTURE_2D 比如现在有个需求：使用 MediaCodec 解码视频，最终需要将解码的每一帧渲染到外部设置的一个 TEXTURE_2D 纹理上。\n实现方案：MediaCodec 支持将解码结果输出到 Surface 中，我们可以通过构造一个绑定了 OES 纹理的 SurfaceTexture 来为 MediaCodec 构造一个输出 Surface。当解码结果写入到 Surface 的 BufferQueue 之后，再利用 SurfaceTexture 将结果从 BufferQueue 渲染到 OES 纹理上，然后再通过 OpegGL 管道流水线操作将 OES 纹理上的内容渲染到 TEXTURE_2D 纹理：\nMediaCodec 解码到 Surface 伪代码如下：\noesTextureId = x sTexture = SurfaceTexture(oesTextureId) outputSurface = Surface(sTexture) decoder.setOutputSurface(outputSurface) 这里可以借鉴 grafika 中 Buffer 的生成和消费流程:\n然后在参考了 grafika 的流程后设计的流程：\n正如上图所示，从 TextureOES 到 Texture2D 的关键是利用 FBO(帧缓冲)。在执行 OpenGL 渲染之前，开始 FBO，渲染完成之后关闭 FBO。\n帧缓冲实现 如果我们不额外设置 OpenGL 的帧缓冲，OpenGL 所有操作都将在默认帧缓冲的渲染缓冲上进行；如果我们激活了自己的帧缓冲，也就是在绑定到 GL_FRAMEBUFFER 目标之后，所有的读取和写入帧缓冲的操作将会影响当前绑定的帧缓冲。\n所以这里的操作是：创建一个帧缓冲，将 Texture2D 纹理作为它的颜色缓冲，然后在利用 Shader 从 TextureOES 纹理上采样之前将这个帧缓冲设置为 OpenGL 上下文当前激活的帧缓冲。这样设置之后就相当于，将 TextureOES 采样到帧缓冲中，而帧缓冲背后又是 Texture2D，就间接的将 TextureOES 采样到了 Texture2D 上。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class DecodeFBO { private var mFrameBuffer = -1 init { val tmp = IntArray(1) GLES30.glGenFramebuffers(1, tmp, 0) SLGLUtils.checkGlError(\u0026#34;glGenFrameBuffer\u0026#34;) mFrameBuffer = tmp[0] } /** * 绑定 FBO 到 Texture2D 纹理 */ fun begin(texture2D: Int) { GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, mFrameBuffer) SLGLUtils.checkGlError(\u0026#34;glBindFrameBuffer\u0026#34;) //将纹理作为帧缓冲对象的颜色缓冲  GLES30.glFramebufferTexture2D( GLES30.GL_FRAMEBUFFER, GLES30.GL_COLOR_ATTACHMENT0, GLES30.GL_TEXTURE_2D, texture2D, 0 ) checkGlError(\u0026#34;glFramebufferTexture2D\u0026#34;) val status = GLES30.glCheckFramebufferStatus(GLES30.GL_FRAMEBUFFER) if (status != GLES30.GL_FRAMEBUFFER_COMPLETE) { Log.e(TAG, \u0026#34;bind FBO failed！\u0026#34;) return } } fun end() { GLES30.glFramebufferTexture2D( GLES30.GL_FRAMEBUFFER, GLES30.GL_COLOR_ATTACHMENT0, GLES30.GL_TEXTURE_2D, 0, 0 ) checkGlError(\u0026#34;detach texture from FBO\u0026#34;) GLES30.glBindFramebuffer(GLES30.GL_FRAMEBUFFER, 0) checkGlError(\u0026#34;deactivate FBO\u0026#34;) } fun release() { GLES30.glDeleteFramebuffers(1, IntArray(1) { mFrameBuffer }, 0) checkGlError(\u0026#34;glDeleteFramebuffers\u0026#34;) } }   着色器实现 这里的着色器就不复杂了，就是从一个纹理上采样，然后设置给 gl_FragColor。\n顶点着色器：\n1 2 3 4 5 6 7 8 9  private static final String VERTEX_SHADER = \u0026#34;uniform mat4 uMVPMatrix;\\n\u0026#34; + \u0026#34;attribute vec4 aPosition;\\n\u0026#34; + \u0026#34;attribute vec4 aTextureCoord;\\n\u0026#34; + \u0026#34;varying vec2 vTextureCoord;\\n\u0026#34; + \u0026#34;void main() {\\n\u0026#34; + \u0026#34; gl_Position = uMVPMatrix * aPosition;\\n\u0026#34; + \u0026#34; vTextureCoord = aTextureCoord.xy;\\n\u0026#34; + \u0026#34;}\\n\u0026#34;;   片段着色器：\n1 2 3 4 5 6 7 8  private static final String FRAGMENT_SHADER = \u0026#34;#extension GL_OES_EGL_image_external : require\\n\u0026#34; + \u0026#34;precision mediump float;\\n\u0026#34; + \u0026#34;varying vec2 vTextureCoord;\\n\u0026#34; + \u0026#34;uniform sampler2D sTexture;\\n\u0026#34; + \u0026#34;void main() {\\n\u0026#34; + \u0026#34; gl_FragColor = texture2D(sTexture, vTextureCoord);\\n\u0026#34; + \u0026#34;}\\n\u0026#34;;   ","description":"","id":2,"section":"posts","tags":[""],"title":"Android Opengl OES 纹理渲染到 GL_TEXTURE_2D","uri":"https://jiyang.site/posts/android_opengl_oes_to_2d/"},{"content":"背景 FFmpeg 是一个开源的、强大的音视频工具库，平常情况下的使用方法一般是利用编译好的 ffmpeg 程序，在 PC 上使用，需要不同的功能时只需传递不同的参数即可，而且都是一条或多条命令就能完成功能，非常方便。\n比如要从视频中提取音乐，执行 ffmpeg -i input.mp4 output.mp3 就能搞定了，执行完成之后 ffmpeg 程序就退出了。也就是说 ffmpeg 命令行程序的机制就是：它是一个生命周期很简单的程序，执行完一个任务就退出。\n但是，当我们想在移动应用上集成 ffmpeg，并且也希望能够如同在 PC 上那样使用，传递命令参数就能执行对应功能时，ffmpeg 的运行完成就退出的机制其实会带给我们不便。这个不便是什么呢？\u0026ndash; 请继续浏览下文。\n集成 ffmpeg 之殇 为了实现在 Android 上能和在 PC 上一样的使用方法（因为直接传递参数给 ffmpeg 程序，比自己调用 ffmpeg 的 api 实现各种功能，方便的不是一点点），我首先分析了下 PC 上使用的 ffmpeg 程序是怎么来的。\nffmpeg 命令行程序的由来 当我们在 PC 上安装了 ffmpeg 的程序之后，一般都是在命令行中就能直接调用了，它本质就是一个可直接运行的程序。那么它对应的源码在 ffmpeg 项目中的哪里呢？\n➜ ~ which ffmpeg /usr/local/bin/ffmpeg ➜ ~ ls -la /usr/local/bin/ffmpeg -rwxr-xr-x /usr/local/bin/ffmpeg 在 FFmpeg 4.3.1 的源码中，有这么一个目录：fftools，它里面就存放了常见的 ffmpeg ffprobe ffplay 对应的源码文件。ffmpeg 对应的源码是 fftools/ffmpeg.h 和 fftools/ffmpeg.c。ffmpeg.c 中的 main 方法就是 ffmpeg 命令行程序的运行入口。\nmain 方法的工作主要为：\n 注册所有 ffmpeg 组件 判断是否传递了输入文件路径 调用方法解析传递给 main 方法的参数，并执行参数对应的功能 判断是否传递了输出文件路径 执行程序清理工作  源码大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  int main(int argc, char **argv) { int i, ret; init_dynload(); register_exit(ffmpeg_cleanup); #if CONFIG_AVDEVICE  avdevice_register_all(); #endif  avformat_network_init(); /* parse options and open all input/output files */ ret = ffmpeg_parse_options(argc, argv); if (ret \u0026lt; 0) exit_program(1); if (nb_output_files \u0026lt;= 0 \u0026amp;\u0026amp; nb_input_files == 0) { show_usage(); av_log(NULL, AV_LOG_WARNING, \u0026#34;Use -h to get full help or, even better, run \u0026#39;man %s\u0026#39;\\n\u0026#34;, program_name); exit_program(1); } /* file converter / grab */ if (nb_output_files \u0026lt;= 0) { av_log(NULL, AV_LOG_FATAL, \u0026#34;At least one output file must be specified\\n\u0026#34;); exit_program(1); } for (i = 0; i \u0026lt; nb_output_files; i++) { if (strcmp(output_files[i]-\u0026gt;ctx-\u0026gt;oformat-\u0026gt;name, \u0026#34;rtp\u0026#34;)) want_sdp = 0; } av_log(NULL, AV_LOG_DEBUG, \u0026#34;%\u0026#34;PRIu64\u0026#34; frames successfully decoded, %\u0026#34;PRIu64\u0026#34; decoding errors\\n\u0026#34;, decode_error_stat[0], decode_error_stat[1]); if ((decode_error_stat[0] + decode_error_stat[1]) * max_error_rate \u0026lt; decode_error_stat[1]) exit_program(69); exit_program(received_nb_signals ? 255 : main_return_code); return main_return_code; }   其实这个程序，我把方法名改改，然后封装一层 JNI，让 Java 层能够调到，那么就可以在 Android 平台上运行了，使用者就如同在 PC 上使用时一样方便了。\n但是，当你尝试之后，就会发现，当这段代码执行完成之后，你的 App 进程会跟着就退出了 \u0026hellip;\u0026hellip;.，因为 exit_program 这个方法。 这个方法定义在 cmdutils.c 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  static void (*program_exit)(int ret); void exit_program(int ret) { if (program_exit) program_exit(ret); exit(ret); } void register_exit(void (*cb)(int ret)) { program_exit = cb; }   exit_program 方法会先调用 program_exit 函数指针，然后调用了系统库方法 exit。OMG，这种做法在 PC 上是没问题的，因为在 PC 上，我们通过命令行执行命令，都会新创建一个进程来执行，但是在 Android App 上，我们 JNI 调用过来，默认都是在当前进程，如果在当前进程调用了 exit，就意味着我们 App 进程要退出了。\nmobile-ffmpeg 的解决方案 遇到这个坑之后，我就找了找，找到了开源的 mobile-ffmpeg，这个库就实现了 Android 上和 PC 类似的使用体验。他的实现方法我感觉很巧妙，简单来说是：利用 setjmp 和 longjmp 这两个标准库函数，在 ffmpeg 程序要退出时，将程序的执行状态恢复到调用 ffmpeg 程序之前。\nmobile-ffmpeg 实现了自己的 ffmpeg、ffprobe、 cmdutils，通过修改 ffmpeg 源码中的部分实现达到了避免程序运行 ffmpeg 指令之后进程退出的情况。\n在执行 ffmpeg.c 的 main 函数代码之前，先利用 setjmp 将程序的执行状态保留：\n1 2 3 4 5 6 7 8 9 10 11 12  int ffmpeg_execute(int argc, char **argv) { int savedCode = setjmp(ex_buf__); if (savedCode == 0) { // 执行 ffmpeg.c main 函数中的代码  } else { main_ffmpeg_return_code = (received_nb_signals || cancelRequested(executionId)) ? 255 : longjmp_value; } return main_ffmpeg_return_code; }   在 ffmpeg 期望退出程序时，将程序的执行状态恢复到之前保留的状态：\n1 2 3 4 5 6 7 8 9 10  void exit_program(int ret) { if (program_exit) program_exit(ret); // exit disabled and replaced with longjmp, exit value stored in longjmp_value  // exit(ret);  longjmp_value = ret; longjmp(ex_buf__, ret); }    https://zh.wikipedia.org/wiki/Setjmp.h  ","description":"","id":3,"section":"posts","tags":["FFmpeg"],"title":"通过分析mobile Ffmpeg解析如何优雅的集成ffmpeg到Android应用中","uri":"https://jiyang.site/posts/mobile_ffmpeg_compile/"},{"content":"背景 最近需要上线一个音乐编辑功能，需要展示音乐的波形图(如下图)。\n   期待效果 初步效果          首先这样的波形图，是根据音频在采样点的采样值来绘制的。像 mp3 m4a 的音乐格式，都会经历音频采样、编码的过程。采样的结果是 PCM，对 PCM 利用不同的编码算法进行编码就产生了不同格式的音乐文件。\n所以要得到绘制波形图的数据，第一步需要将压缩编码过的 PCM 音乐，解码为 PCM。这一步在 Android 上可以使用 MediaCodec 实现。获取到了 PCM 数据之后，如果你直接利用采样数据开始绘制，你应该会发现，数据量太大了，会直接导致你的绘制出现问题。\n 比如一段 PCM 音频数据，44.1 kHz 的采样率就会在每秒生成 44100 个采样点，如果我们要绘制这段音频的音量波形图，1秒就要绘制 44100 个点(单声道的情况下)，如果音频时间为10秒，则有 441000 个点。当代显示器的分辨率常见的就是 4K、2K，4K 分辨率下屏幕在水平方向最多能展示 4k 个像素点，如果不对上百万的采样点进行二次采样减小数据的量级，那么绘制出来的波形图，要么非常长，要么不长却会很难画清晰。\n 所以第二步就是对 PCM 数据进行二次采样。\n获取 PCM 数据 解码音乐 Android 上利用 MediaCodec 解码音乐还是比较方便的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  class AudioWaveformGenerator( private val path: String, private val expectPoints: Int ) : MediaCodec.Callback() { private lateinit var decoder: MediaCodec private lateinit var extractor: MediaExtractor private var onFinish: () -\u0026gt; Unit = {} @Throws(Exception::class) fun startDecode(onFinish: () -\u0026gt; Unit) { sampleData.clear() this.onFinish = onFinish try { val format = getFormat(path) ?: error(\u0026#34;Not found audio\u0026#34;) val mime = format.getString(MediaFormat.KEY_MIME) ?: error(\u0026#34;Not found mime\u0026#34;) decoder = MediaCodec.createDecoderByType(mime) decoder.configure(format, null, null, 0) decoder.setCallback(this) decoder.start() } catch (e: java.lang.Exception) { Log.e(TAG, \u0026#34;start decode\u0026#34;, e) throw e } } private fun getFormat(path: String): MediaFormat? { extractor = MediaExtractor() extractor.setDataSource(path) val trackCount = extractor.trackCount repeat(trackCount) { val format = extractor.getTrackFormat(it) val mime = format.getString(MediaFormat.KEY_MIME) ?: \u0026#34;\u0026#34; if (mime.contains(\u0026#34;audio\u0026#34;)) { durationS = format.getLong(MediaFormat.KEY_DURATION) / 1000000 extractor.selectTrack(it) return format } } return null } private var inputEof = false private var sampleRate = 0 private var channels = 1 private var pcmEncodingBit = 16 private var totalSamples = 0L private var durationS = 0L private var perSamplePoints = 0L override fun onOutputBufferAvailable( codec: MediaCodec, index: Int, info: MediaCodec.BufferInfo ) { } override fun onInputBufferAvailable(codec: MediaCodec, index: Int) { if (inputEof) return codec.getInputBuffer(index)?.let { buf -\u0026gt; val size = extractor.readSampleData(buf, 0) if (size \u0026gt; 0) { codec.queueInputBuffer(index, 0, size, extractor.sampleTime, 0) extractor.advance() } else { codec.queueInputBuffer(index, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM) inputEof = true } } } override fun onOutputFormatChanged(codec: MediaCodec, format: MediaFormat) { sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE) channels = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT) pcmEncodingBit = if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { if (format.containsKey(MediaFormat.KEY_PCM_ENCODING)) { when (format.getInteger(MediaFormat.KEY_PCM_ENCODING)) { AudioFormat.ENCODING_PCM_16BIT -\u0026gt; 16 AudioFormat.ENCODING_PCM_8BIT -\u0026gt; 8 AudioFormat.ENCODING_PCM_FLOAT -\u0026gt; 32 else -\u0026gt; 16 } } else { 16 } } else { 16 } totalSamples = sampleRate.toLong() * durationS perSamplePoints = totalSamples / expectPoints } override fun onError(codec: MediaCodec, e: MediaCodec.CodecException) { Log.e(TAG, \u0026#34;onError\u0026#34;, e) } } fun MediaCodec.BufferInfo.isEof() = flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0 fun MediaCodec.BufferInfo.isConfig() = flags and MediaCodec.BUFFER_FLAG_CODEC_CONFIG != 0   读取 PCM 采样数据 需要注意 PCM 的数据部分的字节储存方式是小端序，如果采样位数大于了 8 位，就需要在读取时注意按照小端序方式读取。\n接着为了方便后续处理，在读取到了采样值后，首先将每个采样点的采样值转化到 [-1, 1] 的 float 区间内：\n 如果是 8 bit 采样大小的数据：读取为 byte(注意：Java 上由于没有无符号类型，所以在 Java 上最好读取为 int)，然后除以 128(2^8/2)，转化到 [-1, 1] 区间内 如果是大于或等于 16 bit 采样大小的数据：   16 bit：采样值范围为 -32678 ~ 32678，读取为 float，然后除以 32678(2^16/2)，转化到 [-1, 1] 区间内 24 bit: 采样值范围为 -8388608 ~ 8388608，读取为 double，然后除以 8388608(2^24/2)，转化到 [-1, 1] 区间内 32 bit 和 64 bit 进行和上面类似的转化   为什么要转化到 [-1, 1] 的区间内呢，这涉及到后面的重采样\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  private fun handle8bit(size: Int, buf: ByteBuffer) { repeat(size / if (channels == 2) 2 else 1) { // 左声道  // 8 位采样的范围是: -128 ~ 128  val left = buf.get().toInt() / 128f if (channels == 2) { buf.get() } calRMS(left) } } private fun handle16bit(size: Int, buf: ByteBuffer) { repeat(size / if (channels == 2) 4 else 2) { // 左声道  val a = buf.get().toInt() val b = buf.get().toInt() shl 8 // 16 位采样的范围是: -32768 ~ 32768  val left = (a or b) / 32768f if (channels == 2) { buf.get() buf.get() } calRMS(left) } } private fun handle32bit(size: Int, buf: ByteBuffer) { repeat(size / if (channels == 2) 8 else 4) { // 左声道  val a = buf.get().toLong() val b = buf.get().toLong() shl 8 val c = buf.get().toLong() shl 16 val d = buf.get().toLong() shl 24 // 32 位采样的范围是: -2147483648 ~ 2147483648  val left = (a or b or c or d) / 2147483648f if (channels == 2) { buf.get() buf.get() buf.get() buf.get() } calRMS(left) } }   然后在 MediaCodec 的输出回调中根据采样大小调用上面的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  override fun onOutputBufferAvailable( codec: MediaCodec, index: Int, info: MediaCodec.BufferInfo ) { if (info.size \u0026gt; 0) { codec.getOutputBuffer(index)?.let { buf -\u0026gt; val size = info.size buf.position(info.offset) when (pcmEncodingBit) { 8 -\u0026gt; { handle8bit(size, buf) } 16 -\u0026gt; { handle16bit(size, buf) } 32 -\u0026gt; { handle32bit(size, buf) } } codec.releaseOutputBuffer(index, false) } }   利用 Python 验证解码 可以在解码完成之后，将解码之后的数据存储为 Wav 格式，然后利用如下脚本绘制波形图，测试解码是否正常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import matplotlib.pyplot as pl import numpy as np import wave def read_wav(): f = wave.open(\u0026#34;test.wav\u0026#34;, \u0026#39;rb\u0026#39;) params = f.getparams() nchannels, sampwidth, framerate, nframes = params[:4] print(\u0026#34;channels: {} samplewidth:{} framerate:{} frames:{}\u0026#34;.format(nchannels, sampwidth, framerate, nframes)) str_data = f.readframes(nframes) f.close() wave_data = np.frombuffer(str_data, dtype=np.short) if nchannels == 2: wave_data.shape = -1, 2 # 将一维数组拆为二维数组: [1,2,3,4] -\u0026gt; [[1,2], [3,4]] wave_data = wave_data.T # 转置数组 [[1,2], [3,4]] -\u0026gt; [[1,3], [2,4]] time = np.arange(0, nframes) * (1.0 / framerate) pl.subplot(211) pl.plot(time, wave_data[0]) # 左声道 pl.subplot(212) pl.plot(time, wave_data[1], c=\u0026#34;g\u0026#34;) # 右声道 pl.xlabel(\u0026#34;time (seconds)\u0026#34;) pl.show() elif nchannels == 1: wave_data.shape = -1, 1 wave_data = wave_data.T time = np.arange(0, nframes) * (1.0 / framerate) pl.subplot(211) pl.plot(time, wave_data[0]) pl.xlabel(\u0026#34;time (seconds)\u0026#34;) pl.show() if __name__ == \u0026#34;__main__\u0026#34;: read_wav()   重采样 在读取到了采样值之后，需要对数据集进行重采样，减少数据集的量级，便于在屏幕上绘制。重采样的方法实现在 calRMS 中。\n具体的计算方法为：\n 设数据量总大小为 T 确定你要绘制多少点 P 计算每个绘制点将使用多少数据量进行重采样 S, S=T/P 为了让重采样之后的数据集在展现时能最好的表现平均水平，所以为每一个绘制点采用 RMS 算法计算采样值  RMS 算法  平方平均数\n    计算方法 结果          每一个绘制点的数值范围为 [-RMS, RMS]。如下就是我实现的 RMS，我这是一个动态计算 RMS 的方法。\n 啥叫动态呢？就是计算的过程在解码的过程中进行，因为如果我们等解码完成之后再进行 RMS，容易因为数据量过大造成 Android 应用发生 OOM，因为一个 2 分钟的常见的音乐(44.1 KHz，16 bit 采样)，解码完成会产生 10584000 个字节的数据，如果用一个数组来存储，数组将会占用 10 MB 内存。如果一个更大长的音乐，那么内存占用将会更多。所以我只存储每次计算 RMS 之后的结果。\n 1 2 3 4 5 6 7 8 9 10 11  private fun calRMS(left: Float) { if (sampleCount == perSamplePoints) { val rms = sqrt(sampleSum / perSamplePoints) sampleData.add(rms.toFloat()) sampleCount = 0 sampleSum = 0.0 } sampleCount++ sampleSum += left.toDouble().pow(2.0) }    前面提到了为啥要转化到 [-1, 1] 的区间，其实是为了让 RMS 的结果能在这个区间\n 最终效果    最终效果 专业软件          可以看到，和专业的音乐编辑软件的显示差不多。\n参考  https://planetcalc.com/8627/ https://www.egeniq.com/blog/alternative-android-visualizer https://developer.android.com/guide/topics/media/media-formats  ","description":"绘制音频的音量波形图，并且在 Android 上进行实现","id":4,"section":"posts","tags":["Audio"],"title":"音频波形图绘制","uri":"https://jiyang.site/posts/audio_waveform/"},{"content":"问题 Unity 项目将版本从 2018 升级到 2020 版本之后，导出集成到 Android 项目时，运行时报错找不到 libmain.so。\njava.lang.UnsatisfiedLinkError: dlopen failed: library \u0026quot;/data/app/xxx/lib/arm/libmain.so\u0026quot; not found 原因 最终找到了根本原因：\nUnity 2020 版导出的工程中 UnityPlayer 加载so 库用的是绝对路径方式，其源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  String var6 = loadNative(getUnityNativeLibraryPath(var1)); private static String getUnityNativeLibraryPath(Context var0) { return var0.getApplicationInfo().nativeLibraryDir; } private static String loadNative(String var0) { String var1 = var0 + \u0026#34;/libmain.so\u0026#34;; try { System.load(var1); } catch (UnsatisfiedLinkError var2) { return logLoadLibMainError(var1, var2.toString()); } catch (SecurityException var3) { return logLoadLibMainError(var1, var3.toString()); } }   而我们 Android 项目用的 AGP(Android Gradle Plugin) 是 4.1 版本。AGP 3.6 版本之后增加了一项优化功能：AGP 编译时不再对共享库进行压缩操作，这样做会导致Apk变大，但是有另外两个好处：\n• 减小应用安装大小，因为平台可以直接从已安装的 APK 访问原生库，而无需创建库的副本。也就是不再会把 so 拷贝到 nativeLibrary 路径里了。\n• 减小下载文件大小，因为在 APK 或 Android App Bundle 中添加未压缩的原生库通常可提高 Google Play 商店的压缩率\n所以在 nativeLibraryDir 中就不再会存放 Apk 中 so 的拷贝，而 UnityPlayer 却还是用原始路径去加载，就肯定会出现找不到文件的问题。\n解决 在项目的 manifest.xml 中增加如下选项去关闭 AGP 的这项优化：\n1  android:extractNativeLibs=\u0026#34;true\u0026#34;   AGP 这个优化是好事，但是 Unity 团队可能没发现这个问题。\n","description":"","id":5,"section":"posts","tags":null,"title":"解决 Unity 2020 导出项目到 Android 中 So 加载问题","uri":"https://jiyang.site/posts/unity-export-android-library-so-not-found/"},{"content":"FFmpeg 的源码仓库在 doc/examples 目录中提供了一些基本的 FFmpeg Api 使用方法。但是在我想运行这些例子时，却尝试了很久才编译出来可运行的例子。因为 FFmpeg 的 readme 中只大概提到了如何编译 examples，但是还是要花一些时间才能成功。\n所以在此记录以下如何编译并成功运行那些 exampples。\nFFmpeg Relase 4.3 版本的源码目录结构应该是如下的:\n➜ FFmpeg-release-4.3 tree -L 1 . ├── Makefile ├── README.md ├── doc ├── ffbuild ├── ffmpeg ├── ffplay ├── ffprobe ├── fftools ├── libavcodec ├── libavdevice ├── libavfilter ├── libavformat ├── libavresample ├── libavutil ├── libpostproc ├── libswresample ├── libswscale FFmpeg 的编译会依赖一个叫 pkg-config 的工具去定位各个依赖库的位置，所以在编译前需要先在你的编译环境上安装 pkg-config。doc/examples 中就是 FFmpeg 内部 Api 的使用例子。\n要运行 examples，需要先将 FFmpeg 各个组件编译为对应你目标平台的库。\n编译 FFmpeg 编译本身没啥可说的，利用 make 工具根据 FFmpeg 项目中的 MakeFile 进行编译。执行 make 前需要先使用源码根目录的 .configure 脚本配置要把哪些组件加入编译中。\n下面是我在 osx 上编译的一个配置, prefix 配置了编译后结果的存放目录:\n./configure --prefix=./mac_build \\ --enable-gpl \\ --disable-everything \\ --enable-nonfree \\ --enable-libass \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libmp3lame \\ --enable-libtheora \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libopus \\ --enable-libxvid \\ --samples=fate-suite --enable-debug=3 \\ --enable-demuxer=mov,wav,wavpack \\ --enable-muxer=image2 \\ --enable-encoder=png \\ --enable-decoder=h264 \\ --enable-protocol=file \\ --enable-filter=scale,trim make clean make -j 6 make -j 6 install 编译完成后的目录结构应该如下：\nmac_build ├── bin │ ├── ffmpeg │ ├── ffplay │ └── ffprobe ├── include │ ├── libavcodec │ ├── libavdevice │ ├── libavfilter │ ├── libavformat │ ├── libavutil │ ├── libpostproc │ ├── libswresample │ └── libswscale ├── lib │ ├── libavcodec.a │ ├── libavdevice.a │ ├── libavfilter.a │ ├── libavformat.a │ ├── libavutil.a │ ├── libpostproc.a │ ├── libswresample.a │ ├── libswscale.a │ └── pkgconfig │ ├── libavcodec.pc │ ├── libavdevice.pc │ ├── libavfilter.pc │ ├── libavformat.pc │ ├── libavutil.pc │ ├── libpostproc.pc │ ├── libswresample.pc │ └── libswscale.pc └── share ├── doc │ └── ffmpeg ├── ffmpeg │ ├── examples │ │ ├── Makefile 编译出来的可执行文件在 bin 目录中；如果你要基于 FFmpeg 的 Api 进行开发，那么 include 和 lib 目录就是你需要的了。而原来 doc/examples 中的例子们都被拷贝到了这里的 share/ffmpeg/examples 中，这个目录中会生成一个新的 Makefile，这个 Makefile 才是用来编译例子们的。\n编译可运行的 examples 到此，我们已经得到了用来编译 examples 的 Makefile，但是还有个东西需要注意，那就是上面提到的 pkg-config。如果这个时候你直接在 share/ffmpeg/examples 目录中执行 make，一定会出现如下的日志:\nPackage libavdevice was not found in the pkg-config search path. Perhaps you should add the directory containing `libavdevice.pc' to the PKG_CONFIG_PATH environment variable No package 'libavdevice' found Package libavformat was not found in the pkg-config search path. Perhaps you should add the directory containing `libavformat.pc' to the PKG_CONFIG_PATH environment variable No package 'libavformat' found ..... cc -Wall -g -c -o avio_list_dir.o avio_list_dir.c avio_list_dir.c:23:10: fatal error: 'libavcodec/avcodec.h' file not found #include \u0026lt;libavcodec/avcodec.h\u0026gt; ^~~~~~~~~~~~~~~~~~~~~~ 1 error generated. make: *** [avio_list_dir.o] Error 1 pck-config 这个工具是需要根据配置文件来配置的，编译 examples 的 Makefile 又会依赖 pkg-config 去找例子们依赖的库和这些库的头文件放在了哪里，从而让预处理器和链接器能够成功执行预处理和链接任务。\n那我们需要自己写 pkg-config 的配置文件吗？可以自己写，但是很痛苦，所以 FFmpeg 已经配置好了，mac_build/lib/pkgconfig 目录中就存放了每个库对应的 pkg-config配置文件。\n随便打开一个看看：\nprefix=./mac_build exec_prefix=${prefix} libdir=./mac_build/lib includedir=./mac_build/include Name: libavcodec Description: FFmpeg codec library Version: 58.91.100 Requires: libswresample \u0026gt;= 3.7.100, libavutil \u0026gt;= 56.51.100 Requires.private: Conflicts: Libs: -L${libdir} -lavcodec -liconv -lm -llzma -lz -framework AudioToolbox -pthread -framework VideoToolbox -framework CoreFoundation -framework CoreMedia -framework CoreVideo -framework CoreServices Libs.private: Cflags: -I${includedir} 上面的配置其实很可读了，声明了 libavcodec 的库目录和头文件目录，以及它所依赖的库。所以我们只要让 $PKG_CONFIG_PATH 指向 mac_build/lib/pkgconfig 目录即可，同时要注意上面的 libdir 的值是 ./mac_build/lib，表示在当前目录下的 mac_build/lib 目录中查找库，所以还需要进行一个比较丑的操作解决当前目录的问题：\ncd mac_build mkdir mac_build cp -r include mac_build cp -r lib mac_build cp share/ffmpeg/examples/* . 最终脚本 所以最终我写了如下的编译脚本，在编译 FFmpeg 时同时为 doc/examples 目录下的例子们编译出对应的可执行文件:\n#! /usr/bin/env bash ./configure --prefix=./mac_build \\ --enable-gpl \\ --disable-everything \\ --enable-nonfree \\ --enable-libass \\ --enable-libfdk-aac \\ --enable-libfreetype \\ --enable-libmp3lame \\ --enable-libtheora \\ --enable-libvorbis \\ --enable-libvpx \\ --enable-libx264 \\ --enable-libopus \\ --enable-libxvid \\ --samples=fate-suite --enable-debug=3 \\ --enable-demuxer=mov,wav,wavpack \\ --enable-muxer=image2 \\ --enable-encoder=png \\ --enable-decoder=h264 \\ --enable-protocol=file \\ --enable-filter=scale,trim make clean make -j 6 make -j 6 install export PKG_CONFIG_PATH=~/code/FFmpeg-release-4.3/mac_build/lib/pkgconfig echo \u0026quot;========Start make examples========\u0026quot; cd mac_build mkdir mac_build cp -r include mac_build cp -r lib mac_build cp share/ffmpeg/examples/* . make echo \u0026quot;========Finish======== 执行完上面的脚本后，就能在 mac_build 目录中找到每个 example 对应的可执行文件，然后执行例子学习了。\n","description":"","id":6,"section":"posts","tags":["FFmpeg"],"title":"Compile And Run FFmpeg Examples","uri":"https://jiyang.site/posts/compile-and-run-ffmpeg-examples/"},{"content":" 视频编码格式为: H264, 封装格式为: mp4\n 外部参考:  手机CPU性能天梯图 手机Soc性能排行榜  能耗对比:    解码1080P 编码1080P           左边是硬件Codec的CPU占用、内存、能耗；右边是软件Codec的\n 说明:\n 内存: Codec 过程中, 通过 profiler 观察到的内存占用情况 CPU: Codec 过程中，通过 profiler 观察到的处理器使用率  解码 参与测试手机    手机 Android 系统版本 CPU/GPU 发布时间     Xiaomi MI 4LTE 6 高通骁龙801 MSM8X74AC 2014/7   Vivo X9 7.1.2 高通 骁龙625/Adreno (TM) 506 2016/11   Vivo X9 Plus 8.1.0 高通 骁龙653/Adreno510 2016/11   Vivo X30 9.0 三星 Exynos 980 2019/12   Mi Note3 9 高通 骁龙660 2017/9   SM S8 Plus(samsung SM-G955F) 9.0 三星 Exynos 8895/Adreno (TM) 540 2017/5   HUAWEI BKL-AL20 10 HiSilicon Kirin 970(麒麟970) 2017/11   Google Pixel 2 10 高通 骁龙835 2017/10   HUAWEI meta20pro 10 麒麟 980 2018/10    参与测试视频  长度均为 10 秒\n    文件 FPS 比特率 宽 高     360_10s_1MB.mp4 30 792 640 360   360_10s_2MB.mp4 30 1656 640 360   360_10s_5MB.mp4 30 4183 640 360   360_10s_10MB.mp4 30 8375 640 360   360_10s_20MB.mp4 30 16996 640 360   360_10s_30MB.mp4 30 25604 640 360   720_10s_1MB.mp4 30 775 1280 360   720_10s_2MB.mp4 30 1582 1280 720   720_10s_5MB.mp4 30 3999 1280 720   720_10s_10MB.mp4 30 8175 1280 720   720_10s_20MB.mp4 30 16372 1280 720   720_10s_30MB.mp4 30 25657 1280 720   1080_10s_1MB.mp4 30 815 1920 1080   1080_10s_2MB.mp4 30 1569 1920 1080   1080_10s_5MB.mp4 30 3948 1920 1080   1080_10s_10MB.mp4 30 7986 1920 1080   1080_10s_20MB.mp4 30 16183 1920 1080   1080_10s_30MB.mp4 30 24563 1920 1080    测试结果 说明:\n 耗时: 解码过程中，前后两帧解码成功的时间差，不包括解码之后的像素格式转换等操作(解出来都是 YUV420P 的格式)  总结  mediacodec 解码上对内存和CPU的消耗都明显低于 ffmpeg(ffmpeg 内存的消耗主要在 native 内存) 随着视频分辨率的增加, ffmpeg 的解码效率降低较快, mediacodec 则相对较慢 在 1080P 上, ffmpeg 的解码效率在大部分手机上已经低于了 30FPS 的要求 MediaCodec 由于依赖手机厂家的实现, 可能存在某些分辨率硬解不支持的情况  MediaCodec 本质 Android SDK 是向开发者提供的一套通用编解码接口，底层的硬件 Codec 实现需要由具体的厂家做，如果厂家没做自己的硬件编解码实现, 谷歌也提供了支持上限 1080P 的软件 Codec 实现(Android 10时)   虽然从统计中部分 ffmpeg 耗时小于 MediaCodec，但是如果在手机处理器较忙碌的情况下, ffmpeg CPU 使用率较高的问题就会被放大，导致耗时增加 某些手机的 MediaCodec 不支持 mov 格式的封装 编码上: FFMpeg 的灵活性较高；MediaCodec 的编码参数则最好按照谷歌描述的标准设置; 某些机型 MediaCodec 不支持 4K 视频编解码(这些机型本身录像也不支持 4K 录像)  ","description":"最近工作涉及视频编解码的, 所以进行了相关领域的学习. 这里记录下软件和硬件解码的效率对比","id":7,"section":"posts","tags":["FFmpeg","MediaCodec","Video"],"title":"Android 上 FFMpeg 和 MediaCodec 视频解码效率对比","uri":"https://jiyang.site/posts/android-ffmpeg-vs-mediacodec-video-decode/"},{"content":"在 Android 上，native 层的代码出现问题时，系统内核将会发送一些信号到应用进程，应用进程可以通过自定义信号的处理过程来实现 native crash 的收集等工作。\nLinux 信号  在计算机科学中，信号（英语：Signals）是 Unix、类 Unix 以及其他 POSIX 兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就会执行默认的处理函数。\n 信号类似于中断，不同之处在于中断由处理器产生并由内核处理，而信号由内核产生(可能通过系统调用)并由用户进程处理。当然内核也可以将中断作为信号传递给导致中断的用户进程。\n常见信号 无法被截获处理的信号\n SIGKILL: 这个信号不能被捕获或忽略，同时接收这个信号的进程在收到这个信号时也不能执行任何清理工作 SIGSTOP  发送信号   终端\n Ctrl-C 发送 SIGINT，终止进程 Ctrl-Z 发送 SIGTSTP，挂起进程 Ctrl-\\ 发送 SIGQUIT，终止进程并内存转储到硬盘    程序\n 通过 kill() 系统调用 除零、段错误等异常会产生信号 内核可以向进程发送信号    处理信号 sigaction sigaction() 系统调用用于更改进程在接收到特定信号时所采取的操作。通过 sigaction 系统调用设置信号处理函数。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。\n我这里定义了一个 NativeCatcher 空间来做 native crash 的收集。\n1 2 3 4 5 6 7 8 9 10 11 12 13  namespace NativeCatcher { // 只捕获会造成进程终止的几种异常  const int SIGNALS_LEN = 7; const int signal_array[] = {SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV, SIGSTKFLT, SIGSYS}; // 储存系统默认的异常处理  struct sigaction old_signal_handlers[SIGNALS_LEN]; void init(); void signal_handler(int, siginfo_t *, void *); void make_crash(); }   在 JNI_OnLoad 的时候，调用 init 设置异常处理函数:\n1 2 3 4 5 6 7  static jclass CLASS = nullptr; extern \u0026#34;C\u0026#34; jint JNI_OnLoad(JavaVM *vm, void *reserved) { NativeCatcher::init(); //...  return JNI_VERSION_1_4; }   注册异常处理函数, 并持有默认的处理函数。sigaction 是 sigaction() 系统调用的参数, sa_flags 用于配置信号会携带的数据, 如果 sa_flags 含有 SA_SIGINFO 标志位, 则异常处理函数(sa_sigaction) 需要为 void (*sa_sigaction)(int, siginfo_t *, void *) 的函数指针，否则就需要为 void (*sa_handler)(int) 的函数指针。\n1 2 3 4 5 6 7 8 9  void NativeCatcher::init() { struct sigaction handler = { .sa_sigaction = NativeCatcher::signal_handler, .sa_flags = SA_SIGINFO }; for (int i = 0; i \u0026lt; SIGNALS_LEN; ++i) { sigaction(signal_array[i], \u0026amp;handler, \u0026amp;old_signal_handlers[i]); } }   异常处理函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  void NativeCatcher::signal_handler(int signal, siginfo_t *info, void *context) { // 自己做一些处理工作  const int code = info-\u0026gt;si_code; LOG_D(\u0026#34;handler signal %d, code: %d, pid: %d, uid: %d, tid: %d\u0026#34;, signal, code, info-\u0026gt;si_pid, info-\u0026gt;si_uid, info-\u0026gt;si_tid ); // 找到异常对应的默认处理函数  int index = -1; for (int i = 0; i \u0026lt; SIGNALS_LEN; ++i) { if (signal_array[i] == signal) { index = i; break; } } if (index == -1) { LOG_E(\u0026#34;Not found match handler\u0026#34;); exit(code); } struct sigaction old = old_signal_handlers[index]; // 调用默认的异常处理函数  old.sa_sigaction(signal, info, context); }   模拟产生异常:\n1 2 3 4  void NativeCatcher::make_crash() { int a = 0; int i = 10 / a; }   获取 crash 数据 异常处理函数的第3个参数 void* context 将会用与 crash 数据的收集。context 参数是指向 ucontext_t 类型的一个指针。\n The ucontext_t type is a structure type suitable for holding the context for a user thread of execution. A thread\u0026rsquo;s context includes its stack, saved registers, and list of blocked signals\n ucontext_t 结构体会包含出现异常的线程的上下文信息:\n 执行栈 存储的寄存器 阻塞的信号列表  具体的字段信息:\n uc_link: 当前方法返回时应该返回到的地址(如果 uc_link 等于 NULL ，那么当这个方法返回时进程就会退出) uc_sigmask: 阻塞的信号 uc_stack: 执行栈 uc_mcontext: 存储的寄存器(uc_mcontext 字段与机器的处理器架构相关)  由于寄存器等信息在不同处理器架构下都不相同。如下是在 arm 架构下的 ucontext_t 定义:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #if defined(__arm__)  #define NGREG 18 /* Like glibc. */ typedef int greg_t; typedef greg_t gregset_t[NGREG]; typedef struct user_fpregs fpregset_t; #include \u0026lt;asm/sigcontext.h\u0026gt;typedef struct sigcontext mcontext_t; typedef struct ucontext { unsigned long uc_flags; struct ucontext* uc_link; stack_t uc_stack; mcontext_t uc_mcontext; sigset_t uc_sigmask; /* Android has a wrong (smaller) sigset_t on ARM. */ uint32_t __padding_rt_sigset; /* The kernel adds extra padding after uc_sigmask to match glibc sigset_t on ARM. */ char __padding[120]; unsigned long uc_regspace[128] __attribute__((__aligned__(8))); } ucontext_t;   从上面可以看出，在 ARM 下这里会在 gregset_t 数组中储存 18 个寄存器，而且 mcontext_t 的类型是 arm/sigcontext.h 中的 sigcontext:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  struct sigcontext { unsigned long trap_no; unsigned long error_code; unsigned long oldmask; unsigned long arm_r0; unsigned long arm_r1; unsigned long arm_r2; unsigned long arm_r3; unsigned long arm_r4; unsigned long arm_r5; unsigned long arm_r6; unsigned long arm_r7; unsigned long arm_r8; unsigned long arm_r9; unsigned long arm_r10; unsigned long arm_fp; unsigned long arm_ip; unsigned long arm_sp; unsigned long arm_lr; unsigned long arm_pc; unsigned long arm_cpsr; unsigned long fault_address; };   sigcontext 中的 arm_pc 就代表了 ARM 处理器的 PC 寄存器。\n定位问题代码 当 native 代码运行出现异常时，我们其他能够直接从输出中看到问题代码所属的源码文件和行数。这就涉及到了 so 文件的编码格式(ELF) 和 native 程序的部分运行原理(程序计数器)。\n首先程序计数器一般称作 PC(Program Counter)，在处理器中一般都有专门的寄存器来储存它的值，称为 PC 寄存器。PC 寄存器中储存着处理器当前执行的指令的内存地址, 获取这个内存地址之后，使用 addr2line 工具就能找到地址对应的源码行数。\n定义如下方法来实现获取程序计数器存储的地址:\n1  uint NativeCatcher::get_pc(const void *context);   由于不同的处理器架构在不同的寄存器中储存程序寄存器，所以需要针对性的获取:\n1 2 3 4 5 6 7 8 9 10 11 12 13  const auto *ucxt = static_cast\u0026lt;const ucontext_t *\u0026gt;(context); greg_t absolute_pc; #if defined(__arm__)  absolute_pc = ucxt-\u0026gt;uc_mcontext.arm_pc; #elif defined(__aarch64__)  absolute_pc = ucxt-\u0026gt;uc_mcontext.pc; #elif defined(__i386__)  absolute_pc = ucxt-\u0026gt;uc_mcontext.gregs[REG_EIP]; #elif defined(__mips__)  absolute_pc = ucxt-\u0026gt;uc_mcontext.pc; #elif defined(__x86_64__)  absolute_pc = ucxt-\u0026gt;uc_mcontext.gregs[REG_RIP]; #endif   程序寄存器中存储的当前指令在内存中的绝对地址 ，而 addr2line 工具需要的是指令在指令所属的 so 中的相对地址，所以需要先获取出现异常的指令属于的共享库(so)被加载到内存的开始地址，然后使用 绝对地址 减去 开始地址 得出程序寄存器相对 开始地址 的偏移量: 相对地址 = 绝对地址(pc) - so被加载到的地址。通过 dladdr 库函数，可以找到一个绝对地址所属的 so, 以及 so 被加载到内存的位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13  Dl_info dl_info; LOG_D(\u0026#34;calculate pc(%d)\u0026#34;, absolute_pc); int result = dladdr((void *) absolute_pc, \u0026amp;dl_info); if (result \u0026amp;\u0026amp; dl_info.dli_fname) { // so 加载到内存的地址  uint base = reinterpret_cast\u0026lt;long\u0026gt;(dl_info.dli_fbase); // 当前 pc 属于的方法的名称  LOG_D(\u0026#34;symbol is %s\u0026#34;, dl_info.dli_sname); // 计算相对位置  uint relative_pc = absolute_pc - base; return relative_pc; } return 0;   输出:\n1 2 3 4  D: calculate pc(613568945) D: share object is /data/app/.../lib/x86_64/libnative-catcher.so D: symbol is _ZN13NativeCatcher10make_crashEv D: relative pc register: 00000000000011b1   使用 addr2line 找到 pc 寄存器对应的方法和行数:\n1 2 3  ▶ x86_64_addr2line -e libnative-catcher.so -f 00000000000011b1 _ZN13NativeCatcher10make_crashEv ??:?   debug 模式下 从输出上看到由于行数没有找到而显示了 ??:?，这是因为 Android Gradle Plugin 在 native 编译时会默认对 so 进行 strip 操作，so 中与调试相关的信息都被去掉了。所以可以在 debug 编译下禁用 strip:\n1 2 3 4 5 6 7 8 9 10 11 12  android { ... buildTypes { ... debug { packagingOptions { doNotStrip \u0026#34;*/x86_64/*.so\u0026#34; } } } ... }   然后使用 debug 下编译出的 so 就能看到问题代码在源码中的行数了:\n1 2 3  ▶ x86_64_addr2line -e libnative-catcher.so -f 00000000000011b1 _ZN13NativeCatcher10make_crashEv .../src/main/cpp/native_catcher.cpp:92   release 模式下 上面提到了因为 strip 的原因，我们无法定位到问题代码在源码中的行数，但是如果不进行 strip，so 就会因为包含许多运行时用不到的符号信息、调试信息变得很大，从而导致Apk的安装包很大，而且 so 中包含调试信息也存在安全隐患。所以如何在 release 下既能使用 strip，又能让我们通过 addr2line 定位到问题代码呢？\n现在我们项目使用的 bugly 来做 Crash 上报， bugly 甚至能将 release 模式下的 native 堆栈复原为代码的行数，不经让我好奇，它是如何做到的。通过一番搜索，发现 bugly sdk 中的有使用一个 SymtabToolAndroid 来做符号表的收集。bugly 的策略是这样：收集 debug 模式下含有符号表的 so 中的 debug 相关信息，然后存在数据库中，当线上的 release 版本 so 出现 native 问题时，就先定位到 pc (native 层的程序计数器) 的位置，然后再从之前收集的 debug 符号表中定位问题代码行数。\n到 bugly 对应的 maven 仓库找到了 SymtabToolAndroid 这个工具库, 尝试导出一份符号表试下:\n1 2 3 4 5 6  static String path = \u0026#34;.../libnative-catcher.so\u0026#34;; public static void main(String[] args) { SymtabToolAndroid.main(new String[]{\u0026#34;-i\u0026#34;, path}); System.out.println(SymtabToolAndroid.symtabFileName); }   结果:\n看到这个结果就可以进一步查找 bugly 是如何生成这个文件的了。经过一番定位：\n断点处就是核心所在，bugly 将 so 中上面几种内容储存为 内存地址 -\u0026gt; 源码行数 的映射。\nso 文件本身是属于 ELF 文件的，.debug_info、.debug_line .debug_str 和 .debug_ranges 代表的是 ELF 文件中 Section 的名称。\nELF 文件 Section ELF 作为一种可执行、可链接的二进制文件，其文件格式允许文件的生成方写入多个 Section，这里我们只看上面几种 Section，其实还有其他 Section 这里不涉及。\n通过 Android NDK 工具包中的 readelf 工具可以查看 ELF 文件的详细内容, readelf -S 查看含有哪些 Section:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ▶ x86_64_readelf libnative-catcher.so -S There are 38 section headers, starting at offset 0xec78: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [25] .debug_str PROGBITS 0000000000000000 0000206d 0000000000005229 0000000000000001 MS 0 0 1 [28] .debug_info PROGBITS 0000000000000000 00007ce5 0000000000005a51 0000000000000000 0 0 1 [29] .debug_ranges PROGBITS 0000000000000000 0000d736 0000000000000070 0000000000000000 0 0 1 [33] .debug_line PROGBITS 0000000000000000 0000dec9 00000000000005ed 0000000000000000 0 0 1   那这些 Section 我们应该如何从 ELF 文件(我们这里是 so)中读取呢? 在查找读取方式的过程中，我发现了一个新名词 DWARF。原来 ELF 文件中的调试信息都是按照一种叫 DWARF 的标准来读写的。http://dwarfstd.org/ 的维护网站上详细介绍了这个标准。\n通过 readelf 的 --debug-dump 方式，我们可以输出对应 Section 的内容:\ndebug_line --debug-dump=decodedline: 会解码输出 .debug_line 的内容，储存着某行代码在编译之后的内存地址\n1 2 3 4 5 6 7 8 9 10  ▶ x86_64_readelf libnative-catcher.so --debug-dump=decodedline Decoded dump of debug contents of section .debug_line: File name Line number Starting address ../native_catcher.cpp: native_catcher.cpp 91 0x11a0 native_catcher.cpp 92 0x11a9 native_catcher.cpp 93 0x11b0 native_catcher.cpp 93 0x11b4 native_catcher.cpp 94 0x11b7   这里查看的是 debug 模式下的 so 的 .debug_line Section, 可以看到包含了上面期望的 0x11b0 地址，它对应的源码行数是 93 行，这和 addr2line 的结果一致。\n所以，要在 release 模式下没有符号信息的情况下找到出错地址对应的源码行数，可以将包含调试信息的 so 的 .debug_line Section 中的内容导出储存，然后根据出错地址匹配到源码行数。\nPS: \u0026ndash;debug-dump .debug_line 的输出中，是按方法分的，每块对应的一个方法相关的行，方法之间以文件路径分隔：\n1 2 3 4 5 6 7 8 9  File name Line number Starting address cpp/native_catcher.cpp: native_catcher.cpp 16 0xcf0 cpp/native_catcher.cpp: native_catcher.cpp 26 0xda0 cpp/native_catcher.cpp: native_catcher.cpp 55 0xf30   获取方法调用栈 获取方法的调用栈，有多种方式。目前应用最多的是 Google 的 breakpad\n 系统 \u0026lt;unwind.h\u0026gt; 库 系统 libcorkscrew.so 开源库 coffeecatch Google breakpad  Breakpad Breakpad 的几大部分:\n client 是开发者应该引用的一个库。通过它可以捕获当前线程的状态、当前加载的可执行文件和共享库的标识去生成 minidump 文件。开发者可以配置 client，使其在发生崩溃或显式请求时生成 minidump 文件 symbol dumper 程序：它读取编译器生成的调试信息，并以 Breakpad 自己的格式生成符号文件 processor 程序：它读取 minidump 文件，为 minidump 文件对应的可执行文件和共享库找到匹配的符号文件，并生成可读的 C/C++ 调用栈。  参考  Unix信号 Android Native Crash  ","description":"记录捕获到的一些关于 natice crash 处理相关的内容","id":8,"section":"posts","tags":["ELF","DWARF","Signal"],"title":"Android 处理 Native Crash","uri":"https://jiyang.site/posts/collect-android-so-crash/"},{"content":"在编写 c/c++ 代码时，我们通常使用 #define 定义一些宏，然后编译器在 预处理 阶段会把用到宏的地方替换为宏的内容，由于宏的替换完全是一种文本替换，所以在一些情况下如果使用不当，容易产生副作用。\n运算符优先级问题 考虑如下宏定义:\n1  #define MAX(x,y) x \u0026gt; y ? x:y   使用1:\n1  int a = MAX(1, 2);   预处理后:\n1  int a = 1 \u0026gt; 2 ? 1:2;   预处理之后的代码，符合我们的预期。\n使用2:\n1  int b = 3 * MAX(1, 2);   预处理后:\n1  int a = 3 * 1 \u0026gt; 2 ? 1:2;   这时预处理后的代码，就产生了副作用，由于 * 运算符的优先级高于 \u0026gt;，所以编译之后，优先执行 3 * 1，执行结果就成了 1，而不是期望的 6。\n解决方法: 使用 () 包裹宏的内容，以避免优先级问题。\n1  #define MAX(x,y) (x \u0026gt; y ? x:y)   宏参数传递表达式问题 考虑如下宏定义:\n1  #define MIN(x,y) (x \u0026lt; y ? x:y)   这个宏的定义，就采用了 () 包裹，虽然避免了运算符优先级问题，但是还是存在副作用。考虑如下使用方式：\n1  int a = MIN(i++, j++);   预处理之后:\n1  int a = (i++ \u0026lt; j++ ? i++ : j++);   由于预处理是直接的文本替换，就会造成表达式会被执行两次，也产生了副作用。于是一般会在宏里额外定义局部变量来避免副作用：\n1 2 3 4  #define max(type, x, y)({ \\ const type _x = (x); \\ const type _y = (y); \\ _x \u0026gt; _y ? _x : _y; })   1  int a = MIN(int, i++, j++);   预处理之后:\n1  int a = ({ const int _x = (i++); const int _y = (j++); _x \u0026gt; _y ? _x : _y; });   保证了表达式只被执行一次。\n","description":"在 native 编程中经常利用的宏，使用不当就会出现一些副作用","id":9,"section":"posts","tags":["代码工程"],"title":"GNU C 避免宏定义产生副作用","uri":"https://jiyang.site/posts/gnu-c-%E9%81%BF%E5%85%8D%E5%AE%8F%E5%AE%9A%E4%B9%89%E4%BA%A7%E7%94%9F%E5%89%AF%E4%BD%9C%E7%94%A8/"},{"content":"缓存分类   块缓存\n一般用于访问真正的磁盘文件。C库会为文件访问申请一块内存，只有当文件内容将缓存块填满或执行冲刷函数flush时，C库才会将缓存内容写入内核中。\n  行缓存\n一般用于访问终端。当遇到一个换行符时，就会引发真正的I/O操作。需要注意的是，C库的行缓存也是固定大小的。因此，当缓存已满，即使没有换行符时也会引发I/O操作。\n  无缓存\nC库没有进行任何的缓存。任何C库的I/O调用都会引发实际的I/O操作。\n​\n  标准输入输出的默认缓存机制 stdio.h 中声明了 stdin 、stdout 和 stderr 的全局变量以及对应的宏:\n1 2 3 4 5 6 7 8 9 10 11 12  typedef struct _IO_FILE FILE; /* Standard streams. */ extern struct _IO_FILE *stdin; /* Standard input stream. */ extern struct _IO_FILE *stdout; /* Standard output stream. */ extern struct _IO_FILE *stderr; /* Standard error output stream. */ #ifdef __STDC__ /* C89/C99 say they\u0026#39;re macros. Make them happy. */ #define stdin stdin #define stdout stdout #define stderr stderr #endif   可以看出 stdin stdout stderr 其实就是文件指针, 它们的定义代码如下:\n1 2 3  _IO_FILE *stdin = (FILE *) \u0026amp;_IO_2_1_stdin_; _IO_FILE *stdout = (FILE *) \u0026amp;_IO_2_1_stdout_; _IO_FILE *stderr = (FILE *) \u0026amp;_IO_2_1_stderr_;   1 2 3  DEF_STDFILE(_IO_2_1_stdin_, 0, 0, _IO_NO_WRITES); DEF_STDFILE(_IO_2_1_stdout_, 1, \u0026amp;_IO_2_1_stdin_, _IO_NO_READS); DEF_STDFILE(_IO_2_1_stderr_, 2, \u0026amp;_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);   DEF_STDFILE 是一个宏定义，用于初始化 C 库中的 FILE 结构。从源码上就可以看到3个标准输入输出的差异：\n stdin: 文件描述符为 0, 不可写(_IO_NO_WRITES) stdout: 文件描述符为 1, 不可读(_IO_NO_READS) stderr: 文件描述符为 2, 不可读(_IO_NO_READS)   通常，所有文件都是块缓冲的。当文件上发生第一个I/O操作时，将调用 malloc 并获得一个最优大小的缓冲区。\n如果一个流指向一个终端(比如通常的 stdout)，那么它就是行缓冲的。标准错误流 stderr 总是未缓冲的。\n 从源码中的定义也能看出, stderr 在定义时还追加了 IO_UNBUFFERED，表示无缓冲。\nC库接口 C库提供了接口，用于修改默认的缓存行为:\n1 2 3 4  void setbuf(FILE *restrict stream, char *restrict buf); void setbuffer(FILE *stream, char *buf, int size); int setlinebuf(FILE *stream); int setvbuf(FILE *restrict stream, char *restrict buf, int type, size_t size);   前3个接口内部都调用了 setvbuf 接口, 所以主要看 setvbuf 接口就行。\n 当 size 参数设为 0 时，代表使用默认的最优大小缓冲区分配 当 size 不为 0 时，除了未缓冲的文件，buf 参数应该指向一个至少有 size 大小的缓冲区; 如果 buf 不为空，则调用方必须在流关闭后自己释放该缓冲区 当 size 不为 0，但 buf 为 NULL 时，则库会自动分配给定大小的缓冲区，并且自动在流关闭时释放  例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //c_lib_io_cache.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int main(void) { printf(\u0026#34;Hello \u0026#34;); if(0 == fork()) { printf(\u0026#34;child\\n\u0026#34;); return 0; } printf(\u0026#34;parent\\n\u0026#34;); return 0; }   上述代码执行后：\n▶ gcc c_lib_io_cache.c -o main.o \u0026amp;\u0026amp; ./main.o Hello parent Hello child 因为 stdout 在终端默认为行缓存，所以最开始执行 printf(\u0026quot;Hello \u0026quot;) 时并没有触发真正的输出, Hello  只被写到了 父进程的 stdout 的内存缓存中，当父进程通过 fork 创建子进程之后, 子进程的内存空间也拥有和父进程一样的内容，所以子进程调用 printf(\u0026quot;child\\n\u0026quot;) 时，连带自己 stdout 缓存空间中的 Hello  一起输出了。\n下面通过两种方式去避免上述问题的出现:\n  强制立即输出到 stdout\n在父进程 printf(\u0026quot;Hello \u0026quot;) 后调用 fflush(stdout) 强制立即输出到 stdout\n1 2 3 4  //... printf(\u0026#34;Hello \u0026#34;); fflush(stdout); //...   ▶ gcc c_lib_io_cache.c -o main.o \u0026amp;\u0026amp; ./main.o Hello parent child   修改 stdout 的缓存大小\n在 printf(\u0026quot;Hello \u0026quot;) 前调用 setbuffer 将 stdout 的缓存大小设为 1 个字节\n1 2 3 4  //... setbuffer(stdout, NULL, 1); printf(\u0026#34;Hello \u0026#34;); //...   ▶ gcc c_lib_io_cache.c -o main.o \u0026amp;\u0026amp; ./main.o Hello parent child   虽然第2种方式也实现了目的，但是将行缓存大小设为1个字节，终究不是最优方法，没有利用到缓存机制。所以最佳应该方法应该是第一种利用 fflush 强制 IO 同步。\n","description":"在标准的 C 库中，对 IO 有一定的缓存机制。理解这些机制或许能在分析某些问题时提供参考。","id":10,"section":"posts","tags":null,"title":"C库的IO缓存机制","uri":"https://jiyang.site/posts/libc-io-cache/"},{"content":"背景: 使用 Kotlin Coroutine 的使用方法，参照官方文档食用即可。这里只简单给出一些概念。\nsuspend ​使用 suspend 表示函数支持挂起操作，目的在于告诉编译器，该方法可能产生阻塞(因为普通方法也能使用 suspend 标记，但是实际不会起作用)。suspend 方法会被编译为继承 SuspendLambda 的类\n创建协程   launch\n返回 Job，​能够获取和控制当前 Scope 下的协程的状态，比如取消(cancel)协程、获取是否运行(isActive)。\n  async\n​返回 Deferred，Deferred 继承自 Job，它拥有 Job 的功能。另外 Deferred 还类似 Java UTC 中的 Future 接口，通过 Deferred 能够获取协程执行完毕之后的结果。\n  withContext\n​切换代码块的执行上下文\n  结构化并发 ​将多个协程放到一个可以管理的空间里面，这个空间的名字就叫 CoroutineScope。通过 Scope 就能够统一的管理内部的协程，方便对多个协程整体上做取消(cancel)、等待结果(join)等操作。\n实现原理 Kotlin 的协程实现属于有限状态机编程, 有限状态机编程是编程范式的一种。是指利用有限状态机来进行编程实现。\nKotlin 在 JVM 上实现的协程机制，本身没有超脱出 JVM 的范畴，也不能够超脱，所以代码本质还是运行在操作系统级别的线程上的。所以 Kotlin Coroutine 的实现就是要在 JVM 上实现一套代码(任务)的挂起和恢复机制，而挂起和恢复刚好能抽取为两种状态，于是要实现代码运行的挂起和恢复的需求，就转变为了实现一种控制状态转移的需求。而有限状态下的编程，使用有限状态机编程范式再合适不过了。\nKotlin 协程本质还是运行在线程上的，所以如果从代码的运行角度来看，并没有太多的魔法，代码的运行机制和传统一样，虚拟机按行读取指令和操作数，然后执行操作。所以 Kotlin 协程的魔法更多是在编译期就开始了。\n​执行的最小单元 CodeBlock 在 Kotlin 代码编译时，launch/async 和 suspend 方法中的代码会根据挂起点被拆分到多个 Code Block 中。Code Block 会被封装为 Runnable，被封装的 Runnable 会被 Dispatcher 执行。使用哪种 Dispatcher 则由传递给 launch/async 的 CoroutineContext 参数决定。\n例子代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class RunBlockingDemo { fun demo() { runBlocking { println(1) // block 1  launch { // block 1  println(3) // block 2  suspendFunc() // block 2  println(6) // block 3  } println(2) // block 1  } } private suspend fun suspendFunc() { println(4) // block 4  delay(500) // block 4  println(5) // block 5  } }   例子代码中，使用的 runBlocking 来创建协程，runBlocking 会为内部的协程提供一个阻塞当前线程的 EventLoop 队列，等队列中的所有协程都执行完之后，runBlocking 才会执行完毕。例子代码中的 launch 没有传递额外的 CoroutineContext 参数，所以它会继承 runBlocking 的 context 去使用。\n例子代码的执行过程可以简述为:\n   运行流 说明      1. 调用 runBlocking，block 1 入队，然后开始循环从队列中消费任务 2. block 1 出队执行，输出 1\n3. launch 被调用，block 2 入队\n4. 输出 3\n5. block 1 执行完成，执行继续从队列中取下一个任务\n6. block 2 出队执行，输出 3，调用 suspendFunc 方法\n8. suspendFunc 方法在编译之后，会在调用时先持有它自己的代码执行完成之后将要继续执行的代码块(block 3)的引用(在它自己的代码执行完成之后，就会恢复执行 block 3)\n9. 执行 suspendFunc ，输出 4\n10. 调用 delay ，block 5 会被封装为一个 delay task 并入队\n11. block 2 和 block 4 执行完毕，执行继续从队列中取下一个任务\n12. 这时队列中存在的任务是 block 5 ，循环会一直循环等待，直到到满足了 block 5 delay 的时间时就将 block 5 出队\n13. block 5 出队执行，输出 5\n14. block 5 执行完成就代表 suspendFunc 执行完毕了，就会恢复执行 suspendFunc 在进入时持有的 block 3\n15. block 3 执行，输出 6\n16. runBlocking 中的所有代码执行完毕，程序执行完毕    通过上面这个例子能看出，虽然所有代码都是在同一个线程执行的，但是 Kotlin 协程却实现了非阻塞的运行(println(2) 不会被 println(3) 阻塞)，而协程内部又是按照同步的方式执行的(println(5) 在 delay 完成之后才会被执行)。\n正是由于编译器将来自不同协程的代码块相互交错的插入到事件循环队列中，才让仅使用一个线程就能实现代码块的挂起和恢复得以实现。\n其他的 CoroutineContext 或许使用不同的 Dispatcher 在不同的线程上采用不同的策略去执行协程，但是其过程与这个例子是类似的。\n​维护执行状态的 Continuation 到目前为止，我们已经了解了使代码块执行的逻辑概念了。但是，在该概念是如何实现上面还存在一些疑惑。\n 如何在已编译的 Java 字节码中实现这个逻辑概念？ 如何跟踪代码块的执行状态？或者说如何决定一个代码块执行完成之后该执行的哪一个代码块？  我尝试通过 JD-GUI 去反编译 RunBlockingDemo 类，但是 suspendFuncA 方法 JD-GUI 反编译失败了，没有显示出来。于是我先通过 javap RunBlockingDemo 查看了 RunBlockingDemo 类会有哪些方法，发现 suspendFuncA 被编译为了下面的样子：\n1  final java.lang.Object suspendFuncA(kotlin.coroutines.Continuation\u0026lt;? super kotlin.Unit\u0026gt;);   然后我再使用 javap -c RunBlockingDemo 反编译得到编译之后的字节码:\n  *suspendFuncA* 方法的反编译字节码太长, 点击可展开  Code: 0: aload_1 // 加载第二个局部变量到栈顶, 这里的第二个局部变量就是方法的第一个参数 Continuation 1: instanceof #29 // class RunBlockingDemo$suspendFuncA$1 4: ifeq 39 //如果不是 RunBlockingDemo$suspendFuncA$1 的对象，就跳转到 39 行 7: aload_1 //否则加载第二个局部变量到栈顶 8: checkcast #29 // class RunBlockingDemo$suspendFuncA$1 11: astore 5 //栈顶对象存入第5个局部变量，即方法的第一个参数通过了 checkcast 判断之后，存入第5个局部变量 13: aload 5 //加载第5个局部变量到栈顶 15: getfield #33 // Field RunBlockingDemo$suspendFuncA$1.label:I // 获取 label 字段 18: ldc #34 // int -2147483648 // 从常量池中加载第34个整形常量到栈顶，其值是 Integer.MIN_VALUE 20: iand // 从栈中弹出两个整数，进行与运算，即将 label 和 Integer.MIN_VALUE 进行与运算 21: ifeq 39 // 如果结果为0，就跳转到 39 行 24: aload 5 // 否则加载第5个局部变量到栈顶 26: dup // 复制栈顶元素 27: getfield #33 // Field RunBlockingDemo$suspendFuncA$1.label:I // 加载 label 字段到栈顶 30: ldc #34 // int -2147483648 // 从常量池加载数字 Integer.MIN_VALUE 32: isub // label 减去 Integer.MIN_VALUE 的结果存入栈顶 33: putfield #33 // Field RunBlockingDemo$suspendFuncA$1.label:I // 将栈顶元素存入 label 36: goto 50 // 跳转到 50 行 39: new #29 // class RunBlockingDemo$suspendFuncA$1 42: dup 43: aload_0 44: aload_1 45: invokespecial #35 // Method RunBlockingDemo$suspendFuncA$1.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:(LRunBlockingDemo;Lkotlin/coroutines/Continuation;)V 48: astore 5 50: aload 5 // 加载第5个局部变量 52: getfield #39 // Field RunBlockingDemo$suspendFuncA$1.result:Ljava/lang/Object; // result 字段加载到栈顶 55: astore 4 // result 存到第4个局部变量中 57: invokestatic #45 // Method kotlin/coroutines/intrinsics/IntrinsicsKt.getCOROUTINE_SUSPENDED:()Ljava/lang/Object; 60: astore 6 // 将 getCOUROUTINE_SUSPENDED() 的返回值存入第6个局部变量中 62: aload 5 // 加载第5个局部变量 64: getfield #33 // Field RunBlockingDemo$suspendFuncA$1.label:I // 加载 label 字段到栈顶 67: tableswitch { // 0 to 1 0: 88 // label 为 0 就跳转到 88 行 1: 133 // label 为 1 就跳转到 133 行 default: 165 // 默认跳转到 165 行 } 88: aload 4 // 加载 result 到栈顶 90: invokestatic #51 // Method kotlin/ResultKt.throwOnFailure:(Ljava/lang/Object;)V 93: iconst_4 // 加载常量数字 4 到栈顶 94: istore_2 // 将栈顶数字(这里就是4)存到第二个局部变量中 95: iconst_0 96: istore_3 // 将数字0 存到第3个局部变量中 97: getstatic #57 // Field java/lang/System.out:Ljava/io/PrintStream; 100: iload_2 // 加载第2个局部变量，这里存的是 4 101: invokevirtual #63 // Method java/io/PrintStream.println:(I)V // 调用 println 输出栈顶的数字 4 104: ldc2_w #64 // long 500l // 加载常量池第63个长整形数字到栈顶，这里就是 500L 107: aload 5 109: aload 5 111: aload_0 112: putfield #68 // Field RunBlockingDemo$suspendFuncA$1.L$0:Ljava/lang/Object; // 将 this 对象引用存储到 L$0 字段 115: aload 5 117: iconst_1 118: putfield #33 // Field RunBlockingDemo$suspendFuncA$1.label:I // label 赋值 1 121: invokestatic #74 // Method kotlinx/coroutines/DelayKt.delay:(JLkotlin/coroutines/Continuation;)Ljava/lang/Object; 124: dup 125: aload 6 127: if_acmpne 149 // 如果 delay 的返回值 != getCOROUTINE_SUSPEND() 的返回值，就跳转 149 行 130: aload 6 // 否则返回 getCOROUTINE_SUSPEND() 的返回值 132: areturn 133: aload 5 135: getfield #68 // Field RunBlockingDemo$suspendFuncA$1.L$0:Ljava/lang/Object; 138: checkcast #2 // class RunBlockingDemo 141: astore_0 142: aload 4 144: invokestatic #51 // Method kotlin/ResultKt.throwOnFailure:(Ljava/lang/Object;)V 147: aload 4 149: pop 150: iconst_5 151: istore_2 // 5 存入第2个局部变量 152: iconst_0 153: istore_3 // 0 存入第3个局部变量 154: getstatic #57 // Field java/lang/System.out:Ljava/io/PrintStream; 157: iload_2 158: invokevirtual #63 // Method java/io/PrintStream.println:(I)V // 输出 5 161: getstatic #80 // Field kotlin/Unit.INSTANCE:Lkotlin/Unit; 164: areturn // return Unit.INSTANCE 165: new #82 // class java/lang/IllegalStateException 168: dup 169: ldc #84 // String call to 'resume' before 'invoke' with coroutine 171: invokespecial #87 // Method java/lang/IllegalStateException.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:(Ljava/lang/String;)V 174: athrow // 抛出异常  下面是我根据反编译出来的字节码推测出的 RunBlockingDemo 类的 suspendFuncA 方法经过编译器处理之后的源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  final Object suspendFuncA(Continuation\u0026lt;?\u0026gt; continuation){ if(!continuation istanceOf RunBlockingDemo$suspendFuncA$1 || (RunBlockingDemo$suspendFuncA$1)continuation.label \u0026amp; Integer.MIN_VALUE == 0 ){ continuation = new RunBlockingDemo$suspendFuncA$1(this); } continuation.label = contination.label - Integer.MIN_VALUE; Object obj = IntrinsicsKt.getCOROUTINE_SUSPEND(); switch(continuation.label) { case 0: println(4); continuation.L$0 = this; continuation.label = 1; if(delay(500, continuation) == obj) { return obj; } case 1: ResultKt.throwOnFailure(continuation.result); println(5); return Unit.INSTANCE; default: throw new IllegalStateException(\u0026#34;call to \u0026#39;resume\u0026#39; before \u0026#39;invoke\u0026#39; with coroutine\u0026#34;); } }   从源码中能得出两个有趣的地方:\n 例子中的 supendFuncA 是没有参数的，但是编译之后，编译器为它增加了一个 Continuation 类型的参数 suspendFuncA 内部通过一个 switch-case 去调度执行不同的代码块，而 switch 的参数则是传入的 Continuation 对象的 label 字段  因此不难推测出，编译器为 suspendFuncA 方法增加的 Continuation 参数就是用来跟踪协程运行状态的对象，而且运行状态就保存在一个简单的 int 类型的 label 字段中。\n再回头看看 suspendFuncA 方法是如何被调用的。\n 首先编译器会为 suspend 方法生成一个实现了 ContinuationImpl 的包装类，然后在包装类的 invokeSuspend 方法中调用 suspendFuncA。\n下面就是编译器为 suspendFuncA 方法生成的包装类(使用 JD-GUI 查看):  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class RunBlockingDemo$suspendFuncA$1 extends ContinuationImpl { int label; Object L$0; @Nullable public final Object invokeSuspend(@NotNull Object $result) { this.result = $result; this.label |= Integer.MIN_VALUE; return RunBlockingDemo.this.suspendFuncA(this); } RunBlockingDemo$suspendFuncA$1(Continuation paramContinuation) { super(paramContinuation); } }   ","description":"理解 Kotlin Coroutine 的实现原理","id":11,"section":"posts","tags":null,"title":"Kotlin 协程的实现原理简析","uri":"https://jiyang.site/posts/kotlin-coroutine-inner/"},{"content":"Exception Level  https://developer.arm.com/docs/ddi0488/d/programmers-model/armv8-architecture-concepts/exception-levels\n 在 ARMv8 处理器中，处理器的运行总是发生在 4 个异常级别之中的一个。异常级别决定了权限级别(privilege level)，每个异常级别(ELn)都有对应的权限级别(PLn)。n 的值越大，权限也就越大。\n通常会按照如下规则来配置运行软件的异常级别:\n EL0: Normal user applications EL1: Operating system kernel typically described as privileged EL2: Hypervisor EL3: Low-level firmware, including the Secure Monitor     Exception Level      EL0 EL0 的权限是最小的，运行在 EL0 的程序只能访问通用寄存器，大多数系统寄存器都不能访问，也不能修改某些系统配置，比如虚拟内存映射等。   EL1 EL1 通常是操作系统运行的级别，EL1 在 EL0 的基础上还能访问系统寄存器，也能够修改系统配置。   EL2 EL2 提供了处理器虚拟化支持。   EL3 EL3 提供了切换 Scurity 状态的能力。    获得当前 EL  https://developer.arm.com/docs/ddi0595/g/aarch64-system-registers/currentel\n 可以通过系统寄存器 CurrentEL 获取处理器当前的 Exception Level。\nAArch64 架构下 CurrentEL 用 64 位表示，其中第 [3:2] 位表示 EL，[63:4] 和 [1:0] 都是保留位。\n   EL Meaning     0b00 EL0   0b01 EL1   0b10 EL2   0b11 EL3    通过下面的代码能够获得当前的 EL:\n1 2 3 4 5 6 7  // Move the contents of a PSR to a general-purpose register // 将 CurrentEL 值写入通用寄存器 x0 mrs x0, CurrentEL // Logical Shift Right // 将 Xt 值右移 2 位 lsr x0, x0, #2   比如获取到的值是 0b0100, 因为 [1:0] 2位是保留位，总是为0，所以右移 2 位就得到了上表中的 0b01 EL。\n所以能创建如下的方法去获取当前 EL:\n1 2 3 4 5  .global get_el get_el: mrs x0, CurrentEL lsr x0, x0, #2  ret // 返回到 X30 寄存器   切换 EL 在了解异常级别的切换前，需要先了解 ARM 架构的异常。\nARM Excepion  在通常的操作系统概念中，经常提到中断：一种中断软件执行流程的机制。在 ARM 体系中，中断实际是通过异常体现的。异常是一种要求异常处理程序采取某些措施以确保系统平稳运行的条件或系统事件。每个异常类型都有对应的异常处理程序。处理完异常后，异常处理程序将为内核做好准备(比如: 恢复处理器状态、恢复异常发生时的指令地址)，以恢复发生异常之前的操作。\n   ARM 架构下有如下3种类型的异常：\n Interrupts: 中断。这里的中断是指硬件层面的中断。通常由外部硬件发起中断。 Aborts: 中止。这个就是软件层面的异常了。比如代码中访问了不存在的内存地址，进行了除0操作(指令执行错误)等问题。 Reset: 复位。复位被视为实现最高异常级别的特殊变量。这是引发异常时 ARM 处理器跳转到的指令的位置。 该向量使用 IMPLEMENTATION DEFINED 地址。 RVBAR_ELn 包含此变量的地址，其中 n 是已实现的最高异常级别的编号。所有内核都有一个复位输入，并在复位后立即执行复位异常。它是最高优先级的异常，无法屏蔽。处理器上电后，此异常用于在内核上执行初始化的代码。    除了运行时程序出现问题产生异常外，也有一些指令能够产生异常，通常执行这些指令是为了从运行于更高权限级别的软件中请求服务:\n svc: Supervisor Call 指令使用户模式程序可以请求 OS 服务 hvc: Hypervisor Call 指令使来宾 OS 可以请求系统管理程序服务。 smc: 通过 Secure monitor Call 指令，普通世界可以请求安全世界服务。(security model 参考)  如果异常是由于在 EL0 执行指令而生成的，则会将其视为 EL1 的异常。如果是在任何其他 EL 执行指令导致生成异常，则异常级别保持不变。\n  异常处理  程序只能通过「获取异常」或「从异常返回」去切换异常级别\n 也就是说程序只有在处理异常的过程中，才能切换异常级别。\n 当处理器从较高的异常级别移至较低的异常级别时，执行状态(Execution State)可以保持不变，也可以从 AArch64 切换到 AArch32 。 相反，当从较低的异常级别移到较高的异常级别时，执行状态可以保持不变或从 AArch32 切换到 AArch64 。  当应用程序发生异常时，处理器会到一个异常表去查找分派代码然后执行分派代码(异常表包含每种异常类型对应的分派代码)，分派代码选择并调用适当的函数来处理异常。分派代码执行完成后，返回到高级别的处理程序，该处理程序执行 ERET 指令返回到应用程序。\n相关寄存器 当处理异常时，会涉及几个寄存器的操作:\n 当前正在执行的指令地址(PC 寄存器)会被存储在 ELR_ELn(Exception link register) 中 当前处理器的状态(PSTATE)被存储在 SPSR_ELn(Saved Program Status Register) 异常处理程序被执行。异常处理程序可以修改 ELR 和 SPSR 异常处理程序执行 eret 指令。这个指令会从 SPSR_Eln 寄存器恢复处理器的状态，并且恢复 ELE_Eln 中储存的指令的执行​                由于异常处理程序可以修改 ELR_ELn 和 SPSR_ELn 寄存器，所以异常处理程序能够间接的修改 EL 等参数，达到切换 EL 的目的。\n切换到 EL1 回到树莓派OS这边，通电之后，处理器默认是在最高级别的 EL 运行的，也就是 EL3。现在我希望树莓派OS 启动之后切换到 EL1 执行(如同 Linux 和 Windows 都是在EL1运行)。通过配置一些系统寄存器，然后调用 eret 指令触发处理器去执行状态重读取就能达成目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  master: ldr x0, =SCTLR_VALUE_MMU_DISABLED msr sctlr_el1, x0 ldr x0, =HCR_VALUE msr hcr_el2, x0 ldr x0, =SCR_VALUE msr scr_el3, x0 ldr x0, =SPSR_VALUE msr spsr_el3, x0 adr x0, el1_entry msr elr_el3, x0 eret   配置 SCTLR_EL1  System Control Register\n sctlr_eln 寄存器被用来配置处理器的不同参数。存在 sctlr_el1、 sctlr_el2 和 sctlr_el3 分别对应 EL1、 EL2 和 EL3 的寄存器。\nsctlr_el1 寄存器能够配置 EL0 和 EL1 级别的内存等配置。通过修改 sctlr_el1 某些位的值能达到配置处理器在 EL0 和 EL1 级别运行时的行为。\n1 2  ldr x0, =SCTLR_VALUE_MMU_DISABLED msr sctlr_el1, x0   1 2 3 4 5 6 7 8 9 10 11 12 13 14  #define SCTLR_RESERVED (3 \u0026lt;\u0026lt; 28) | (3 \u0026lt;\u0026lt; 22) | (1 \u0026lt;\u0026lt; 20) | (1 \u0026lt;\u0026lt; 11) // 保留位赋值1 #define SCTLR_EE_LITTLE_ENDIAN (0 \u0026lt;\u0026lt; 25) // EL1 采用小端字节序 #define SCTLR_EOE_LITTLE_ENDIAN (0 \u0026lt;\u0026lt; 24) // EL0 采用小端字节序 #define SCTLR_I_CACHE_DISABLED (0 \u0026lt;\u0026lt; 12) // 禁用指令缓存 #define SCTLR_D_CACHE_DISABLED (0 \u0026lt;\u0026lt; 2) // 禁用数据缓存 #define SCTLR_MMU_DISABLED (0 \u0026lt;\u0026lt; 0) // 禁用内存管理单元  #define SCTLR_VALUE_MMU_DISABLED\t(SCTLR_RESERVED | SCTLR_EE_LITTLE_ENDIAN | SCTLR_I_CACHE_DISABLED | SCTLR_D_CACHE_DISABLED | SCTLR_MMU_DISABLED)   配置 HCR_EL2  Hypervisor Configuration Register\n HCR_EL2 寄存器提供了虚拟化的配置，包括定义是否将各种操作限制在EL2中。因为只有 EL2 支持 Hypervisor,所以只存在一个 HCR_EL2 寄存器。\n1 2 3  #define HCR_RW\t(1 \u0026lt;\u0026lt; 31) // EL1 的 Execution State 为 AArch64 #define HCR_VALUE\tHCR_RW   1 2  ldr x0, =HCR_VALUE msr hcr_el2, x0   配置 SCR_EL3  Secure Configuration Register\n SCR_EL3 寄存器定义当前安全状态的配置:\n EL0，EL1 和 EL2 的安全状态为 Secure 或 Non-Secure EL2 的 Execution State  1 2 3 4 5 6  #define SCR_RESERVED\t(3 \u0026lt;\u0026lt; 4) #define SCR_RW\t(1 \u0026lt;\u0026lt; 10) // EL2 的Execution State 为 AArch64 #define SCR_NS\t(1 \u0026lt;\u0026lt; 0) // 安全状态为 Non-secure #define SCR_VALUE\t(SCR_RESERVED | SCR_RW | SCR_NS)   1 2  ldr x0, =SCR_VALUE msr scr_el3, x0   配置 SPSR_EL3  Saved Program Status Register\n EL3 发生异常时，SPSR_EL3 寄存器用来保存处理器的状态。这里因为树莓派OS启动之后是在 EL3 运行，所以通过修改 SPSR_EL3 的值来修改处理器的运行状态。\n7 \u0026lt;\u0026lt; 6 意味着将 [8:7] 3 个位都置 1:\n1  #define SPSR_MASK_ALL (7 \u0026lt;\u0026lt; 6)    bit[8]: SError interrupt mask bit[7]: IRQ interrupt mask bit[6]: FIQ interrupt mask  设置 Exception level 和 selected Stack Pointer 为 EL1h:\n1 2  #define SPSR_EL1h\t(5 \u0026lt;\u0026lt; 0) #define SPSR_VALUE\t(SPSR_MASK_ALL | SPSR_EL1h)      位 含义     0b0000 EL0t   0b0100 EL1t   0b0101 (5 \u0026lt;\u0026lt; 0) EL1h   0b1000 EL2t   0b1001 EL2h   0b1100 EL3t   0b1101 EL3h    1 2  ldr x0, =SPSR_VALUE msr spsr_el3, x0   将 SPSR_EL3 的第 [3:0] 3 个位, 置为 EL1h 后，在执行 eret 指令后，处理器的状态会从 SPSR_EL3 中恢复，也就让处理器的 EL 切换到了 EL1。\n配置 ELR_EL3  Exception Link Register (EL3)\n 在 EL3 进行异常处理时，ELR_EL3 寄存器将用来保留要返回的地址。\n1 2 3 4  adr x0, el1_entry // 将 el1_entry label 地址存到 x0 msr elr_el3, x0 // 将 x0 值存到 elr_el3   先将 el1_entry 符号地址存到 elr_el3，在执行 eret 指令之后，处理器就将从 elr_el3 寄存器读取符号去恢复执行，也就间接的让处理器执行 el1_entry。\n通过配置上述系统寄存器，然后调用 eret 触发处理器的执行状态的重恢复，就能将异常级别从 EL3 切换到 EL1 了。\n","description":"理解并配置 ARM 处理器的异常级别。","id":12,"section":"posts","tags":["RPI_OS"],"title":"树莓派OS#0x02 处理器初始化","uri":"https://jiyang.site/posts/rpios-processor-init/"},{"content":"在 Android 7.0, 增加了一个 Api 可以方便的统计一个 Window 的 View 树的绘制耗时。\n功能  统计渲染子系统报告的帧生命周期中各个里程碑的时序数据。可以通过其相应的标识符查询支持的指标。\n 各个里程碑就是指:\n   FrameMetrics 指标 说明     ANIMATION_DURATION 表示执行动画回调的耗时   COMMAND_ISSUE_DURATION 表示向 GPU 发出绘制命令的耗时   DRAW_DURATION 表示将 View 树转换为 DisplayList 的耗时   FIRST_DRAW_FRAME 表示当前帧是否是当前 Window 布局中绘制的第一帧   INPUT_HANDLING_DURATION 表示处理输入事件回调的耗时   INTENDED_VSYNC_TIMESTAMP 当前帧的预期开始时间, 如果此值与 VSYNC_TIMESTAMP 不同，则表示 UI 线程上发生了阻塞，阻止了 UI 线程及时响应vsync信号   LAYOUT_MEASURE_DURATION 表示对 View 树进行 measure 和 layout 所花的时间   SWAP_BUFFERS_DURATION 表示将此帧的帧缓冲区发送给显示子系统所花的时间   SYNC_DURATION 表示将 DisplayList 与渲染线程同步所花的时间   TOTAL_DURATION 表示此帧渲染并发布给显示子系统所花费的总时间, 等于所有其他具有时间价值的指标的值之和   UNKNOWN_DELAY_DURATION 表示等待 UI 线程响应并处理帧所经过的时间, 大多数情况下应为0   VSYNC_TIMESTAMP 在所有 vsync 监听器和帧绘制中使用的时间值(Choreographer 的帧回调, 动画, View＃getDrawingTime等)     时间单位都是纳秒\n 以上所有指标都存储在一个 long 类型的数组中, 使用 FrameMetrics#getMetric 方法可以从中提取。\n使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14  val thread = HandlerThread(\u0026#34;frame-stat\u0026#34;).apply { start() } val handler = Handler(thread.looper) window.addOnFrameMetricsAvailableListener(Window.OnFrameMetricsAvailableListener { _, metric,_ -\u0026gt; // 会在 handler 对应的 thread 中执行  val copy = FrameMetrics(metric) /* 注意需要做深拷贝, 再使用 */ val vsycn = copy.getMetric(FrameMetrics.VSYNC_TIMESTAMP) val intended = copy.getMetric(FrameMetrics.INTENDED_VSYNC_TIMESTAMP) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;is first frame: ${copy.getMetric(FrameMetrics.FIRST_DRAW_FRAME) == 1L}\u0026#34;) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;measure layout: ${copy.getMetric(FrameMetrics.LAYOUT_MEASURE_DURATION) / 1000000}ms\u0026#34;) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;draw: ${copy.getMetric(FrameMetrics.DRAW_DURATION) / 1000000}ms\u0026#34;) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;total: ${copy.getMetric(FrameMetrics.TOTAL_DURATION) / 1000000}ms\u0026#34;) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;delay draw: ${copy.getMetric(FrameMetrics.INTENDED_VSYNC_TIMESTAMP) \u0026gt; copy.getMetric(FrameMetrics.VSYNC_TIMESTAMP)}ms\u0026#34;) Log.d(\u0026#34;FrameStat\u0026#34;, \u0026#34;=============\u0026#34;) }, handler)   D: is first frame: false D: measure layout: 0 ms D: draw: 4 ms D: total: 52 ms D: delay draw: false ms D: ============= D: is first frame: false D: measure layout: 1 ms D: draw: 0 ms D: total: 18 ms D: delay draw: false ms D: ============= 参考  https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html https://developer.android.com/reference/android/view/FrameMetrics  ","description":"在 Android 7.0, 增加了一个 Api 可以方便的统计一个 Window 的 View 树的绘制耗时","id":13,"section":"posts","tags":[""],"title":"使用 OnFrameMetricsAvailableListener 统计绘制耗时","uri":"https://jiyang.site/posts/%E4%BD%BF%E7%94%A8-onframemetricsavailablelistener-%E7%BB%9F%E8%AE%A1%E7%BB%98%E5%88%B6%E8%80%97%E6%97%B6/"},{"content":"问题背景： 有个动画在 onAnimatorEnd 回调中间接调用了 Animator#cancel。在 Android 8 没有问题，但是在 Android 5, Android 6 等版本出现了下面的递归调用。\njava.lang.StackOverflowError: stack size 8MB ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) ... at android.animation.AnimatorSet.cancel(AnimatorSet.java:340) 发现是 AnimatorSet 造成的问题，AnimatorSet 在 Android 8 和 Android 8 以下对 cancel 方法的实现有区别。\n   Android 8 及以上 Android 8 以下         回调了 onAnimationCancel 之后，不会再回调 onAnimatioinEnd 回调了 onAnimationCancel 之后，会再回调 onAnimatioinEnd    解决方法：  避免存在 onAnimationEnd 中会调用 cancel 的场景 在 onAnimationEnd 调用之后，移除对应的 listener  ","description":"有个动画在 onAnimatorEnd 回调中间接调用了 Animator#cancel。在 Android 8 没有问题，但是在 Android 5, Android 6 等版本造成了 StackOverflowError。","id":14,"section":"posts","tags":null,"title":"AnimatorSet Cancel 在 Android 8 和以下版的行为不一致坑","uri":"https://jiyang.site/posts/2020-04-16-animatorset-cancel-android8-%E5%92%8C%E4%BB%A5%E4%B8%8B%E7%89%88%E7%9A%84%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9D%91/"},{"content":"TextView 在布局方面提供了一些特别的属性来控制文本的布局。比如现在要显示一个句子 What is a good time for you?。 TextView 在发现一行布局不足以显示整个文本内容时，会进行自动的换行。\n那么 TextView 是如何知道或者说它是如何做到自动换行的呢? 这就要涉及下图所示的内容。\nLayout  官方介绍： android.text.Layout 是一个管理屏幕上文本布局的基类。在 TextView 内部，对于会编辑的文本(EditText)，会使用 DynamicLayout ，它会随着文本的更改而更新；对于不会更改的文本，会使用 StaticLayout 或 BroingLayout。\n getLineXXX 由于文本可能会被显示为多行，所以 Layout 提供了一系列获取每一行文本具体位置的方法。通过 getLineCount() 可以获取一个 Layout 包含了多少行文本，然后通过一系列 getLineXXX(int line) 方法可以获取每行的具体参数。\n   方法 作用     getLineTop 当前行文本区域的最顶部在屏幕y方向的位置   getLineBottom 当前行文本区域的最底部在屏幕y方向的位置, 会包含实际的行间距X(最后一行不会包含)   getLineBaseline 当前行文字的 baseline   getLineStart 绘制在当前行的第一个字符在所有字符中的索引   getLineEnd 绘制在当前行的最后一个字符在所有字符中的索引   getLineLeft 绘制在当前行的第一个字符在屏幕x方向的位置   getLineRight 绘制在当前行的最后一个字符在屏幕x方向的位置   getLineAscent 获取字体头部的额外高度，相对于 Bottom 的偏移   getLineDescent 获取字体底部相对于 Bottom 的偏移   getPrimaryHorizontal 获取文本中某个字符在水平方向上的x位置   \u0026hellip;     自己尝试画这些线：\n1 2 3 4 5 6 7  repeat(layout.lineCount) { drawLine(canvas, Color.RED, layout.getLineTop(it), \u0026#34;top\u0026#34;) drawLine(canvas, Color.YELLOW, layout.getLineAscent(it) + layout.getLineBottom(it), \u0026#34;ascent\u0026#34;) drawLine(canvas, Color.BLUE, layout.getLineBaseline(it), \u0026#34;baseline\u0026#34;) drawLine(canvas, Color.GREEN, layout.getLineBottom(it), \u0026#34;bottom\u0026#34;) drawLine(canvas, Color.BLACK, layout.getLineDescent(it) + layout.getLineBottom(it), \u0026#34;descent\u0026#34;) }      单行 多行          FontMetricsInt 与文本布局有关的还有一个数据类，FontMetricsInt，它封装了一系列字体相对与 baseline 的偏移量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public static class FontMetricsInt { /** * The maximum distance above the baseline for the tallest glyph in * the font at a given text size. */ public int top; /** * The recommended distance above the baseline for singled spaced text. */ public int ascent; /** * The recommended distance below the baseline for singled spaced text. */ public int descent; /** * The maximum distance below the baseline for the lowest glyph in * the font at a given text size. */ public int bottom; /** * The recommended additional space to add between lines of text. */ public int leading; }   实验 通过继承一个 TextView，可以方便的在布局和绘制相关方法中输出当前 TextView 使用的 Layout。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class MTv @JvmOverloads constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int = 0) : androidx.appcompat.widget.AppCompatTextView(context, attrs, defStyleAttr) { override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) { super.onMeasure(widthMeasureSpec, heightMeasureSpec) Log.d(TAG, \u0026#34;[onMeasure] $layout\u0026#34;) } override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) { super.onLayout(changed, left, top, right, bottom) Log.d(TAG, \u0026#34;[onLayout] $layout\u0026#34;) } override fun onDraw(canvas: Canvas) { Log.d(TAG, \u0026#34;[onDraw] $layout\u0026#34;) } }   然后做以下实验，让 TextView 分别显示长字符串和短字符串，以及使用 EditText。\n  当文本为 What is a good time for you? 时，输出：\nD/TAG: [onMeasure] android.text.StaticLayout@b677650 D/TAG: [onMeasure] android.text.StaticLayout@b677650 D/TAG: [onMeasure] android.text.StaticLayout@19ea28b D/TAG: [onMeasure] android.text.StaticLayout@19ea28b D/TAG: [onLayout] android.text.StaticLayout@19ea28b D/TAG: [onDraw] android.text.StaticLayout@19ea28b 会发现在整体的绘制过程中，创建了两个 StaticLayout 对象(b677650 和 19ea28b)。\n  当文本为较短的 a good time 时，输出：\nD/TAG: [onMeasure] android.text.BoringLayout@fb6605a D/TAG: [onMeasure] android.text.BoringLayout@fb6605a D/TAG: [onMeasure] android.text.BoringLayout@fb6605a D/TAG: [onMeasure] android.text.BoringLayout@fb6605a D/TAG: [onLayout] android.text.BoringLayout@fb6605a D/TAG: [onDraw] android.text.BoringLayout@fb6605a 因为没有涉及换行的操作，所以在整体的绘制过程中，创建了一个 BoringLayout 对象。\n  使用 EditText 时：\nD/TAG: [onMeasure] android.text.DynamicLayout@aa9b261 D/TAG: [onMeasure] android.text.DynamicLayout@aa9b261 D/TAG: [onMeasure] android.text.DynamicLayout@c1d4c99 D/TAG: [onMeasure] android.text.DynamicLayout@c1d4c99 D/TAG: [onLayout] android.text.DynamicLayout@c1d4c99 D/TAG: [onDraw] android.text.DynamicLayout@c1d4c99 会发现在整体的绘制过程中，创建了两个 DynamicLayout 对象(aa9b261 和 c1d4c99)\n  通过以上实验也部分验证了官方的说法，但是官方对 Layout 的介绍中没有提及 BoringLayout 和 StaticLayout 的区别。于是需要去他们各自的文档中去详细了解。\nBoringLayout  官方介绍：BoringLayout 是一种非常简单的 Layout 实现，用于从左到右的单行文本。你可能永远都不想自己做一个。 如果这样做，请确保首先调用 isBoring(CharSequence，TextPaint) 以确保文本符合条件。\n 所以使用 BoringLayout 的场景是：\n 单行文本 从左到右：TextView 有个 textDirection 属性，可以控制文本的显示方向。ltr 就表示从左到右  isBoring 上面提到过判断文本是否符合使用 BoringLayout 的条件，可以通过调用 isBoring 方法。\n1 2 3 4  //Returns null if not boring; the width, ascent, and descent if boring. public static Metrics isBoring(CharSequence text, TextPaint paint) { return isBoring(text, paint, TextDirectionHeuristics.FIRSTSTRONG_LTR, null); }   isBoring 方法会返回一个 BoringLayout.Metrics 对象，如果返回了 null，则说明目标文本不符合使用 BoringLayout 的条件。\n1 2 3 4 5 6 7 8  public static Metrics isBoring(CharSequence text, TextPaint paint, TextDirectionHeuristic textDir, Metrics metrics) { final int textLength = text.length(); //1  //2  //3  //4  return fm; }     判断文本中是否存在一些特殊字符\n1 2 3  if (hasAnyInterestingChars(text, textLength)) { return null; // There are some interesting characters. Not boring. }     判断是不是从右到左的方向\n1 2 3  if (textDir != null \u0026amp;\u0026amp; textDir.isRtl(text, 0, textLength)) { return null; // The heuristic considers the whole text RTL. Not boring. }     判断有没有存在 ParagraphStyle\n1 2 3 4 5 6 7  if (text instanceof Spanned) { Spanned sp = (Spanned) text; Object[] styles = sp.getSpans(0, textLength, ParagraphStyle.class); if (styles.length \u0026gt; 0) { return null; // There are some PargraphStyle spans. Not boring.  } }     以上条件都通过之后，就会创建布局相关的参数\n1 2 3 4 5 6 7 8 9 10 11 12 13  Metrics fm = metrics; if (fm == null) { fm = new Metrics(); } else { fm.reset(); } TextLine line = TextLine.obtain(); // 从 TextLine 对象池复用一个 TextLine // 将参数注入 TextLine line.set(paint, text, 0, textLength, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false,null); // 将经过测量之后的文本将要占用的宽赋值到 BoringLayout.Metrics#width fm.width = (int) Math.ceil(line.metrics(fm)); TextLine.recycle(line); // 对象回收进池子     TextLine  TextLine 代表一行样式文本，以视觉顺序进行度量，用于渲染。通俗说就是它负责对单行的文本进行宽度测量。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public void set(TextPaint paint, CharSequence text, int start, int limit, int dir, Directions directions, boolean hasTabs, TabStops tabStops) { mPaint = paint; mText = text; mStart = start; mLen = limit - start; mDir = dir; mDirections = directions; if (mDirections == null) { throw new IllegalArgumentException(\u0026#34;Directions cannot be null\u0026#34;); } mHasTabs = hasTabs; mSpanned = null; //... }   1 2 3 4  public float metrics(FontMetricsInt fmi) { //对于 BoringLayout, mLen 就是文本的长度  return measure(mLen, false, fmi); }   measure 最终会调用到 TextPaint#getRunAdvance 去获取文本占用的宽。对于 TextPaint 如何去测量文本占用的宽，这里不再深入。其对应的 native 实现在 Paint.cpp 中。\nStaticLayout StaticLayout 中主要做了测量文本需要多少行的工作。\n在测量过程中会对 StaticLayout 中的成员变量 mLineCount 进行 ++ 操作。\nDynamicLayout //TODO\nlineSpacingExtra  每行文本之间的间隔高度(不会应用到最后一行)\n 与其相关的还有一个属性是 lineSpacingMultiplier, 它代表希望应用到默认行高的倍数。\nTextView 某一行的行高计算：\n1 2 3  public int getLineHeight() { return FastMath.round(mTextPaint.getFontMetricsInt(null) * mSpacingMult + mSpacingAdd); }    mTextPaint.getFontMetricsInt(null) 就是默认行高，是一个根据具体字体和 textSize 属性计算出来的值 mSpacingAdd 就是 lineSpacingExtra  =\u0026gt; 实际行高 = 默认行高 * lineSpaceMultiplier + lineSpaceExtra\n实例  第一个数字是 lineSpaceExtra，第二个数字是 lineSpaceMultiplier。 红色是 TOP 线，黑色是 BOTTOM 线     default 0 0 100 0              100 3 100 1 100 0.5           运用 知道了 TextView 中 3 种 Layout 的存在之后，就能在需要的时候直接利用 Layout 提前测量文本的布局信息。\n  使用 BoringLayout\n1 2 3 4 5 6 7 8 9 10 11 12  fun measureTextByBoringLayout(width: Int, paint: TextPaint, text: String) { val layout = BoringLayout( text, paint, width, Layout.Alignment.ALIGN_NORMAL, 0f, 0f, BoringLayout.Metrics(), true ) }     使用 StaticLayout\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  fun measureTextByStaticLayout(width: Int, paint: TextPaint, text: String): ArrayList\u0026lt;Pair\u0026lt;Int, Int\u0026gt;\u0026gt; { val layout = if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M) { val builder = StaticLayout.Builder.obtain( text, 0, text.length, paint, width ) builder.build() } else { StaticLayout( text, 0, text.length, paint, width, Layout.Alignment.ALIGN_NORMAL, 0f, 0f, true ) } }     DynamicLayout\n1  //TODO     总结  TextView 的布局是代理给 Layout 的 3 个子类来完成的 利用 3 种 Layout，可以提前测量文本是否会存在换行的情况，也能提前拿到文本的最终布局信息 在涉及会分配大量对象的场景时，Android SDK 内广泛采用了对象池方法来避免创建大量对象。  TextLine, obtain recycle StaticLayot.Builder, obtain recycle DynamicLayout.Builder, obtain recycle    ","description":"业务上为了满足各种设计需求，会涉及对文字排版的要求，于是深入了解了 TextView 的布局细节。","id":15,"section":"posts","tags":null,"title":"TextView 的布局细节","uri":"https://jiyang.site/posts/2020-04-10-textview-%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86/"},{"content":"源码结构 1 2 3 4 5 6 7 8 9 10 11 12  ➜ linux-master tree -L 1 . ├── Kbuild ├── Kconfig ├── Makefile ├── arch ├── drivers ├── fs ├── include ├── init ├── kernel ├── mm   与内核初始化过程最相关的几个源码目录是：\n arch 包含许多子目录，每个子目录对应的一种处理器架构 init 包含start_kernel和其他与内核初始化相关的函数。内核将由与处理器体系对应的代码引导。然后处理器会执行 start_kernel 函数，该函数负责常见的内核初始化工作，这些工作是与处理器体系结构无关的，是内核的起点 kernel Linux内核的核心，几乎所有主要的内核子系统都在此实现 mm 与内存管理相关的方法和数据结构都定义在此文件夹中 drivers 包含所有外设的驱动实现，此文件夹是内核代码中最大的一个 fs 包含各种文件系统的实现  编译规则 Linux 也是使用 make 工具去编译内核源码，但是它的 Makefile 比较复杂。同时 Linux 还开发了基于 make 的 kbuild 编译系统。\nkbuild 概念   通过使用 kbuild 变量我们可以自定义编译过程。 kbuild 变量定义在 Kconfig 文件中，在 Kconfig 里可以定义变量和它的默认值。kbuild 变量有3种类型，string integer boolean。在 Kconfig 里可以定义变量之间的依赖。Kconfig 不是 make 的功能，它是被 Linux 自己实现解析的，在其中定义的变量会暴露给内核代码和 Makefile。变量的值在内核编译的配置阶段可以进行修改。\n比如，执行 make menuconfig 可以自定义编译变量的值，然后它们会被存储在 .config 文件中。\n  Linux 采用的是递归编译。每个子目录能够有自己的 Makefile 和 Kconfig 文件，子目录的编译配置会在编译时被递归的编译。大多数子目录的 Makefile 都比较简单，基本都是定义了哪些目标文件需要被编译。\n1  obj-$(SOME_CONFIG_VARIABLE) += some_file.o   上面的 Makefile 配置表示，如果 SOME_CONFIG_VARIABLE 变量被定义，则会将 some_file.c 编译并链接到内核。如果你想不使用 Kconfig 中的变量去做条件编译，那你可以直接使用 obj-y 去添加编译目标:\n1  obj-y += some_file.o     make 只会在 target 依赖的文件发生改变了才去重新构建 target，这种特性能够有效的利用构建缓存，减少构建耗时。但是如果是一个构建命令发生了更改，make 就不能识别到，会导致 make 在重新编译时实际不会执行命令，而是使用之前的编译产物。\n比如:\n1 2  %.o: %.c  gcc $(flag) -o $@ $\u0026lt;   flag 是一个配置变量，就有可能进行了修改，但是由于 make 判断到 %.c 文件没有发生修改，于是在重新编译时，实际不会去执行 gcc $(flag) -o...命令，而是直接使用上一次的 %.o 产物。这种情况就可能与我们的期望不一致了，所以 Linux 引入了if_changed 方法去增加了对命令是否修改的检测。上面的构建配置就可以修改为下面这样：\n1 2 3 4  cmd_compile = gcc $(flag) -o $@ $\u0026lt; %.o: %.c FORCE  $(call if_changed, compile)   修改之后的构建配置表示：为每一个.c文件执行if_changed函数(并把compile作为参数传递给它)去生成.c文件对应的.o文件。\nif_changed函数会检查compile变量(if_changed会自动添加一个cmd_前缀)的值与上一次编译相比是否发生了修改，如果发生了修改，就会执行compile引用的命令，进而进行重新编译。FORCE 则是一个特别的依赖文件，使用 FORCE 表示强制让 make 在构建时总是执行构建配置下的命令。\n于是使用 FORCE 和 if_changed，就能避免make忽略了命令的修改而不触发重新编译。\n  编译内核 内核的编译流程其实很复杂，但是有两个主要的问题只要弄清楚了，大致流程也就清晰了。\n 源文件如何精确地编译为目标文件？ 目标文件如何链接到OS映像？  为了便于理解，需要先了解第二个问题，目标文件的链接。\nlink stage   首先运行 make help 能看到内核定义的编译目标\n➜ linux-master make help ... Other generic targets: all\t- Build all targets marked with [*] * vmlinux\t- Build the bare kernel * modules\t- Build all modules modules_install - Install all modules to INSTALL_MOD_PATH (default: /) Execute \u0026quot;make\u0026quot; or \u0026quot;make all\u0026quot; to build all targets marked with [*] 可以看到 vmlinux 被 * 号标记了，所以它会默认的被编译。\n  vmlinux 编译目标的定义如下：\n1 2 3 4 5 6  cmd_link-vmlinux = \\  $(CONFIG_SHELL) $\u0026lt; $(LD) $(KBUILD_LDFLAGS) $(LDFLAGS_vmlinux) ; \\  $(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true) vmlinux: scripts/link-vmlinux.sh autoksyms_recursive $(vmlinux-deps) FORCE +$(call if_changed,link-vmlinux)   去除 if_changed 的干扰，替换 $\u0026lt; 和 $@ 之后，意思就是 vmlinux 的构建会执行 cmd_link_vmlinux 命令。 cmd_link_linux 对应的命令就是执行 scripts/link-vmlinux.sh，然后再执行处理器架构对应的 ARCH_POSTLINK。\n  当 link-vmlinux.sh 执行时，假设所有依赖的目标文件都已经编译出来了。这些依赖的目标文件位置存放在 $(KBUILD_VMLINUX_INIT)，$(KBUILD_VMLINUX_MAIN)，$(KBUILD_VMLINUX_LIBS) 中(来自 link-vmlinux.sh的注释)。\n  link-vmlinux.sh 脚本首先会将所有可用的目标文件一起编译为一个 thin archive(archive_builtih方法)。thin archive 是一个特别的目标文件，它包含了一系列目标文件的引用和目标文件们的符号表的合并。生成的 thin archive 作为 build-in.o 文件存放，并且 build-in.o 文件的格式能够被 linker 识别，所以它的使用方法和普通的目标文件一样。(thin archive 是 archive_build 函数利用 ar 工具生成的。）\n  接着会调用 modpost_link 方法。这个方法调用 linker 去生成 vmlinux.o 文件，这个文件会被用于执行 Section missmatch analysis，该分析由modpost 程序执行，并在 link-vmlinux.sh#L260 触发。\n  接着会生成内核符号表。它会包含所有函数和全局变量，以及它们在 vmlinux 二进制文件中的位置信息。主要的工作在 kallsyms 函数中完成。它首先使用 nm 从 vmlinux.o 中导出所有符号。然后使用 scripts/kallsyms 生成一个包含所有符号信息，且按照一种能被内核理解的特定格式编码的汇编文件(symbols.S)。接下来 symbols.S 被编译，并和原始的 vmlinux 文件链接在一起。来自内核符号表的信息用于在运行时生成 /proc/kallsyms 文件。\n  最终，vmlinux 文件生成，System.map 也会被生成。System.map 文件包含的信息和 /proc/kallsyms 一样，区别在与 System.map 是编译期生成的，用来在内核出现错误 Crash 时(linux kernel oops)，根据内存地址查找对应的符号信息。\n/proc/kallsyms 虚拟文件:\n kallsyms: Extract all kernel symbols for debugging\n ffffffff8140c3b0 T vsnprintf ffffffff8140c8e0 T vscnprintf ffffffff8140c910 T vsprintf ffffffff8140c930 T snprintf ffffffff8140c990 T scnprintf ffffffff8140ca20 T sprintf ffffffff8140ca90 T bstr_printf ffffffff8140ce50 T num_to_str ffffffff8140cef0 T clear_page ...   build stage   首先看下源码文件是如何被编译为目标文件的，在上面 link stage 部分，能看到 vmlinux 构建目标有一个依赖项是 $(vmlinux-deps) 变量。vmlinux-deps 变量定义在 Linux 源码根目录的 Makefile 中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  init-y := init/ drivers-y := drivers/ sound/ firmware/ net-y := net/ libs-y := lib/ core-y := usr/ core-y += kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/ init-y := $(patsubst %/, %/built-in.o, $(init-y)) core-y := $(patsubst %/, %/built-in.o, $(core-y)) drivers-y := $(patsubst %/, %/built-in.o, $(drivers-y)) net-y := $(patsubst %/, %/built-in.o, $(net-y)) export KBUILD_VMLINUX_INIT := $(head-y) $(init-y) export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y) export KBUILD_VMLINUX_LIBS := $(libs-y1) export KBUILD_LDS := arch/$(SRCARCH)/kernel/vmlinux.lds vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN) $(KBUILD_VMLINUX_LIBS)   开始定义的 init-y，drivers-y 等变量包含了所有需要编译到内核中的源码文件目录路径，然后经过 patsubst 函数处理后，这些变量会变为 init/build-in.o 这样的路径。\n接着，在 export 部分，不同目录下的 build-in.o 被分类到了 KBUILD_VMLINUX_*** 中。\n最后，所有 build-in.o 文件被聚合到 vmlinux-deps 变量中。这也解释了为什么 vmlinux 最终其实是依赖了所有子目录的 build-in.o 文件。\npatsubst 是 make 的函数，用来替换文本。比如 init-y 的初始值是 init/，那么经过 patsubst 处理之后：\n1  init-y := $(patsubst %/, %/built-in.o, $(init-y))   init-y 就会变为 init/build-in.o。\n  那么所有 build-in.o 文件是如何生成的呢？下面是相关的 Makefile：\n1 2 3 4 5 6 7 8  vmlinux-dirs := $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \\  $(core-y) $(core-m) $(drivers-y) $(drivers-m) \\  $(net-y) $(net-m) $(libs-y) $(libs-m) $(virt-y))) $(sort $(vmlinux-deps)): $(vmlinux-dirs) ; $(vmlinux-dirs): prepare scripts $(Q)$(MAKE) $(build)=$@   build 变量定义在 Kbuild.include 中:\n1 2 3 4 5  ### # Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj= # Usage: # $(Q)$(MAKE) $(build)=dir build := -f $(srctree)/scripts/Makefile.build obj   所以会调用 Makefile.build 脚本，并将各个 build-in.o 文件作为 obj 参数传递。\n  启动流程 要理解启动流程，需要先找到内核启动之后，执行的入口方法。这就涉及了内核镜像文件的文件布局。而决定一个 ELF 文件布局的程序是 ld ( Linker 链接器)，ld 又是根据 linker script 来执行链接操作的。\nLinker Script  Linker Script: 是被 ld 程序使用的配置脚本，它描述了输入文件应该按照怎样的布局储存到输出文件中。\n 下面是一段简单的 linker script:\nSECTIONS { . = 0x1000000; .text : { *(.text) } . = 0x8000000; .data : { *(.data) } .bss : { *(.bss) } } 这段脚本描述了在 ELF 文件中, text 域将会在 0x1000000内存地址开始存放, data 域在 0x8000000 开始存放，bss 域则紧跟 data 域之后。\nLinker Script 脚本中的每行代表一个 Output Section，每行开头的.号是 Location Counter，表示当前行的开始内存地址。Location Counter 会随着 Output Section 占用的内存增加。\n这里的第二行定义了 Section .text。冒号是必需的语法。在 Output Section 名称后面的花括号中，放置在此 Output Section 中的 Input Section 的名称。*是与任何文件名匹配的通配符。表达式 *（.text) 表示所有输入文件中的 .text input section 都会被放置在这个区域。\n详细可参考Simple Linker Script Example。\nLinux Linker Script Linux arm64 架构对应的 link script(vmlinux.lds.S) 是一个模版文件，该模板文件利用一些宏去替换其实际值，来构建实际的 linker script，这样就能让在不同体系的处理器之间读取和移植能够变得更加容易。\nSECTIONS { . = KIMAGE_VADDR + TEXT_OFFSET; .head.text : { _text = .; HEAD_TEXT } ... } 上面是 vmlinux.lds.S 的相关部分，内核代码的入口应该放在 .head.text Section 中。通过在内核代码中搜索能发现，在 include/linux/int.h中定义了一个宏 _HEAD，这个宏的值是 .section \u0026quot;.head.text\u0026quot;,\u0026quot;ax\u0026quot;。在 arm64/kernel/head.S 中会用到这个宏去定义 linker 规则。这个规则中用到了ENTRY去定义了程序执行的第一个指令。\nENTRY(stext)  ENTRY(symbol) 是 Linker Script 设置 entry point 的命令，symbol 就是需要执行的方法符号。\n 说明机器在通电启动之后，经过 bootloader 加载之后，执行的入口就是 stext。\nENTRY(stext) bl\tpreserve_boot_args bl\tel2_setup\t// Drop to EL1, w0=cpu_boot_mode adrp\tx23, __PHYS_OFFSET and\tx23, x23, MIN_KIMG_ALIGN - 1\t// KASLR offset, defaults to 0 bl\tset_cpu_boot_mode_flag bl\t__create_page_tables /* * The following calls CPU setup code, see arch/arm64/mm/proc.S for * details. * On return, the CPU will be ready for the MMU to be turned on and * the TCR will have been set. */ bl\t__cpu_setup\t// initialise processor b\t__primary_switch ENDPROC(stext) preserve_boot_args 方法用来存储 bootloader 传递给内核的参数。详细可参考preserve_boot_args。\nel2_setup 设置处理器的异常级别在 EL1。\n参考  https://github.com/torvalds/linux/blob/v4.14/Documentation/kbuild/makefiles.txt https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson01/linux/build-system.md https://sourceware.org/binutils/docs/ld/Simple-Example.html#Simple-Example  ","description":"通过理解 Linux 内核源码的目录结构、源码的编译规则进而理解内核的启动流程","id":16,"section":"posts","tags":["RPI_OS"],"title":"树莓派OS-#0x01-理解Linux内核的初始化流程","uri":"https://jiyang.site/posts/2020-03-28-%E5%AE%9E%E7%8E%B0rpi-os-b-%E7%90%86%E8%A7%A3linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"content":"Java 的增量编译 Gradle 在 5.0 增加了对 Java 增量编译的支持，通过增量编译，我们能够获得一些优点：\n 更少的编译耗时 更少的字节码修改  增量编译概览：\n Gradle 会重新编译受更改影响的所有类。 如果某个类发生了更改或者它依赖的类发生了更改，那么这个类也会被重新编译。无论类是否在同一个项目、另一个项目，还是外部库中定义了的其他类。 类的依赖关系由其字节码中的类型引用确定。 由于常量可以内联，因此对常量的任何更改都将导致 Gradle 重新编译所有源文件。因此，我们应尽量减少在源代码中使用常量，并在可能的情况下间接通过静态方法返回常量。 由于 Retention(SOURCE) 的注解不会编译进字节码中，因此对这种注解的更改将导致完全重新编译。 可以通过应用软件设计原则（如松耦合）来提高增量编译性能。例如，当 类A 依赖 接口B 时，则仅当 接口B 更改时，才会重新编译依赖类 类A，而仅当 接口B 的某个实现类更改时，不会重新编译 类A。 对类分析的结果会缓存在项目目录中，因此在 CI 服务器上 checkout 后的首次构建可能会变慢，所以在 CI 服务器上一般关闭增量编译。  已知问题:\n 如果编译过程中某个 task 造成了编译失败，下一次将会走完全编译 如果使用的是读取外部资源的注释处理器（例如配置文件），则需要将这些资源声明为编译任务的输入 如果资源文件发生修改，Gradle 会触发完全重编译  注解处理器增量编译 在 Gradle 编译时，会输出以下日志提醒你那些注解处理器没有支持增量编译:\nw: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: com.x.XXProcessor (NON_INCREMENTAL). 让 APT 支持增量编译 首先 Gradle 支持两种注解处理器的增量编译：isolating 和 aggregating，你需要搞清你的注解处理器属于哪种。然后在 META-INF/gradle/incremental.annotation.processors 文件中声明支持增量编译的注解处理器。\n比如我实现的一个支持增量编译的注解处理器的目录结构：\nx_processor/src/main/ ├── java │ └── site │ └── jiyang │ └── features_impl_processor └── resources └── META-INF ├── gradle │ └── incremental.annotation.processors └── services └── javax.annotation.processing.Processor incremental.annotation.processors 和 javax.annotation.processing.Processor 类似，一行一个注解处理器的声明:\n\u0026lt;注解处理器全限定名\u0026gt;,isolating 同时要在后面声明注解处理器的类型，使用 , 号做分隔。\n如果你的注解处理器要在运行时才能决定是否支持增量编译，那么可以声明为 dynamic，然后在注解处理器的 getSupportedOptions 方法中返回包含 org.gradle.annotation.processing.aggregating 的 Set\u0026lt;String\u0026gt;。\nincremental.annotation.processors:\n\u0026lt;注解处理器全限定名\u0026gt;,dynamic 1 2 3 4 5 6  override fun getSupportedAnnotationTypes(): MutableSet\u0026lt;String\u0026gt; { return mutableSetOf( \u0026#34;\u0026lt;你的目标注解类名\u0026gt;\u0026#34;, \u0026#34;org.gradle.annotation.processing.aggregating\u0026#34; ) }   两种增量编译注解处理器的共同限制:\n 只能通过 javax.annotation.processing.Filer 接口去生成文件。任何其他方式生成的文件因为不能正确的被清理，会造成编译失败 要支持增量编译的注解处理器不能依赖编译器特有的类。因为 Gradle 包装了 processing API，任何依赖了特定编译器的类的编译都会失败 如果使用了 Filer#createResource, Gradle 将重编译所有源文件。  isolating 最快的注解处理器类别，这类注解处理器独立地搜索每个带注解的元素，并为其生成文件或验证消息。\n限制\n 这类 APT 从 AST(Abstract Synax Tree) 获得信息，为带注解的类做出所有决策（生成代码，编译检查等）。这意味着我们甚至可以递归地分析类的超类，方法返回类型，注解等。但是这类 APT 不能基于 RoundEnvironment 中不存在的元素进行决策。如果你的 APT 需要基于其他不相关元素的组合做出决策，你应该将它声明为 aggregating。   重新编译源文件时，Gradle 将重新编译由源文件生成的所有文件。 删除源文件后，从其生成的文件也会被删除。\n aggregating aggregating 类型的 APT, 可以将多个源文件聚合到一个或多个输出文件中。\n限制\n 这类 APT 只能读取 CLASS 或 RUNTIME 类型的会保留在字节码中的注解 只能读到通过 -parameters 传递给编译器的参数的参数名   Gradle 将始终重新处理（但不会重新编译）APT 已处理的所有带注解的源文件。Gradle 将始终重新编译 APT 生成的任何文件。\n KAPT 支持 Kotlin Annotation Processor 也支持了增量编译，在项目的 gradle.propertice 中声明如下配置就能开启:\nkotlin.incremental=true Auto-Service 配置 一些 APT 会使用 auto-service 去生成 META-INF，所以 auto-service 在 1.0.0-rc6 也支持了增量编译\n参考  https://docs.gradle.org/current/userguide/java_plugin.html#sec:incremental_compile https://developer.android.com/studio/releases/gradle-plugin#3-5-0 https://kotlinlang.org/docs/reference/using-gradle.html#incremental-compilation https://github.com/google/auto/releases/tag/auto-service-1.0-rc6  ","description":"Gradle 5.0 支持了 Java Annotation Processor 的增量编译, 本文概述了增量编译的类型以及实现方式。","id":17,"section":"posts","tags":null,"title":"让 Annotation Processor 支持增量编译","uri":"https://jiyang.site/posts/2020-03-24-%E8%AE%A9annotation-processor-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/"},{"content":"花费接近一周的业余时间，基本实现了基于 TLS 1.2 的通信过程。在这期间遇到了许多问题，在此记录。\n实现的源码在: https://github.com/stefanJi/CNP/tree/master/TLSImpl\n字节序问题 由于我代码使用基于 JVM 的语言写的，所以所有数字类型都是带符号的，也就是 signed 类型。但是 TLS 层的数据都是 unsigned 类型的数字，这就导致数据从 Socket 流走到 JVM 层之后会由于 JVM 的语言没有 unsigned 类型出现数字越界的问题。\n比如一个 u_char, 值是 128，由于它大于了 127，走到 Java 这边之后，byte 的范围是 -128~127，就会被解析为 -128 。(128=11111111, bit位的首位在 signed 类型时表示符号位，首位为 1 表示这是一个负数，负数在 JVM 中又是以补码形式存储，所以 11111111 转化为原码之后就是 10000000 =\u0026gt; 128，加上负数就变成 -128 了)。\n由于上面的越界问题，所以从 Socket 中读数据都读出来存为 int，写数据时再转化为 u_char 写入。写入的过程就涉及字节序问题。\n就比如发送每条 TLS 消息时，你都需要在消息体外面包裹一层 TLSPlaintText 结构，这个结构中必须写入一个 16 位的数字(length) 去表示数据的大小。16 位的就包含了2个字节，在这2个字节的写入上，我就遇到了问题。\n我们知道 OutputStream 提供的 write 接口接收的数据单位是以字节为单位的，现在我想写入2个字节，这2个字节的写入顺序就要受字节序的影响了。\n开始我是这样写的：\n1 2 3 4  fun ByteBuffer.putU16(value: Int) = run { put((value and 0xFF).toByte()) put((value shl 8).toByte()) }   因为我们写入时是以32位 int 写的，所以先取低8位写入第一个字节，再把32位数左移8位，剩下的写入第二个字节。这样就把32位数中的16位写入了2个字节中。\n当我天真的以为这样就成功时，运行发现 Server 反馈我发送的数据有问题，通过 Wireshark 我发现，wireshark 解析出来的 length 尽然和我写入的length 值不相同。\n原因是上面的写入顺序是 litte-endian 的，而网络协议一般都是按照 big-endian 的。\n所以需要修改代码为：\n1 2 3 4  fun ByteBuffer.putU16(value: Int) = run { put((value shr 8).toByte()) put((value and 0xFF).toByte()) }   阅读 RFC 问题 RFC 作为计算机领域的协议标准，是非常值得仔细阅读的文档。但是由于自己英文水平不高，面对一些词句有时需要很久才能理解通顺。\n我的经验是一定要仔细浏览目录，目录涵盖了 RFC 文档的脉络，而且最好两个 tab 对照着来看，一个看大纲，一个看内容，防止看内容时忘记当前的上下文。\n理解 RFC 中对数据结构的描述 RFC 中对数据结构的描述也需要注意，其所描述的结构并就是代码对应的结构，也是因为 RFC 是语言无关的文档，所以 RFC 文档一般都会有一个 Presentation Language 章节来说明文档本身的表达规范，理解表达规范对理解 RFC 的主体章节及其重要。比如: https://tools.ietf.org/html/rfc5246#section-4 章节就是对应 TLS v1.2 RFC 中的表达语言规范。\n理解 IO 理解 InputStream read 的含义 Socket 本质是操作系统向上层应用提供的一套访问操作系统网络栈实现的接口。网络数据从网卡到达之后，先是存在操作系统的网络栈实现的缓存中。通过 Socket 获取的 Input Output Stream 实际是读操作系统内核中的缓存数据的读写。read 读取数据时，操作系统会先判断当前缓存中是否还有数据可被读取，如果有就返回给应用；如果没有，则等待网卡数据到来之后再返回给应用，这也是 read 是一个阻塞调用的本质。\n理解 BufferedInputStream 的特点 BufferedInputStream 是带缓存的流，带缓存的意思是 BufferedInputStream 中会维护数据读取的起始量和已读量，并维护一个字节数组。在从 BufferedInputStream 第一次取数据时，它会从原始流中一次性读取多个字节，填充到自己维护的字节数组中。后面再取数据，优先从自己维护的字节数据中获取，只有当获取的数据的长度超过了自己维护的字节数组时，才会触发第二次对原始流的读取。通过增加一层这样的缓存机制，就减少了对原始流的读写次数，也就减少了处理器在内核态和用户态的切换成本。\n加密套件的含义 当客户端和服务器在 TLS 握手的 Client Hello 和 Server Hello 会协商使用的加密套件。加密套件在传输的过程中来说，其实就是一个类型编码(Hex code)，每个编码将对应一种公众协商好的加密套件。\n   套件的元信息 套件包含的信息          而加密套件本身代表着在 TLS 通信中将使用到的算法：\n   算法 作用     Key Exchange 在交互密钥过程中使用的算法   Authentication 在验证身份时使用的算法   Encryption 加密数据使用的算法   Hash 散列算法    查看一个加密套件代表的信息可以到 https://ciphersuite.info/ 搜索。\n长长的名字代表啥 RFC 给常见的加密套件做了一套命名，它们的名字其实就代表着它们的算法组合。常见的加密套件：\nTLS_ECDH_ECDSA_WITH_NULL_SHA = { 0xC0, 0x01 } TLS_ECDH_ECDSA_WITH_RC4_128_SHA = { 0xC0, 0x02 } TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x03 } TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x04 } TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x05 } TLS_ECDHE_ECDSA_WITH_NULL_SHA = { 0xC0, 0x06 } TLS_ECDHE_ECDSA_WITH_RC4_128_SHA = { 0xC0, 0x07 } TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x08 } TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x09 } TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x0A } TLS_ECDH_RSA_WITH_NULL_SHA = { 0xC0, 0x0B } TLS_ECDH_RSA_WITH_RC4_128_SHA = { 0xC0, 0x0C } TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x0D } TLS_ECDH_RSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x0E } TLS_ECDH_RSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x0F } TLS_ECDHE_RSA_WITH_NULL_SHA = { 0xC0, 0x10 } TLS_ECDHE_RSA_WITH_RC4_128_SHA = { 0xC0, 0x11 } TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x12 } TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = { 0xC0, 0x13 } TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = { 0xC0, 0x14 } TLS_ECDH_anon_WITH_NULL_SHA = { 0xC0, 0x15 } TLS_ECDH_anon_WITH_RC4_128_SHA = { 0xC0, 0x16 } TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA = { 0xC0, 0x17 } TLS_ECDH_anon_WITH_AES_128_CBC_SHA = { 0xC0, 0x18 } TLS_ECDH_anon_WITH_AES_256_CBC_SHA = { 0xC0, 0x19 } 比如 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256(0xc02f)，通过名字我们能直观的知道，使用这个加密套件时将会用到的算法：\n Key Exchange 使用 ECDHE(Elliptic Curve Diffie-Hellman Ephemeral 短暂的椭圆曲线迪菲-赫尔曼公钥交换) 算法 Authentication 使用 RAS(非对称加密) 算法 Encryption 使用 AES_128_GCM(Advanced Encryption Standard with 128bit key in Galois/Counter mode 高级加密标准) 算法 Hash 使用 SHA256 散列算法  密钥交换的过程 密钥交换即 Key exchange message 的收发，premaster_secret 的生成和交换其实就是利用 Key Exchange 算法交换一些算法需要的参数的过程。\nKey Exchange 算法们 常见的 Key Exchange 算法有:\n ECDH_ECDSA   表示两种算法的结合。ECDH(椭圆曲线迪菲-赫尔曼公钥交换算法) 和 ECDSA(椭圆曲线数字签名算法)\n 在使用 ECDH_ECDSA 作为 Key Exchange 算法时, 服务器的证书必须包含一个 ECDH 可用的公钥，并且证书要用 ECDSA 签名。同时这种情况下，ServerKeyExchange 将不会被发送（因为服务器的证书已经包含了客户端所需的所有必要的参数信息）。\n客户端使用与服务器相同的曲线算法生成一个 ECDH 密钥对，密钥对中的公钥将作为和服务器通信的长期公共密钥。客户端需要在 ClientKeyExchange 消息中携带这个公共密钥。\n客户端和服务器都执行 ECDH 操作，并将生成的共享密钥作为后续阶段的 premaster_secret。\n ECDHE_ECDSA   ECDHE: 算法的计算方法和 ECDH 相同, 最后的 E 是 ephemeral 的缩写，表示临时的\n 在使用 ECDHE_ECDSA 作为 Key Exchange 算法时, 服务器的证书必须包含一个 ECDSA 可用的公钥，并且证书要用 ECDSA 签名。\n服务器必须在 ServerKeyExchange 消息中携带他的临时ECDH公钥和他生成这个公钥使用到的曲线算法类型。这些参数必须使用与服务器证书中的公钥相对应的私钥来进行 ECDSA 签名。\n客户端使用与服务器相同的曲线算法生成一个 ECDH 密钥对，密钥对中的公钥将作为和服务器通信的临时公共密钥。客户端需要在 ClientKeyExchange 消息中携带这个公共密钥。\n客户端和服务器都执行 ECDH 操作，并将生成的共享密钥作为后续阶段的 premaster_secret。\n ECDH_RSA  该密钥交换算法与 ECDH_ECDSA 相同，唯一的不同是：服务器的证书必须使用RSA签名而不是ECDSA。\n ECDHE_RSA  该密钥交换算法与 ECDHE_ECDSA 相同，不同之处在于服务器的证书必须包含使用 RSA 算法签名的公钥，并且 ServerKeyExchange 消息中的签名必须使用相应的 RSA 私钥进行计算。服务器证书必须使用 RSA 算法进行签名。\n ECDH_anon   anon 表示匿名\n 在 ECDH_anon 中，服务器的证书，证书请求，客户的证书，以及证书验证消息都不能发送。服务器必须在 ServerKeyExchange 消息中携带他的临时ECDH公钥和他生成这个公钥使用到的曲线算法类型。这些参数不能进行任何签名。\n客户端使用与服务器相同的曲线算法生成一个 ECDH 密钥对，密钥对中的公钥将作为和服务器通信的临时公共密钥。客户端需要在 ClientKeyExchange 消息中携带这个公共密钥。\n客户端和服务器都执行 ECDH 操作，并将生成的共享密钥作为后续阶段的 premaster_secret。\n请注意，尽管ECDH_ECDSA，ECDHE_ECDSA，ECDH_RSA和ECDHE_RSA密钥交换算法要求使用特定的签名方案对服务器的证书进行签名，但是此规范并未对证书链中其他地方使用的签名方案施加限制。所以证书链上的证书都需要使用根证书结构去验证其正确性。\n","description":"花费接近一周的业余时间，基本实现了基于 TLS 1.2 的通信过程。在这期间遇到了许多问题，在此记录。","id":18,"section":"posts","tags":["TLS"],"title":"当我尝试自己实现TLS时，我遇到了这些问题","uri":"https://jiyang.site/posts/2020-03-15-%E5%BD%93%E6%88%91%E5%B0%9D%E8%AF%95%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0tls%E6%97%B6%E6%88%91%E9%81%87%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"content":"详细分析在 zygote 的启动流程中, Android 的 Art/Dalvik VM 是如果启动的；以及 Android 为支持 JNI 调用做了哪些工作。\nInit Android 系统在启动之后, Linux 内核的启动进程 init 进程将会启动 system/bin/app_process 程序, 其对应的源码为 app_main.cpp, app_process 被执行时就会从 app_main.cpp 的 main 方法开始执行:\n1 2 3 4 5 6 7 8 9 10 11 12  int main(int argc, char* const argv[]) { // 创建 AppRuntime  AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); //...  // 通过 zygote 标志区分不同进程  if (zygote) { runtime.start(\u0026#34;com.android.internal.os.ZygoteInit\u0026#34;, args, zygote); } else if (className) { runtime.start(\u0026#34;com.android.internal.os.RuntimeInit\u0026#34;, args, zygote); } //... }   AppRuntime 继承自 AndroidRuntime:\n1 2 3 4 5 6 7  class AppRuntime : public AndroidRuntime { public: AppRuntime(char* argBlockStart, const size_t argBlockLength) : AndroidRuntime(argBlockStart, argBlockLength), mClass(NULL) { } }   AndroidRuntime 的构造函数:\n1 2 3 4 5 6 7 8 9  AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) : mExitWithoutCleanup(false), mArgBlockStart(argBlockStart), mArgBlockLength(argBlockLength) { SkGraphics::Init(); assert(gCurRuntime == NULL); // 整个系统中只能有一个 AndroidRuntime  gCurRuntime = this; }    初始化 Skia 图像库 将 AndroidRuntime 对象存在全局的 gCurRuntime 变量中  AndroidRuntime#start AndroidRuntime 的构造函数中没有涉及 JNI 的内容。于是接着看 runtime.start 的执行:\n1 2 3 4 5 6 7 8 9 10 11 12  void AndroidRuntime::start(const char* className, const Vector\u0026lt;String8\u0026gt;\u0026amp; options, bool zygote) { //...  JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(\u0026amp;mJavaVM, \u0026amp;env, zygote, primary_zygote) != 0) { return; } onVmCreated(env); //... }   libnativehelper/include/nativehelper/JniInvocation.h 中的 JniInvocation 是JNI调用的一个工具类。\nclass JniInvocation 的声明:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class JniInvocation final { public: JniInvocation() { // 构造时创建 JniInvocationImpl 实例  impl_ = JniInvocationCreate(); } bool Init(const char* library) { // 代理给 impl 执行  return JniInvocationInit(impl_, library) != 0; } static const char* GetLibrary(const char* library, char* buffer) { return JniInvocationGetLibrary(library, buffer); //const char* JniInvocationGetLibrary(const char* library, char* buffer) {  // return JniInvocationImpl::GetLibrary(library, buffer);  //}  // 所以也是代理给 impl 执行  } private: static const char* GetLibrary(const char* library, char* buffer, bool (*is_debuggable)(), int (*get_library_system_property)(char* buffer)); /* const char* JniInvocation::GetLibrary(const char* library, char* buffer, bool (*is_debuggable)(), int (*get_library_system_property)(char* buffer)) { return JniInvocationImpl::GetLibrary(library, buffer, is_debuggable, get_library_system_property); 所以也是代理给 impl 执行 } */ JniInvocationImpl* impl_; };   JniInvocation 的所有操作其实都是代理给 JniInvocationImpl 的。\nclass JniInvocationImpl 的声明:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  struct JniInvocationImpl final { public: JniInvocationImpl(); ~JniInvocationImpl(); bool Init(const char* library); static const char* GetLibrary(const char* library, char* buffer, bool (*is_debuggable)() = IsDebuggable, int (*get_library_system_property)(char* buffer) = GetLibrarySystemProperty); static JniInvocationImpl\u0026amp; GetJniInvocation(); jint JNI_GetDefaultJavaVMInitArgs(void* vmargs); jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args); jint JNI_GetCreatedJavaVMs(JavaVM** vms, jsize size, jsize* vm_count); private: bool FindSymbol(FUNC_POINTER* pointer, const char* symbol); // 全局的单例  static JniInvocationImpl* jni_invocation_; // 通过 dlopen 加载动态链接库返回的句柄  void* handle_; // 持有通过 dlopen 加载的库中的函数指针  // JNI_GetDefaultJavaVMInitArgs, JNI_CreateJavaVM, JNI_GetCreatedJavaVMs. 是 libart 中包含的方法  jint (*JNI_GetDefaultJavaVMInitArgs_)(void*); jint (*JNI_CreateJavaVM_)(JavaVM**, JNIEnv**, void*); jint (*JNI_GetCreatedJavaVMs_)(JavaVM**, jsize, jsize*); };   class JniInvocationImpl 的实现 libnativehelper/JniInvocation.cpp:\n构造函数：\n1 2 3 4 5 6 7 8 9 10 11  JniInvocationImpl* JniInvocationImpl::jni_invocation_ = NULL; // 参数列表赋值, 将几个字段赋值 NULL JniInvocationImpl::JniInvocationImpl() : handle_(NULL), JNI_GetDefaultJavaVMInitArgs_(NULL), JNI_CreateJavaVM_(NULL), JNI_GetCreatedJavaVMs_(NULL) { // 将当前实例存到全局的 jin_invocation_ 中  jni_invocation_ = this; }   通过 JniInvocationImpl 的构造函数能看出，JniInvocationImpl 的实例在一个进程中只会存在一个单例对象(jni_invocation_)。在 AndroidRuntime 初始化完成之后，之后系统中的所有 JNI 调用都会通过 jni_invocation_ 这个单例对象执行。当然因为应用进程都是 fork 自 zygote 进程，所以每个应用的进程都会拥有一个jin_invocation_ 对象。\nJni Invocation Init 过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  bool JniInvocationImpl::Init(const char* library) { char buffer[PROP_VALUE_MAX]; library = GetLibrary(library, buffer); handle_ = OpenLibrary(library); // 加载之后，判断是否能找到一些符号对应的函数指针，验证加载是否成功  if (!FindSymbol(reinterpret_cast\u0026lt;FUNC_POINTER*\u0026gt;(\u0026amp;JNI_GetDefaultJavaVMInitArgs_), \u0026#34;JNI_GetDefaultJavaVMInitArgs\u0026#34;)) { return false; } if (!FindSymbol(reinterpret_cast\u0026lt;FUNC_POINTER*\u0026gt;(\u0026amp;JNI_CreateJavaVM_), \u0026#34;JNI_CreateJavaVM\u0026#34;)) { return false; } if (!FindSymbol(reinterpret_cast\u0026lt;FUNC_POINTER*\u0026gt;(\u0026amp;JNI_GetCreatedJavaVMs_), \u0026#34;JNI_GetCreatedJavaVMs\u0026#34;)) { return false; } return true; }   GetLibarary 对传入的 library 参数做重新赋值，在非debug模式下会将library都设置为默认的 libart.so。\n1 2 3 4 5 6 7 8 9  static const char* kLibraryFallback = \u0026#34;libart.so\u0026#34;; const char* JniInvocationImpl::GetLibrary(const char* library, char* buffer, bool (*is_debuggable)()) { const char* default_library; if (!is_debuggable()) { library = kLibraryFallback; default_library = kLibraryFallback; }else {/*...*/} return library; }   OpenLibrary 1 2 3 4 5 6 7 8 9  void* OpenLibrary(const char* filename) { #ifdef _WIN32  //... #else  // Android 会走 dlopen 方式  const int kDlopenFlags = RTLD_NOW | RTLD_NODELETE; return dlopen(filename, kDlopenFlags); #endif }    The function dlopen() loads the dynamic shared object (shared library) file named by the null-terminated string filename and returns an opaque \u0026ldquo;handle\u0026rdquo; for the loaded object. This handle is employed with other functions in the dlopen API, such as dlsym(3),dladdr(3), dlinfo(3), and dlclose().\n dlopen 方法用于加载动态分享目标文件(.so .a)，并返回一个 handle。返回的 handle 可供其他 dlopen 库中的方法使用。\nJniInvocationImpl#OpenLibrary 调用 dlopen 时传入了两个 flag:\n RTLD_NOW: 需要在dlopen返回前，解析出所有未定义符号，如果解析不出来，在dlopen会返回NULL RTLD_NODELETE: 在dlclose()期间不卸载库，并且在以后使用dlopen()重新加载库时不初始化库中的静态变量。使用这个 flag 的目的在于: 确保libart.so在关闭时不会被取消映射。因为即使在 JNI_DeleteJavaVM 调用之后，某些线程仍可能尚未完成退出，如果卸载该库，则可能导致段错误  FindSymbol FindSymbol 将目标符号对应的函数指针存到 pointer 函数指针中。\n1 2 3 4 5 6 7 8 9 10  bool JniInvocationImpl::FindSymbol(FUNC_POINTER* pointer, const char* symbol) { *pointer = GetSymbol(handle_, symbol); if (*pointer == NULL) { ALOGE(\u0026#34;Failed to find symbol %s: %s\\n\u0026#34;, symbol, GetError().c_str()); CloseLibrary(handle_); handle_ = NULL; return false; } return true; }   GetSymbol 方法接收 dlopen 返回的 handle, 和要查找的目标符号。然后使用 dlsym 系统调用从dlopen加载的库中找出符号对应的内存地址。\n1 2 3 4 5 6 7  FUNC_POINTER GetSymbol(void* handle, const char* symbol) { #ifdef _WIN32  //... #else  return dlsym(handle, symbol); #endif }    returns the address of the code or data location specified by the null-terminated character string symbol. Which libraries and bundles are searched depends on the handle parameter.\nIf dlsym() is called with a handle, returned by dlopen() then only that image and any libraries it depends on are searched for symbol.\n dlsym 返回匹配目标符号的方法代码或数据在内存中的地址。如果调用 dlsym 传递的 handle 参数是由 dlopen 返回的，那么就只会在 dlopen 加载的库中寻找目标符号。\n启动 VM 加载了 libart.so 之后，zygote 进程中就拥有了 libart.so 中的所有方法，libart.so 中的 JNI_CreateJavaVM 等方法的函数指针也已经在 FindSymbol 时存到了 JniInvocationImpl 的对应字段中。\nAndroidRuntime::start 中调用startVm启动虚拟机:\n1 2 3  if (startVm(\u0026amp;mJavaVM, \u0026amp;env, zygote, primary_zygote) != 0) { return; }   最终会调用到\n1 2 3  jint JniInvocationImpl::JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) { return JNI_CreateJavaVM_(p_vm, p_env, vm_args); }   JniInvocatinImpl 的 JNI_CreateJavaVM_ 字段是一个函数指针，所以调用它就相当于调用它指向的函数: libart.so 中的 JNI_CreateJavaVM。\nart/runtime/jni/java_vm_ext.cc 中定义了 JNI_CreateJavaVM 方法，会被编译进 libart.so 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  extern \u0026#34;C\u0026#34; jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) { // 解析启动VM的参数  const JavaVMInitArgs* args = static_cast\u0026lt;JavaVMInitArgs*\u0026gt;(vm_args); RuntimeOptions options; for (int i = 0; i \u0026lt; args-\u0026gt;nOptions; ++i) { JavaVMOption* option = \u0026amp;args-\u0026gt;options[i]; //...  } // 创建 Runtime  if (!Runtime::Create(options, ignore_unrecognized)) { return JNI_ERR; } // 加载需要用到的 native 库  // 这些库的名字放在 /etc/public.libraries.txt 中  // 这些库的加载直接通过 dlopen 做的  // 最终加载的地方在 art/libnativeloader/library_namespaces.cpp LibraryNamespaces::Initialize  android::InitializeNativeLoader(); Runtime* runtime = Runtime::Current(); // 启动虚拟机  bool started = runtime-\u0026gt;Start(); if (!started) { delete Thread::Current()-\u0026gt;GetJniEnv(); delete runtime-\u0026gt;GetJavaVM(); LOG(WARNING) \u0026lt;\u0026lt; \u0026#34;CreateJavaVM failed\u0026#34;; return JNI_ERR; } *p_env = Thread::Current()-\u0026gt;GetJniEnv(); *p_vm = runtime-\u0026gt;GetJavaVM(); return JNI_OK; }   总结 init 进程会调用 app_process 程序，app_process 程序在执行时会 fork init 进程作为 zygote 进程, 然后会创建 AndroidRuntime, 接着 AndroidRuntime 会创建 JniInvocation, 并执行 JniInvocation#Init 方法去加载 libart.so, libart.so 包含了 VM 的创建方法(比如JNI_CreateJavaVM)等。所以在 JniInvocation Init 成功之后，就会执行 startVm 创建虚拟机。startVm 方法会调用到 libart.so 的 JNI_CreateJavaVM 方法。\ndlopen 实践 目录结构:\n. ├── lib.c └── main.c 实现 lib\n1 2 3 4 5  #include \u0026lt;stdio.h\u0026gt; void hello() { printf(\u0026#34;Hello!\\n\u0026#34;); }   编译为动态链接库 lib.so: gcc -shared lib.c -o lib.so\n动态加载 lib.so\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;dlfcn.h\u0026gt; int main() { const char* library = \u0026#34;lib.so\u0026#34;; const char* symbol = \u0026#34;hello\u0026#34;; void(*hello)(); void* handle = dlopen(library, RTLD_NOW); void* hello_func = dlsym(handle, symbol); hello = hello_func; hello(); return 0; }   编译然后执行 gcc main.c -o main \u0026amp;\u0026amp; ./main，会输出 Hello!\n既然dlopen这么强，那我们是不是可以在 Android 上随意去动态加载一个动态链接库。在 Android JNI 环境下试下从 SD 卡通过 dlopen 加载一个动态链接库。\n🤦‍♂️ 加载失败:\nE/linker: library \u0026ldquo;sdcard/jy.so\u0026rdquo; (\u0026quot;/storage/emulated/0/jy.so\u0026quot;) needed or dlopened by \u0026ldquo;/data/app/xx.playground-EX5qy0zftySydkkVUVoXdQ==/lib/x86_64/libjni_lib.so\u0026rdquo; is not accessible for the namespace: [name=\u0026ldquo;classloader-namespace\u0026rdquo;, ld_library_paths=\u0026quot;\u0026quot;, default_library_paths=\u0026quot;/data/app/xx.playground-EX5qy0zftySydkkVUVoXdQ==/lib/x86_64:/data/app/xx.playground-EX5qy0zftySydkkVUVoXdQ==/base.apk!/lib/x86_64\u0026quot;, permitted_paths=\u0026quot;/data:/mnt/expand:/data/data/xx.playground\u0026quot;]\n\npublic.libraries.txt 查看模拟器(因为只有模拟器直接就有root权限🤦‍♂️)的 etc/public.libraries.txt 能看到一般会加载哪些库。\ngeneric_x86_64:/etc $ cat public.libraries.txt libandroid.so libaaudio.so libc.so libcamera2ndk.so libdl.so libEGL.so libGLESv1_CM.so libGLESv2.so libGLESv3.so libicui18n.so libicuuc.so libjnigraphics.so liblog.so libmediandk.so libm.so libnativewindow.so libneuralnetworks.so libOpenMAXAL.so libOpenSLES.so libRS.so libstdc++.so libsync.so libvulkan.so libwebviewchromium_plat_support.so libz.so ","description":"详细分析在 zygote 的启动流程中, Android 的 Art/Dalvik VM 是如果启动的；以及 Android 为支持 JNI 调用做了哪些工作。","id":19,"section":"posts","tags":null,"title":"Android VM 的启动流程以及 JNI 的通信原理","uri":"https://jiyang.site/posts/2020-03-06-androidruntime%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"content":"Java 方法执行时的动态分派和静态分派是 Java 实现多态的本质\n背景 Java 的动态分派和静态分派也是 Java 方法的执行原理。 Java 源代码的编译之后，方法之间的调用是使用符号引用来表示的。当字节码被 JVM 加载之后，符号引用才会被替换为对应方法在方法区的真实内存地址。那么在替换之前，由于 Java 的方法重写、重载，就导致符号引用对应的方法可能是一个虚方法，那么方法的真实实现在运行时就可能有多个。\n所以在将符号引用替换为真实地址时，还需要做一件事情：那就是确定符号引用要替换的方法的版本。\n运行时方法帧 与 C,C++ 一样，JVM 在运行时也会维护一个运行栈，用于方法的调用和返回。当调用一个方法时，会为方法在栈上分配一块内存区域作为方法的帧。方法调用帧又分为下面几个区域：\n局部变量表\n存储方法参数和方法体中的局部变量，其容量在编译期就已确定。容量的最小单位是 variable slot(变量槽)。\n静态方法的局部变量数就是方法体中声明的变量数；实例方法的局部变量数会多一个，多出的一个就是我们平时在实例方法中访问的this。this 其实是编译器在编译时悄悄加到实例方法上的，而且是作为第一个参数。\n操作数栈\nJVM 的字节码指令执行机制是基于栈的，所以需要一个栈来存储字节码指令的操作数。\nAndroid 的 VM 是基于寄存器的，所以没有操作栈区域。\n Android VM 采用寄存器存储操作数有两个主要原因：1. 寄存器乃是 CPU 内部的高速内存, 读写寄存器是与 CPU 交互最快的方式。2. 智能手机多使用 ARM 架构的 CPU, ARM 架构的 CPU 有很多通用寄存器可使用。\n 动态链接\n方法体中调用其他方法时，会把将要调用的方法在常量池中的符号引用，转化为将要其在方法区内存中的开始地址信息，并储存到动态链接中。\n方法返回地址\n一个方法执行完毕之后，线程需要值得回到哪里继续执行，方法返回地址就是存储这个信息的。返回地址一般就是当前方法的调用者的程序计数器的值(PC寄存器)。\n 正常完成出口: 方法正常返回时，如果有返回值，返回值会被压入调用方法的操作数栈中 异常完成出口: 当方法发生了异常，且在异常表中没有找到匹配的异常处理流程时，方法将不会有返回值  方法调用 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）\n调用方法的指令 有以下字节码指令用于方法的调用:\n   指令 用途 说明     invokestatic 调用类的静态方法    invokespecfical 调用对象的构造函数和私有方法    invokevirtual 调用对象的 public/protected 的方法 可能通过继承复写的方法称做 virtual method: 表示要到运行时才能定位到真正的方法实现。通过符号引用确定虚方法直接引用的过程又叫做动态分派   invokeinterface 调用接口的方法 具体的实现类将在调用时确定   invokedynamic JDK1.7 为了让 JVM 支持动态类型语言引入的指令 让用户可以决定如何查找目标方法    符号引用到直接引用 由于 Java 的编译没有C C++ 编译过程中的链接阶段，所以 Class 文件中储存的只是符号引用，等到了在运行时才通过符号引用定位到方法区中方法代码在内存布局中的位置\u0026ndash;直接引用。\n符号引用到直接引用的替换又涉及两种方式。一种是解析，另一种是分派。解析发生在类加载的解析阶段，分派发生在编译或方法调用阶段。\n解析 在类加载的解析阶段会把满足「编译期可知，运行期不可变」的方法的符号引用替换为指向方法区的直接引用，不会延迟到运行时再去完成。\n满足编译期可知，运行期不可变的方法有：构造函数、私有方法、静态方法、final修饰的方法。不满足上述条件的方法的符号引用替换发生在方法调用期间。\n分派 Dispatch  多态的实现原理\n 变量类型 理解分派之前，需要先看两个类型概念。\n比如：Object obj = new String(\u0026quot;\u0026quot;);\n 静态类型  定义变量时，声明的类型。比如这里 obj 的静态类型就是 Object。静态类型在编译期的编译器就能知道。\n 实际类型  变量赋值时的实际类型。比如这里 obj 的实际类型就是 String。实际类型在编译期的编译器是不可知的。\n静态分派 根据变量的「静态类型(外观类型)」匹配调用方法的过程称为静态分派。发生的场景为方法重载。\n如下代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public class StaticDispatch { static abstract class Human { } static class Man extends Human { } static class Woman extends Human { } static class Child extends Human { } public void say(Human human) { System.out.println(\u0026#34;human\u0026#34;); } public void say(Man man) { System.out.println(\u0026#34;man\u0026#34;); } public void say(Woman woman) { System.out.println(\u0026#34;woman\u0026#34;); } public void say(Child child) { System.out.println(\u0026#34;child\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10  public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); Human child = new Child(); StaticDispatch dispatch = new StaticDispatch(); dispatch.say(man); dispatch.say(woman); dispatch.say(child); }   main 方法的执行结果:\nhuman human human 虽然 StaticDispatch 为每种 Human 的子类都重载了一个 say 方法，但是由于重载采用的是静态分派，是根据对象的静态类型做方法匹配的。所以结果全都匹配到了 public void say(Human human) 方法。main 方法编译之后的字节码:\npublic static main([Ljava/lang/String;)V NEW method_invoke/StaticDispatch$Man DUP INVOKESPECIAL method_invoke/StaticDispatch$Man.\u0026lt;init\u0026gt; ()V ASTORE 1 NEW method_invoke/StaticDispatch$Woman DUP INVOKESPECIAL method_invoke/StaticDispatch$Woman.\u0026lt;init\u0026gt; ()V ASTORE 2 NEW method_invoke/StaticDispatch$Child DUP INVOKESPECIAL method_invoke/StaticDispatch$Child.\u0026lt;init\u0026gt; ()V ASTORE 3 NEW method_invoke/StaticDispatch DUP INVOKESPECIAL method_invoke/StaticDispatch.\u0026lt;init\u0026gt; ()V ASTORE 4 // 下面为调用 say ALOAD 4 ALOAD 1 INVOKEVIRTUAL method_invoke/StaticDispatch.say (Lmethod_invoke/StaticDispatch$Human;)V ALOAD 4 ALOAD 2 INVOKEVIRTUAL method_invoke/StaticDispatch.say (Lmethod_invoke/StaticDispatch$Human;)V ALOAD 4 ALOAD 3 INVOKEVIRTUAL method_invoke/StaticDispatch.say (Lmethod_invoke/StaticDispatch$Human;)V RETURN 从字节码也能看到，编译器确实是按照静态分派选择了匹配静态类型的 StaticDispatch.say(LStaticDispatch$Human;)V 方法，而没有按照变量的实际类型去匹配重载的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class Overload { public static void out(char a) { System.out.println(\u0026#34;char \u0026#34; + a); } public static void out(int a) {System.out.println(\u0026#34;int \u0026#34; + a);} public static void out(long a) { System.out.println(\u0026#34;long \u0026#34; + a); } public static void out(float a) { System.out.println(\u0026#34;float \u0026#34; + a); } public static void out(double a) { System.out.println(\u0026#34;double \u0026#34; + a); } public static void out(Integer a) { System.out.println(\u0026#34;integer\u0026#34;); } public static void out(Character a) { System.out.println(\u0026#34;character\u0026#34;); } public static void out(Serializable a) { System.out.println(\u0026#34;serializable \u0026#34; + a); } public static void out(Comparable a) { System.out.println(\u0026#34;comparable \u0026#34; + a); } public static void out(Object a) { System.out.println(\u0026#34;object \u0026#34; + a); } public static void out(char... a) { System.out.println(\u0026#34;char ... \u0026#34; + Arrays.toString(a)); } public static void main(String[] args) { out(\u0026#39;c\u0026#39;); } }   这段代码也是一个静态分派的例子，编译器会选择参数类型做合适的函数去调用。可以注释掉所有 out 函数，留下 out(Serializable a)，你会发现程序也能成功编译和运行。如果留下Serializeable 和 Comparable 编译则会失败，提示对 out 的引用不明确。\n动态分派 根据变量的「实际类型」匹配调用方法的过程称为动态分派。发生的场景为方法重写。当调用一个可能被子类重写或继承的方法时，就会触发动态分派。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class DynamicDispatch { static class Human { public void say() { System.out.println(\u0026#34;human\u0026#34;); } } static class Man extends Human { @Override public void say() { System.out.println(\u0026#34;man\u0026#34;); } } static class Woman extends Human { @Override public void say() { System.out.println(\u0026#34;woman\u0026#34;); } } }   1 2 3 4 5 6 7 8  public static void main(String[] args) { Human human = new Human(); Human man = new Man(); Human woman = new Woman(); human.say(); man.say(); woman.say(); }   main 方法的执行结果:\nhuman man woman 意料之中，所谓的多态就是这样。那多态是如何实现的？\n其实多态的实现过程也就是确定被重写的方法版本的过程。main 方法编译之后的字节码:\npublic static main([Ljava/lang/String;)V NEW method_invoke/DynamicDispatch$Human DUP INVOKESPECIAL method_invoke/DynamicDispatch$Human.\u0026lt;init\u0026gt; ()V ASTORE 1 NEW method_invoke/DynamicDispatch$Man DUP INVOKESPECIAL method_invoke/DynamicDispatch$Man.\u0026lt;init\u0026gt; ()V ASTORE 2 NEW method_invoke/DynamicDispatch$Woman DUP INVOKESPECIAL method_invoke/DynamicDispatch$Woman.\u0026lt;init\u0026gt; ()V ASTORE 3 // 下面为多态调用 say ALOAD 1 INVOKEVIRTUAL method_invoke/DynamicDispatch$Human.say ()V ALOAD 2 INVOKEVIRTUAL method_invoke/DynamicDispatch$Human.say ()V ALOAD 3 INVOKEVIRTUAL method_invoke/DynamicDispatch$Human.say ()V RETURN 这里通过字节码感觉都会调用Hunman#say方法的，但是运行之后并不是。\n当 JVM 执行这两行字节码时:\nALOAD 1 // 由上面 ASTORE 1 可知, 局部变量表的第一个变量是 Woman 的对象 INVOKEVIRTUAL method_invoke/DynamicDispatch$Human.say ()V // INVOKEVIRTUAL 指令就会到 Woman 类中去寻找 say 方法 调用 say 方法时，JVM 会先去当前调用的对象的类中查找是否存在和目标方法的描述符、简单名称一样的方法，如果存在则将符号引用替换为找到的方法的直接引用，否则就向父类去查找，向父类的父类去查找\u0026hellip;, 直到最后找不到抛出NoSuchMethod异常。\nHuman 的 say 方法的签名:\n1 2  public void say(); descriptor: ()V   Woman 的 say 方法的签名:\n1 2  public void say(); descriptor: ()V   可见 Woman 类的 Human 类中的 say 方法的描述符和简单名称是一样的，所以 JVM 会优先匹配 Woman 类中的方法。这也是多态调用的底层逻辑。\n 阅读《深入理解Java虚拟机》记\n ","description":"Java 方法执行时的动态分派和静态分派是 Java 实现多态的本质","id":20,"section":"posts","tags":null,"title":"Java的动态分派和静态分派","uri":"https://jiyang.site/posts/2020-03-03-java%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE/"},{"content":"raspberry-pi-os 项目记录了从头实现一个适用于树莓派3B(处理器 ARMv8 架构)的操作系统的过程。这篇文章记录了我按照项目的 lesson01 学习的过程，另外再加上自己的修改。\n 内容参考自 https://github.com/s-matyukevich/raspberry-pi-os\n 这个简易系统运行起来将只会做一件事情: 支持通过串口通信。项目结构基本和 raspberry-pi-os lesson01相同，我额外增加了继电器控制部分。\n   继电器连接 UART连接           make make 工具依据 Makefile 定义的规则执行编译工作，Makefile 的格式如下：\ntargets : prerequisites recipe …  targets: 编译的产出文件名，使用空格分隔。target 文件会在 make 执行下面的 recipes 之后生成。 prerequisites: 依赖的文件, 使用空格分隔, 当 make 检测到某个 target 声明的 prerequisties 文件有改动时, 就将会忽略之前的缓存, 重新编译该目标 recipe: 执行的shell命令或脚本, 每一行在单独的 shell 进程中执行. 比如: 如果你在上句命令设置了临时的环境变量, 执行下一句命令时上一句的临时环境变量就不存在了 targets 和 prerequisties 支持使用通配符(%)。当使用通配符的时候，对于每个匹配了的 prerequisties，都会单独执行 receipes。在 receipe 中也可以使用 $\u0026lt; 和 $@ 去引用 prerequiste 和 target。  该项目的 Makefile:\n 一些参数的定义  1 2  ARMGNU ?= aarch64-linux-gnu # ARMGNU 交叉编译的前缀, 这里编译的目标平台是 arm64 架构的 x86 机器, 所以使用 aarch64-linux-gnu-gcc 作为编译器   1 2 3 4 5 6 7  COPS = -Wall -nostdlib -nostartfiles -ffreestanding -Iinclude -mgeneral-regs-only # 传递给C语言编译器的选项 # -Wall 显示所有警告 # -nostdlib 不使用C标准库，因为许多C标准库的调用实际都会与操作系统做交互。我们这里自己实现一个简易的操作系统，因此没有任何已有的操作系统调用供标准库使用。 # -nostartfiles 不使用标准的 startup 文件，Startup 文件的作用是设置一个栈指针，初始化静态数据，跳到主要的入口。这里我们将自己实现这些工作。 # -ffreestanding 告诉编译器不要去假设标准函数有通常的实现 # -Iinclude 在 include 目录里搜索头文件 # -mgeneral-regs-only 只使用通用寄存器   1 2 3  ASMOPS = -Iinclude # 传递给汇编编译器的选项 BUILD_DIR = build # 编译之后文件的存储位置 SRC_DIR = src # 源代码所在的目录    构建目标的定义  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  all : kernel8.img # 默认的构建目标，依赖 kernel8.img 构建目标  clean : # clean 目标的动作是删除所有编译产物  rm -rf $(BUILD_DIR) *.img # 编译 SRC_DIR 目录下所有 .c 文件到 BUILD_DIR # $\u0026lt; 和 $@ 是占位符，$\u0026lt; 指依赖的文件, $@ 指输出的文件 # -MMD 参数让编译器为每一个 object 文件创建一个依赖文件, 依赖文件包含所有编译目标源码时的依赖文件 $(BUILD_DIR)/%_c.o: $(SRC_DIR)/%.c mkdir -p $(@D) $(ARMGNU)-gcc $(COPS) -MMD -c $\u0026lt; -o $@ # 编译 SRC_DIR 目录下所有 .S 文件到 BUILD_DIR $(BUILD_DIR)/%_s.o: $(SRC_DIR)/%.S $(ARMGNU)-gcc $(ASMOPS) -MMD -c $\u0026lt; -o $@ # OBJ_FILES 数组将包含所有 c 源码和汇编源码编译之后的 object 文件 C_FILES = $(wildcard $(SRC_DIR)/*.c) ASM_FILES = $(wildcard $(SRC_DIR)/*.S) OBJ_FILES = $(C_FILES:$(SRC_DIR)/%.c=$(BUILD_DIR)/%_c.o) OBJ_FILES += $(ASM_FILES:$(SRC_DIR)/%.S=$(BUILD_DIR)/%_s.o) # 因为 make 因为依赖的文件的修改触发重新编译, 如果只是依赖关系改变了则不能触发重新编译 # 因此这里将 -MMD 生成的依赖文件也 include 进编译链，间接的让 make 能跟踪到依赖间的改变 DEP_FILES = $(OBJ_FILES:%.o=%.d) -include $(DEP_FILES) # 编译目标 kernel8.img 依赖 linker.ld 和 OBJ_FILES 文件 kernel8.img: $(SRC_DIR)/linker.ld $(OBJ_FILES) # 将 OBJ_FILES 数组链接为 kernel8.elf 文件, 使用 linker.ld 作为链接器的链接规则 $(ARMGNU)-ld -T $(SRC_DIR)/linker.ld -o $(BUILD_DIR)/kernel8.elf $(OBJ_FILES) # elf 文件面向的是操作系统去执行，因此这里需要将其转换为系统镜像文件，才能作为系统镜像去加载 # 文件名末尾的8，是树莓派硬件的约定，8表示该镜像文件用于 64 位架构的 ARMv8 处理器，kernel8.img 告诉硬件启动处理器到64位模式 $(ARMGNU)-objcopy $(BUILD_DIR)/kernel8.elf -O binary kernel8.img   linker 脚本 linker 脚本的目的是：定义如何将目标文件存放到 .elf 文件中的规则。linker script的详解.\nSECTIONS { .text.boot : { *(.text.boot) } .text : { *(.text) } .rodata : { *(.rodata) } .data : { *(.data) } . = ALIGN(0x8); bss_begin = .; .bss : { *(.bss*) } bss_end = .; } 启动后，Raspberry Pi 将 kernel8.img 加载到内存中，并从文件开头开始执行。这就是必须首先使用.text.boot部分的原因。操作系统启动代码将放入这个 section 中。 .text, .rodata, .data 分别包含: 内核代码编译之后的指令, 只读数据, 普通数据。 .bss section 包含应初始化为0的数据，也就是内存中剩余的空间。将镜像加载到内存后，必须将 .bss 部分的内存空间初始化为0, 所以使用bss_begin和bss_end符号来记录开始和结束地址，并保证以 8 的倍数对齐起始地址(ALIGN(0x8))。\n启动 kernel src/lesson01/src/boot.S 汇编代码文件包含了内核的启动代码:\n#include \u0026quot;mm.h\u0026quot; .section \u0026quot;.text.boot\u0026quot; // 表示该汇编代码中定义的内容都应该存放到 .text.boot section 中 // 设备启动之后, 每个处理器核心都会从 _start label 开始执行 .globl _start _start: mrs x0, mpidr_el1 // 从 mpidr_el1 寄存器获取当前运行的处理器ID，然后存到 x0 寄存器 and x0, x0,#0xFF // 将获得的处理器ID 与 0xFF 做与运算，从而得到低8位的值，然后存到 x0 寄存器 cbz x0, master // 因为树莓派有4个处理器核心, 但是现在的这个系统只希望在单处理器核心下运行, 所以将只让0号处理器执行master b proc_hang // 其他处理器执行简单的无限循环 # proc_hang 将调用自己, 也就意味着无限循环 proc_hang: b proc_hang master: adr x0, bss_begin adr x1, bss_end sub x1, x1, x0 // x1 减 x0 的结果存到 x1, 即得到需要初始化的内存空间大小 bl memzero // 调用 memzero 将 x0 到 x0+x1 的内存赋值0 mov sp, #LOW_MEMORY // LOW_MEMORY的值为 4MB, 意思是将内存中4MB的地址拷贝到表示运行栈的 sp 寄存器中. bl kernel_main // 调用 kernel_main 方法  汇编命令\n  mrs: 移动 PSR 寄存器的值到通用寄存器 and: 与操作 cbz: 如果是0，则跳到后面的 label 执行 b: 跳到 label 执行 adr: 在目标寄存器中为存储映射中定义的标签生成相对于寄存器的地址 sub: 做减法 bl: 执行跳转到 label 对应的链接 move: 拷贝值到寄存器  kernel_main 方法  我改变了项目里的 kernel_main 实现，增加了控制继电器开关的通断来体现系统的运行。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \u0026#34;switch.h\u0026#34;#include \u0026#34;utils.h\u0026#34;#include \u0026#34;mini_uart.h\u0026#34; void kernel_main(void) { switch_init(); uart_init(); uart_send_string(\u0026#34;Hello, world!\\r\\n\u0026#34;); while (1) { uart_send(uart_recv()); switch_on(); delay(99999); switch_off(); delay(99999); } }   以上就是这个系统内核所做的所有工作，系统启动之后开始向串口发送一个字符串数据，然后一直循环接收串口的输入并将输入返回给串口，同时控制一个继电器的通断。\n树莓派硬件  为了控制外部设备，还需要了解下树莓派的外设在底层是如何让工作的。\n 树莓派 3B、B+ 使用的主板是 BCM2837 ARM 主板。\nBCM2837 是一种简单的 SOC (System on a chip) 主板。在这种主板上访问外部设备都是通过内存映射寄存器实现。\nARM 上内存的物理地址从 0x00000000 开始。物理内存地址从0x3F000000到0x3FFFFFFF为外设保留。外设的总线地址设置为映射到从0x7E000000开始的外设总线地址范围。因此，假设一个外设在总线上的地址是0x7Ennnnnn，那么外设在物理内存上的地址将是0x3Fnnnnnn。\n一个设备寄存器就是一个32位的内存区域。每个设备寄存器中每一位的含义都在 BCM2837 ARM 主板外设文档中有描述。\n为了向一个 GPIO 针脚外设写入高低电压，会涉及 BCM 主板外设部分的两个概念。\n Alternate function 外设寄存器  Alternate function Alternate function 可以翻译为备用功能。每个GPIO pin(引脚)都可以承载多个功能。一共有6种备用功能可用，但并非每个引脚都具有那么多备用功能。如果只是将 pin 作为输入输出引脚，则用不到这些备用功能。\n外设寄存器 GPIO pin 和其他主板上的外设一样，也被设备寄存器来表示。GPIO pin 涉及的寄存器有多种。比如 GPFSELn 寄存器用来配置一个 pin 的功能。\n通俗点说就是，要使用一个 pin，需要先拿到它被映射到了内存的哪里，然后在向它对应的内存区域写入不同的位来使用不同的功能。\nBCM2837 主板一共有6个 GPFSLEn (GPFSEL0~GPFSEL5) 寄存器。每个寄存器占用 32 位内存空间，这 32 位内存空间每 3 位用来表示一个pin, 32 位就能够表示 10 个 pin。\n比如 GPFSEL0 寄存器能用来表示 0～9 号 GPIO pin。\n比如设置 GPFSEL0 的第 29-27 位(表示pin 19), 3位的不同组合表示的含义:\n继电器 GPIO 配置 那么现在我要使用3号引脚作为一个输出引脚，该做那些操作?\n 获取 pin3 所属的 GPFSEL 寄存器 设置 pin3 为 output 间隔输出高低电压  gnu(接地) 和 vcc(供电)引脚主板启动之后自己设置好的，所以不用额外设置。\n根据文档可知 GPFSELn 寄存器在总线上的地址从 0x7E200000 开始, 那么对应到物理内存上就是 0x3F200000, 所以定义 GPFSELn 宏为:\n1 2 3 4 5 6 7 8  #define PBASE 0x3F00000  #define GPFSEL0 (PBASE+0x00200000) #define GPFSEL1 (PBASE+0x00200004) #define GPFSEL2 (PBASE+0x00200008) #define GPFSEL3 (PBASE+0x0020000C) #define GPFSEL4 (PBASE+0x00200010) #define GPFSEL5 (PBASE+0x00200014)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026#34;utils.h\u0026#34;#include \u0026#34;peripherals/gpio.h\u0026#34; void switch_init(){ unsigned int selector; // 按文档可知 pin3 属于 GPFSEL0 寄存器  selector = get32(GPFSEL0); // pin3 的控制位是11～9位  selector \u0026amp;= ~(7\u0026lt;\u0026lt;9); // xxx -\u0026gt; 000 清空为0  selector |= (1\u0026lt;\u0026lt;9); // xxx -\u0026gt; 001 作为 output  put32(GPFSEL0, selector); } void switch_on(){ // pin3 clear  unsigned int output = get32(GPCLR0); output |= (1\u0026lt;\u0026lt;3); put32(GPCLR0, output); } void switch_off() { // pin3 set  unsigned int output = get32(GPSET0); output |= (1\u0026lt;\u0026lt;3); put32(GPSET0, output); }   UART 配置 UART串口通信\nUART 串口通信属于外设辅助，BCM 主板支持三种 Aux 通信, mini UART 和 2个 SPI master. 要使用这些外设辅助功能，也是通过修改寄存器的值，寄存器在总线上的位置和寄存器对应的功能如下:\n比如要让主板支持 Aux 通信。需要先修改 AUX_ENABLES 寄存器的值为 1.\n根据文档可知 AUX_ENABLES 寄存器在总线上的地址为 0x7E215004, 那么对应到物理内存上就是 0x3F2154004, 所以定义 AUX_ENABLES 宏为:\n1 2  #define PBASE 0x3F00000 #define AUX_ENABLES (PBASE+0x00215004)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void uart_init () { unsigned int selector; selector = get32(GPFSEL1); selector \u0026amp;= ~(7\u0026lt;\u0026lt;12); // 复位 gpio14  selector |= 2\u0026lt;\u0026lt;12; // gpio14 设置 alt5  selector \u0026amp;= ~(7\u0026lt;\u0026lt;15); // 复位 gpio15  selector |= 2\u0026lt;\u0026lt;15; // gpio 15 设置 alt5  put32(GPFSEL1,selector); put32(GPPUD,0); // 向总线发出一个 GPIO PULL DOWN 控制信号  delay(150); // 等待 150 个 CPU 周期  put32(GPPUDCLK0,(1\u0026lt;\u0026lt;14)|(1\u0026lt;\u0026lt;15)); // 让PULL DOWN 信号写入 14和15号 pin  delay(150); // 等待 150 个 CPU 周期  put32(GPPUDCLK0,0); // 移除拦截  put32(AUX_ENABLES,1); //打开 mini uart (this also enables access to it registers)  put32(AUX_MU_CNTL_REG,0); //关闭自动控制和接收和转发  put32(AUX_MU_IER_REG,0); //关闭关闭和转发拦截  put32(AUX_MU_LCR_REG,3); //设置数据格式为8位模式 \u0026lt;- 3 表示二进制的 11: the UART works in 8-bit mode  put32(AUX_MU_MCR_REG,0); //设置电路的状态总是为高电位  put32(AUX_MU_BAUD_REG,270); //设置调制速率为 115200  put32(AUX_MU_CNTL_REG,3); //最后, 开启发送和接收 }   上面每行代码的详细解释以及数据发送和接收的实现可以到initializing-the-mini-uart查看。\n启动树莓派 树莓派的启动流程:\n 设备通电 GPU 启动并读取 config.txt 配置文件 kernel8.img 被加载到内存并执行  为了能够运行我这个简易的系统，config.txt 文件应该变成下面这样:\nkernel_old=1 disable_commandline_tags=1  kernel_old=1 指定 kernel 镜像应该加载到内存地址0 disable_commandline_tags 告诉 GPU 不传递任何参数  测试 kernel   打包系统镜像\n使用 smatyukevich/raspberry-pi-os-builder 镜像进行编译行为, 该镜像已经配置了 GNU 的交叉编译环境\ndocker run --rm -v $(pwd):/app -w /app smatyukevich/raspberry-pi-os-builder make $1   将镜像拷到 SD 卡(Mac os 下)\n将编译出的系统镜像写入 sd 卡，然后弹出\ncp kernel8.img /Volumes/boot hdiutil eject /Volumes/boot   将 SD 卡装到树莓派上\n  将继电器连接到树莓派\n  启动树莓派\n  使用4个处理器核心 在上文，我们只使用了1个处理器核心，另外3个都在执行无意义的死循环。\n要让程序支持多个处理器核心运行，需要注意以下几个方面：\n 每个处理器核心的寄存器们是相互独立的 需要为每个处理器核心分配他们各自的内存区域，否则处理器之间如果交叉读写了彼此的内存，会导致意外的问题 某些只能执行一次的操作，需要做额外处理。防止多个处理器核心都执行了。  .globl _start _start: b master //每个核心通电之后都会执行 master master: bl get_core_id //获取核心编号 cbz x0, init_memory //编号为0的核心执行内存初始化工作 bl get_core_id //再次获取核心编号 bl init_stack //设置栈空间 bl get_core_id bl kernel_main //执行kernal_mail 获取处理器核心 从 mpidr_el1 寄存器中可以获取当前正在运行的处理器核心的编号\n.global get_core_id get_core_id: mrs x0, mpidr_el1 and x0, x0, #0xFF ret 内存初始化   将 bss_begin 和 bss_end 范围的内存赋值0\n.global init_memory init_memory: adr x0, bss_begin adr x1, bss_end sub x1, x1, x0 b memzero ret   为每个处理器核心分配 1KB 的栈空间\n.global init_stack init_stack: mov x1, #STACK_OFFSET //x1=STACK_OFFSET, STACK_OFFSET值为1KB mul x1, x1,x0 //x1=x1*x0, x0是调用方传递过来的处理器核心编号(0~3) add x1, x1,#LOW_MEMORY //x1=x1+LOW_MEMORY, LOW_MEMORY值为4MB mov sp, x1 //将当前处理器核心的sp(栈指针)寄存器移动到x1位置 ret   多核心运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  void kernel_main(unsigned int core_id) { if(core_id == 0) { // uart 外设只需要初始化一次, 所以只让核心0执行  uart_init(); } else { // 其他核心等待一段时间  delay(300000 * core_id); } uart_send_string(\u0026#34;Hello Word From #\u0026#34;); uart_send(core_id + \u0026#39;0\u0026#39;); uart_send_string(\u0026#34; Processor Core.\\r\\n\u0026#34;); if(core_id == 0) while (1) { // 只让核心0执行读取行为  uart_send(uart_recv()); } else while(1) {}; }   结果 Hello From RPI #0 Processor Core.\nHello From RPI #1 Processor Core.\nHello From RPI #2 Processor Core.\nHello From RPI #3 Processor Core.\n","description":"raspberry-pi-os 项目记录了从头实现一个适用与树莓派3B(处理器为ARMv8架构)的操作系统的过程。这篇文章记录了我按照项目的 lesson01 学习的过程，另外再加上自己的修改。","id":21,"section":"posts","tags":["RPI_OS"],"title":"树莓派OS-#0x00-自制系统镜像并控制处理器的运行","uri":"https://jiyang.site/posts/2020-03-01-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%B6%85%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"content":"在 Android 开发中，当项目增加一定规模之后，一般都会采用多模块的项目结构。当然也能采用插件化的开发模式，具体采用什么开发模式，开发者可以自行定夺。这里将介绍下我们项目中采用的模块化开发机制。本质是基于 gradle 的 Multi-Project 构建和 Java 的动态代理机制。\n// settings.gradle\n1  include \u0026#39;:app\u0026#39;, \u0026#39;:feature_a\u0026#39;, \u0026#39;:feature_b\u0026#39;, \u0026#39;:feature_c\u0026#39;   利用这套机制时：比如开发者开发 A 功能时，只会涉及 feature_a 模块中代码的修改，那么开发者就可以让 gradle 不编译其他模块中的代码（在 settings.gradle 中注释不需要的模块），从而能够减少本地开发时的编译耗时，也能够让某些代码只会在开发期间存在（比如为了方便测试单独提供的 admin 模块）。\n选择性编译 同时为了避免因为模块间彼此依赖，导致个别模块不编译的目标无法实现。于是要求各个模块之间不能直接依赖具体实现，只能依赖某个公共模块（比如 app 模块）提供的接口。\n具体实现是:\n在 app 模块中定义模块 feature_a 能够提供的功能，比如打开 feature_a 中的一个 Activity.\n1 2 3 4  public interface IFeatureA { @Nullable public Class\u0026lt;Activity\u0026gt; getActivityOfA(); }   然后在 feature_a 中实现这个接口:\n1 2 3 4 5  public class FeatureA implements IFeatureA { public Class\u0026lt;Activity\u0026gt; getActivityOfA() { return FeatureAActivity.class; } }   然后在 app 中注入 IFeatureA 接口的具体实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class FeatureRegister { private static IFeatureA featureA; @Nullable public static IFeatureA getFeatureA() { if (featureA == null) { try { // 这里使用反射能够在即使 feature_a 模块未加入编译之后也能够成功编译  featureA = (IFeatureA) Class.forName(\u0026#34;io.github.stefanji.feature_a.FeatureA\u0026#34;).newInstance(); } catch (ClassNotFoundException e) { // 如果 feature_a 未加入编译，则会触发异常  } } return featureA; } }   然后 feature_b 需要获取 feature_a 的 FeatureAActivity:\n1 2 3 4 5  IFeatureA featureA = FeatureRegister.getFeatureA(); Class\u0026lt;Activity\u0026gt; activityClass = null; if (featureA != null) { activityClass = featureA.getActivityOfA(); };   动态代理未加入编译的模块 在上面我们已经能够实现不编译某些模块，并且项目整体编译不会出现问题。但是每次访问其他模块提供的功能时，从 app 模块获取实现之后需要进行判空处理。不是太优雅。\n于是可以利用动态代理，如果目标模块没有被编译，那么就返回一个实现了目标模块功能接口的代理对象。\n修改 app 中代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  @NotNull public static IFeatureA getFeatureA() { if (featureA == null) { try { featureA = (IFeatureA) Class.forName(\u0026#34;io.github.stefanji.feature_a.FeatureA\u0026#34;).newInstance(); } catch (ClassNotFoundException e) { } // 如果 feature_a 模块未没编译，FeatureA 类将找不到，就动态生成一个 Proxy 类  if (featureA == null) { featureA = (IFeatureA) Proxy.newProxyInstance(FeatureRegister.class.getClassLoader(), new Class[]{IFeatureA.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Class returnType = method.getReturnType(); // 让原始类型返回零值  if (returnType == boolean.class) { return false; } if (returnType == int.class) { return 0; } if (returnType == float.class) { return 0f; } //...  // 让引用类型返回 null  return null; } }); } } return featureA; }   这样就不用做如下判空了:\n1 2 3  if (featureA != null) { activityClass = featureA.getActivityOfA(); };   自动化 每新增一个模块，我们就需要重复上面的步骤，在 FeatureRegister 中注册新的 Feature 接口。这种重复的操作，当然可以利用注解处理之或 gradle transform 之类的代码生成机制，让编译器去自动生成模板代码。\n","description":"介绍下我们项目目前采用的模块化开发机制。","id":22,"section":"posts","tags":null,"title":"一种 Android 项目的模块化开发机制","uri":"https://jiyang.site/posts/2020-02-05-%E4%B8%80%E7%A7%8D-android-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"content":"问题 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;, \u0026lsquo;4\u0026rsquo;, \u0026lsquo;5\u0026rsquo;, \u0026lsquo;6\u0026rsquo;, \u0026lsquo;7\u0026rsquo;, \u0026lsquo;8\u0026rsquo;, \u0026lsquo;9\u0026rsquo; 。每个拨轮可以自由旋转：例如把 \u0026lsquo;9\u0026rsquo; 变为 \u0026lsquo;0\u0026rsquo;，\u0026lsquo;0\u0026rsquo; 变为 \u0026lsquo;9\u0026rsquo; 。每次旋转都只能旋转一个拨轮的一位数字。\n锁的初始数字为 \u0026lsquo;0000\u0026rsquo; ，一个代表四个拨轮的数字的字符串。\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。\n分析 问题需要的答案为给出最小的旋转次数, 不难联想到与最短、最少相关的广度优先算法. 四个圆形拨轮组合在一起之后可以想象为一个抽奖时的数字转轮.\n4个位置上每次只有一个数能够进行 +1 或 -1 操作, 那么每个数经过变换之后就有2种结果, 4个数就有8种结果.\n实现 判断从 \u0026lsquo;0000\u0026rsquo; 到达目标数字经过的路径是否会经过死亡数字.每个拨轮的数能够+1(向前拨一下)和-1(向后拨一下) =\u0026gt; 每个数相邻的数就将有8种.每个数和相邻的数相连就会构成一个网状图. 利用 BFS 算法查找从 0000 到目标节点的最短路径.\n为了方便存储数字组合, 构建一个类 Node 来存储, 因为涉及数组的比较, 所以需要注意复写 equals 和 hashCode 方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Node { int[] value; public Node(int[] value) { this.value = value; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Node node = (Node) o; return Arrays.equals(value, node.value); } @Override public int hashCode() { return Arrays.hashCode(value); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  class Solution { public int openLock(String[] deadends, String target) { // 参数合理性检查  if (deadends == null || deadends.length \u0026lt; 1 || target == null) throw new NullPointerException(); // 如果目标就在死亡列表中，则直接返回 -1  for (String s : deadends) { if (target.equals(s)) { return -1; } } Set\u0026lt;Node\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); /* 记录访问过的数字 */ Queue\u0026lt;Node\u0026gt; integers = new ArrayDeque\u0026lt;\u0026gt;(); /* BFS 访问队列 */ Node targetNode = parse(target); /* 目标节点 */ // 解析死亡列表  Node[] deads = new Node[deadends.length]; for (int i=0; i\u0026lt;deadends.length; i++) { deads[i] = parse(deadends[i]); } int step = -1; // 添加根节点到访问队列  integers.add(new Node(new int[]{0, 0, 0, 0})); visited.add(integers.peek()); while (!integers.isEmpty()) { // 每一层遍历完后，步数+1  step++; int size = integers.size(); for (int i = 0; i \u0026lt; size; i++) { Node num = integers.remove(); if (num.equals(targetNode)) { return step; } // 是否属于死亡列表  boolean goon = true; for (Node d : deads) { if (d.equals(num)) { goon = false; break; } } if (goon) { // 获取邻居  Node[] neibors = getNeibor(num); for (Node n : neibors) { boolean contain = visited.contains(n); if (!contain) { integers.add(n); visited.add(n); } } } } } return -1; } private Node[] getNeibor(Node target) { Node[] nodes = new Node[8]; for (int i = 0, j = 0; i \u0026lt; 4; i++) { int[] values = Arrays.copyOf(target.value, 4); int num = values[i]; //+1  int add = num + 1; add = add == 10 ? 0 : add; values[i] = add; nodes[j++] = new Node(Arrays.copyOf(values, 4)); //-1  int dec = num - 1; dec = dec == -1 ? 9 : dec; values[i] = dec; nodes[j++] = new Node(Arrays.copyOf(values, 4)); } return nodes; } private Node parse(String str) { String[] ss = str.split(\u0026#34;\u0026#34;); int[] num = new int[4]; for (int i = 0; i \u0026lt; 4; i++) { num[i] = Integer.valueOf(ss[i]); } return new Node(num); } }   ","description":"752. 打开转盘锁 https://leetcode-cn.com/problems/open-the-lock","id":23,"section":"posts","tags":["BFS"],"title":"打开转盘锁","uri":"https://jiyang.site/posts/2020-01-30-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"},{"content":"按照JVM 字节码的存储格式 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html 规范，实现了一段程序解析字节码结构。\n结果输出 ========== Start Parse========= == Magic Number ====================================== MagicNumber{b1=CA, b2=FE, b3=BA, b4=BE} == Version ====================================== Version{minorVersion=0, majorVersion=52} == Constant Pool ====================================== ConstantPool{poolCount=214, constantsSize=2376, mConstantItems= #1 MethodRef{classInfoIndex=65, nameAndTypeIndex=130} #2 String{index=131} ... #213 Utf8{attributeLength=20, value='()Ljava/lang/String;'} } == Access Flags ====================================== AccessFlags: public,final,super, bytecode.AccessFlags@27bc2616 == This class ====================================== ClassIndex{classInfoIndex=49 -\u0026gt; 171 -\u0026gt; bytecode/BytecodeParser} == Super class ====================================== ClassIndex{classInfoIndex=65 -\u0026gt; 185 -\u0026gt; java/lang/Object} == Interfaces ====================================== Interface count: 0 Interface Indexes: [] == Fields ====================================== FieldOrMethod{count=2, name='Fields', mEntities=[Entity{accessFlag=[Public,Static,], nameIndex=66, name=constantItemHashMap, descriptorIndex=67, attributesCount=1, mAttributeInfos=[AttributeInfo{nameIndex=68, attributeLength=2, mInfo=Signature{signatureIndex=69 -\u0026gt; Ljava/util/HashMap\u0026lt;Ljava/lang/Integer;Lbytecode/ConstantItem;\u0026gt;;}}]}, Entity{accessFlag=[Private,Static,Final,], nameIndex=70, name=path, descriptorIndex=71, attributesCount=1, mAttributeInfos=[AttributeInfo{nameIndex=72, attributeLength=2, mInfo=ConstantValue{constantValueIndex=4}}]}]} == Methods ====================================== FieldOrMethod{count=4, name='Methods', mEntities=[Entity{accessFlag=[Public,], nameIndex=73,... == This class attribute_info ====================================== [AttributeInfo{nameIndex=128, attributeLength=2, mInfo=SourceFile{sourceFileIndex=129 -\u0026gt; BytecodeParser.java}}] 实现 整体流程 ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } 按照字节码的储存顺序依次解析每一块内容。所有解析过程都共用一个 byte[] 数组，每个具体的解析过程，通过控制 offset 实现解析不同部分的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  public final class BytecodeParser { // 用来在常量池解析完之后，存在全局方便后面使用  public static HashMap\u0026lt;Integer, ConstantItem\u0026gt; constantItemHashMap; private void parse(final byte[] bytes) { printSectionDivider(\u0026#34;Magic Number\u0026#34;); Section magicNumber = new MagicNumber(0, bytes); magicNumber.parse(); System.out.println(magicNumber); printSectionDivider(\u0026#34;Version\u0026#34;); Section version = new Version(magicNumber.end(), bytes); version.parse(); System.out.println(version); printSectionDivider(\u0026#34;Constant Pool\u0026#34;); ConstantPool constantPool = new ConstantPool(version.end(), bytes); constantPool.parse(); System.out.println(constantPool); constantItemHashMap = constantPool.getConstantItems(); printSectionDivider(\u0026#34;Access Flags\u0026#34;); Section accessFlags = new AccessFlags(constantPool.end(), bytes); accessFlags.parse(); System.out.println(accessFlags); printSectionDivider(\u0026#34;This class\u0026#34;); Section thisClass = new ClassIndex(accessFlags.end(), bytes); thisClass.parse(); System.out.println(thisClass); printSectionDivider(\u0026#34;Super class\u0026#34;); Section superClass = new ClassIndex(thisClass.end(), bytes); superClass.parse(); System.out.println(superClass); printSectionDivider(\u0026#34;Interfaces\u0026#34;); Interfaces interfaces = new Interfaces(superClass.end(), bytes); interfaces.parse(); System.out.println(interfaces); printSectionDivider(\u0026#34;Fields\u0026#34;); FieldOrMethod fields = new FieldOrMethod(\u0026#34;Fields\u0026#34;, interfaces.end(), bytes); fields.parse(); System.out.println(fields); printSectionDivider(\u0026#34;Methods\u0026#34;); FieldOrMethod methods = new FieldOrMethod(\u0026#34;Methods\u0026#34;, fields.end(), bytes); methods.parse(); System.out.println(methods); printSectionDivider(\u0026#34;This class attribute_info\u0026#34;); int offset = methods.end(); int attributeCount = Utils.read2Number(bytes, offset); offset += 2; AttributeInfo[] attributeInfos = new AttributeInfo[attributeCount]; for (int i = 0; i \u0026lt; attributeCount; i++) { attributeInfos[i] = new AttributeInfo(); attributeInfos[i].parse(bytes, offset); offset += attributeInfos[i].size(); } System.out.println(Arrays.toString(attributeInfos)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public static void main(String[] args) { if (args.length \u0026lt; 1) { throw new IllegalArgumentException(\u0026#34;Must pass class file path.\u0026#34;); } String path = args[0]; System.out.println(\u0026#34;========== Start Parse=========\u0026#34;); try { FileInputStream fis = new FileInputStream(new File(path)); int count = fis.available(); byte[] buff = new byte[count]; int read = fis.read(buff); if (read != count) { return; } new BytecodeParser().parse(buff); } catch (IOException e) { e.printStackTrace(); } } private static void printSectionDivider(String name) { System.out.println(\u0026#34;== \u0026#34; + name + \u0026#34; ======================================\u0026#34;); }   提取了一些抽象 方便后面实现时生成统一的方法\n1 2 3  interface Parsable { public void parse(byte[] bytes, int offset); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  abstract class Section { final int start; //记录每一块结构的开始位置  final byte[] bytes; // 所有人共用的数据  public Section(int start, byte[] bytes) { this.start = start; this.bytes = bytes; } public final int start() { return start; } public final int end() { return start + size(); } abstract int size(); //每一块结构需要返回自己占用了多少字节  abstract public void parse(); }   解析魔数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  class MagicNumber extends Section { public MagicNumber(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return 4; } private int b1, b2, b3, b4;//u1  @Override public void parse() { b1 = Utils.readUnsignedByte(bytes, start); b2 = Utils.readUnsignedByte(bytes, start + 1); b3 = Utils.readUnsignedByte(bytes, start + 2); b4 = Utils.readUnsignedByte(bytes, start + 3); } @Override public String toString() { return \u0026#34;MagicNumber{\u0026#34; + \u0026#34;b1=\u0026#34; + Integer.toHexString(b1).toUpperCase() + \u0026#34;, b2=\u0026#34; + Integer.toHexString(b2).toUpperCase() + \u0026#34;, b3=\u0026#34; + Integer.toHexString(b3).toUpperCase() + \u0026#34;, b4=\u0026#34; + Integer.toHexString(b4).toUpperCase() + \u0026#39;}\u0026#39;; } }   解析版本号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Version extends Section { public Version(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return 4; } private int minorVersion, majorVersion; //u2  @Override public void parse() { minorVersion = Utils.read2Number(bytes, start); majorVersion = Utils.read2Number(bytes, start + 2); } @Override public String toString() { return \u0026#34;Version{\u0026#34; + \u0026#34;minorVersion=\u0026#34; + minorVersion + \u0026#34;, majorVersion=\u0026#34; + majorVersion + \u0026#39;}\u0026#39;; } }   解析常量池 常量池这里有一点要注意：代表常量池有多少常量的 poolCount，是包括了 poolCount 它本身的。也就是真正的常量池的常量其实是 poolCount -1 个。\n每个常量项都有一个 u1 的 tag 表示其类型。解析时需要先解析 tag, 然后根据 tag 做对应类型的解析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  class ConstantPool extends Section { int poolCount; //u2  private int constantsSize; private HashMap\u0026lt;Integer, ConstantItem\u0026gt; mConstantItems = new HashMap\u0026lt;\u0026gt;(); public HashMap\u0026lt;Integer, ConstantItem\u0026gt; getConstantItems() { return mConstantItems; } public ConstantPool(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return 2/*u2 的常量池计数占用*/ + constantsSize; } @Override public void parse() { poolCount = Utils.read2Number(bytes, start); // 遍历常量表的每一项常量  int offset = 2; for (int i = 1; i \u0026lt;= poolCount - 1; i++) { int tag = Utils.readUnsignedByte(bytes, start + offset); // 根据 tag 找到匹配的常量  ConstantItem item = ConstantItem.getConstantItemTags(tag); if (item == null) { System.err.println(\u0026#34;Not found ConstantItem for \u0026#34; + tag); return; } item.parse(bytes, start + offset); offset += item.size(); constantsSize += item.size(); mConstantItems.put(i, item); } } @Override public String toString() { StringBuilder sb = new StringBuilder(); for (int i = 1; i \u0026lt;= poolCount - 1; i++) { sb.append(\u0026#34; #\u0026#34;).append(i).append(\u0026#34; \u0026#34;).append(mConstantItems.get(i)).append(\u0026#34;\\n\u0026#34;); } return \u0026#34;ConstantPool{\u0026#34; + \u0026#34;poolCount=\u0026#34; + poolCount + \u0026#34;, constantsSize=\u0026#34; + constantsSize + \u0026#34;, mConstantItems=\\n\u0026#34; + sb.toString() + \u0026#39;}\u0026#39;; } }   每个常量项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /** * 常量项 * 每个常量项都有 u1 的 tag, 表示其类型 * \u0026lt;pre\u0026gt; * cp_info { * u1 tag; * u1 info[]; * } * \u0026lt;/pre\u0026gt; */ abstract class ConstantItem implements Parsable { final int tag; ConstantItem(int tag) { this.tag = tag; } abstract protected int contentSize(); int size() { return 1/*u1的tag*/ + contentSize(); } @Nullable static ConstantItem getConstantItemTags(int tag) { switch (tag) { case 1: return new UTF8(); case 3: return new INTEGER(); case 4: return new FLOAT(); case 5: return new LONG(); case 6: return new DOUBLE(); case 7: return new CLASS(); case 8: return new STRING(); case 9: return new FIELD_REF(); case 10: return new METHOD_REF(); case 11: return new Interface_Method_Ref(); case 12: return new NAME_AND_TYPE(); case 15: return new Method_Handle(); case 16: return new Method_Type(); case 18: return new Invoke_Dynamic(); default: return null; } } }   CONSTANT_Utf8 所有的字面量都储存在 UTF8 常量中。value 存储着以 UTF-8 编码的字符串的原始字节数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //region Constants  class UTF8 extends ConstantItem { private int length; public String value; UTF8() { super(1); } @Override protected int contentSize() { return length /* 字符串占用的字节数 */ + 2 /* u2 的字符串长度 attributeLength*/; } @Override public void parse(byte[] bytes, int start) { length = Utils.read2Number(bytes, start + 1); value = new String(bytes, start + 3, length); } @Override public String toString() { return \u0026#34;Utf8{\u0026#34; + \u0026#34;attributeLength=\u0026#34; + length + \u0026#34;, value=\u0026#39;\u0026#34; + value + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   CONSTANT_Integer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class INTEGER extends ConstantItem { int value; protected INTEGER() { super(3); } @Override protected int contentSize() { return 4 /*u4 值*/; } @Override public void parse(byte[] bytes, int start) { value = Utils.read4Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;Integer{\u0026#34; + \u0026#34;value=\u0026#34; + value + \u0026#39;}\u0026#39;; } }   CONSTANT_Float 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class FLOAT extends ConstantItem { float value; FLOAT() { super(4); } @Override protected int contentSize() { return 4 /* 同 INTEGER 的注释 */; } @Override public void parse(byte[] bytes, int start) { value = Utils.read4Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;Float{\u0026#34; + \u0026#34;value=\u0026#34; + value + \u0026#39;}\u0026#39;; } }   CONSTANT_Long 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class LONG extends ConstantItem { long value; LONG() { super(5); } @Override protected int contentSize() { return 8 /* u8 值*/; } @Override public void parse(byte[] bytes, int start) { value = Utils.read8Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;Long{\u0026#34; + \u0026#34;value=\u0026#34; + value + \u0026#39;}\u0026#39;; } }   CONSTANT_Double 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class DOUBLE extends ConstantItem { DOUBLE() { super(6); } double value; @Override protected int contentSize() { return 8 /*u8 值*/; } @Override public void parse(byte[] bytes, int start) { value = Utils.read8Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;Double{\u0026#34; + \u0026#34;value=\u0026#34; + value + \u0026#39;}\u0026#39;; } }   CONSTANT_Class 存储指向类的全限定名在常量池中的索引 index\nclass CLASS extends ConstantItem { CLASS() { super(7); } int index; @Override protected int contentSize() { return 2 /*u2 常量池索引*/; } @Override public void parse(byte[] bytes, int start) { index = Utils.read2Number(bytes, start + 1); } @Override public String toString() { return \u0026quot;Class{\u0026quot; + \u0026quot;index=\u0026quot; + index + '}'; } } CONSTANT_String 存储指向 Constant_UTF8 的索引 index\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class STRING extends ConstantItem { STRING() { super(8); } int index; //u2  @Override protected int contentSize() { return 2/*u2 常量池索引*/; } @Override public void parse(byte[] bytes, int start) { index = Utils.read2Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;String{\u0026#34; + \u0026#34;index=\u0026#34; + index + \u0026#39;}\u0026#39;; } }   CONSTANT_Fieldref  classInfoIndex 声明字段的类的信息，指向 CONSTANT_Class nameAndTypeIndex 字段的信息，指向 CONSTANT_NameAndType 类型的索引  class FIELD_REF extends ConstantItem { int classInfoIndex, nameAndTypeIndex; FIELD_REF() { super(9); } @Override protected int contentSize() { return 2/*u2 类信息常量池索引*/ + 2/*u2 名字和类型常量池索引*/; } @Override public void parse(byte[] bytes, int start) { classInfoIndex = Utils.read2Number(bytes, start + 1); nameAndTypeIndex = Utils.read2Number(bytes, start + 3); } @Override public String toString() { return \u0026quot;FileRef{\u0026quot; + \u0026quot;classInfoIndex=\u0026quot; + classInfoIndex + \u0026quot;, nameAndTypeIndex=\u0026quot; + nameAndTypeIndex + '}'; } } CONSTANT_Methodref  classInfoIndex 声明方法的类的信息，指向 CONSTANT_Class nameAndTypeIndex 方法的信息，指向 CONSTANT_NameAndType 类型的索引  class METHOD_REF extends ConstantItem { int classInfoIndex, nameAndTypeIndex; METHOD_REF() { super(10); } @Override protected int contentSize() { return 4 /*同 FIELD_REF*/; } @Override public void parse(byte[] bytes, int start) { classInfoIndex = Utils.read2Number(bytes, start + 1); nameAndTypeIndex = Utils.read2Number(bytes, start + 3); } @Override public String toString() { return \u0026quot;MethodRef{\u0026quot; + \u0026quot;classInfoIndex=\u0026quot; + classInfoIndex + \u0026quot;, nameAndTypeIndex=\u0026quot; + nameAndTypeIndex + '}'; } } CONSTANT_InterfaceMethodref  classInfoIndex 声明接口的类的信息，指向 CONSTANT_Class nameAndTypeIndex 接口的信息，指向 CONSTANT_NameAndType 类型的索引  class Interface_Method_Ref extends ConstantItem { int classInfoIndex, nameAndTypeIndex; Interface_Method_Ref() { super(11); } @Override protected int contentSize() { return 4/*同FIELD_REF*/; } @Override public void parse(byte[] bytes, int start) { classInfoIndex = Utils.read2Number(bytes, start + 1); nameAndTypeIndex = Utils.read2Number(bytes, start + 3); } @Override public String toString() { return \u0026quot;InterfaceMethodRef{\u0026quot; + \u0026quot;classInfoIndex=\u0026quot; + classInfoIndex + \u0026quot;, nameAndTypeIndex=\u0026quot; + nameAndTypeIndex + '}'; } } CONSTANT_NameAndType  nameIndex 指向方法或字段的名称在常量池中的索引 descriptorIndex 指向方法或字段的描述符在常量池中的索引  class NAME_AND_TYPE extends ConstantItem { int nameIndex, descriptorIndex; //u2 NAME_AND_TYPE() { super(12); } @Override protected int contentSize() { return 2/*u2 名称在常量池的索引*/ + 2/*u2 描述符在常量池的索引*/; } @Override public void parse(byte[] bytes, int start) { nameIndex = Utils.read2Number(bytes, start + 1); descriptorIndex = Utils.read2Number(bytes, start + 3); } @Override public String toString() { return \u0026quot;NameAndType{\u0026quot; + \u0026quot;nameIndex=\u0026quot; + nameIndex + \u0026quot;, descriptorIndex=\u0026quot; + descriptorIndex + '}'; } } CONSTANT_MethodHandle 详细信息参考 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.8\n referenceKind 方法句柄的类型，代表字节码被执行时的行为. ? 不太懂这个\u0026hellip; 还没有遇到出现的情况 referenceIndex  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Method_Handle extends ConstantItem { int referenceKind; //u1  int referenceIndex; //u2  Method_Handle() { super(15); } @Override protected int contentSize() { return 1/**/ + 2/**/; } @Override public void parse(byte[] bytes, int start) { referenceKind = Utils.readUnsignedByte(bytes, start + 1); referenceIndex = Utils.read2Number(bytes, start + 2); } @Override public String toString() { return \u0026#34;MethodHandle{\u0026#34; + \u0026#34;referenceKind=\u0026#34; + referenceKind + \u0026#34;, referenceIndex=\u0026#34; + referenceIndex + \u0026#39;}\u0026#39;; } }   CONSTANT_MethodType  descriptorIndex 指向常量池中 UTF8 类型的索引，表示方法的描述符  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Method_Type extends ConstantItem { int descriptorIndex; //u2  Method_Type() { super(16); } @Override protected int contentSize() { return 2; } @Override public void parse(byte[] bytes, int start) { descriptorIndex = Utils.read2Number(bytes, start + 1); } @Override public String toString() { return \u0026#34;MethodType{\u0026#34; + \u0026#34;descriptorIndex=\u0026#34; + descriptorIndex + \u0026#39;}\u0026#39;; } }   CONSTANT_InvokeDynamic https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.4.10\n与 Java 的动态方法调用有关。\nclass Invoke_Dynamic extends ConstantItem { int bootstrapAttrIndex, nameAndTypeIndex; Invoke_Dynamic() { super(18); } @Override protected int contentSize() { return 4; } @Override public void parse(byte[] bytes, int start) { bootstrapAttrIndex = Utils.read2Number(bytes, start + 1); nameAndTypeIndex = Utils.read2Number(bytes, start + 3); } @Override public String toString() { return \u0026quot;InvokeDynamic{\u0026quot; + \u0026quot;bootstrapAttrIndex=\u0026quot; + bootstrapAttrIndex + \u0026quot;, nameAndTypeIndex=\u0026quot; + nameAndTypeIndex + '}'; } } //endregion 解析访问标志 一个字段或方法或类的访问标志都是使用一个 u2 类型的数字表示，通过位运算 | 赋予，通过 \u0026amp;运算判断是否拥有某种访问标志。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  class AccessFlags extends Section { private static final int PUBLIC = 0x0001; // 0000 0000 0000 0001  private static final int FINAL = 0x0010; // 0000 0000 0001 0000  private static final int SUPER = 0x0020; // 0000 0000 0010 0000  private static final int INTERFACE = 0x0200; // 0000 0010 0000 0000  private static final int ABSTRACT = 0x0400; // 0000 0100 0000 0000  private static final int SYNTHETIC = 0x1000; // 0001 0000 0000 0000  private static final int ANNOTATION = 0x2000;// 0010 0000 0000 0000  private static final int ENUM = 0x4000; // 0100 0000 0000 0000  private static final int PRIVATE = 0x0002; private int accessFlags; //u2  public AccessFlags(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return 2; } @Override public void parse() { accessFlags = Utils.read2Number(bytes, start); System.out.println(\u0026#34;AccessFlags: \u0026#34; + printAccess(accessFlags)); } public static String printAccess(int access) { ArrayList\u0026lt;String\u0026gt; accessFlags = new ArrayList\u0026lt;\u0026gt;(); if ((access \u0026amp; PUBLIC) == PUBLIC) { accessFlags.add(\u0026#34;public\u0026#34;); } if ((access \u0026amp; FINAL) == FINAL) { accessFlags.add(\u0026#34;final\u0026#34;); } if ((access \u0026amp; SUPER) == SUPER) { accessFlags.add(\u0026#34;super\u0026#34;); } if ((access \u0026amp; INTERFACE) == INTERFACE) { accessFlags.add(\u0026#34;interface\u0026#34;); } if ((access \u0026amp; ABSTRACT) == ABSTRACT) { accessFlags.add(\u0026#34;abstract\u0026#34;); } if ((access \u0026amp; SYNTHETIC) == SYNTHETIC) { accessFlags.add(\u0026#34;synthetic\u0026#34;); } if ((access \u0026amp; ANNOTATION) == ANNOTATION) { accessFlags.add(\u0026#34;annotation\u0026#34;); } if ((access \u0026amp; ENUM) == ENUM) { accessFlags.add(\u0026#34;enum\u0026#34;); } if ((access \u0026amp; PRIVATE) == PRIVATE) { accessFlags.add(\u0026#34;private\u0026#34;); } StringBuilder sb = new StringBuilder(); accessFlags.forEach(s -\u0026gt; sb.append(s).append(\u0026#34;,\u0026#34;)); return sb.toString(); } }   解析类信息 类自身和其父类都存储在 class_info 结构中，classInfoIndex 指向常量池中 Constant_Class 类型的常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /** * 类索引 * 用于解析自身类和父类在常量池的索引 */ class ClassIndex extends Section { private int classInfoIndex; public ClassIndex(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return 2; } @Override public void parse() { classInfoIndex = Utils.read2Number(bytes, start); } @Override public String toString() { CLASS clasz = (CLASS) BytecodeParser.constantItemHashMap.get(classInfoIndex); UTF8 utf8 = (UTF8) BytecodeParser.constantItemHashMap.get(clasz.index); return \u0026#34;ClassIndex{\u0026#34; + \u0026#34;classInfoIndex=\u0026#34; + classInfoIndex + \u0026#34; -\u0026gt; \u0026#34; + clasz.index + \u0026#34; -\u0026gt; \u0026#34; + utf8.value + \u0026#39;}\u0026#39;; } }   解析接口 类实现的所有接口在常量池的 Constant_class 类型索引\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Interfaces extends Section { int interfaceCount; //u2  int[] indexs; // u2[interfaceCount]  public Interfaces(int start, byte[] bytes) { super(start, bytes); } @Override int size() { return interfaceCount * 2 + 2; } @Override public void parse() { interfaceCount = Utils.read2Number(bytes, start); int offset = 2; indexs = new int[interfaceCount]; for (short i = 0; i \u0026lt; interfaceCount; i++) { int index = Utils.read2Number(bytes, start + offset); indexs[i] = index; } } @Override public String toString() { return \u0026#34;Interfaces{\u0026#34; + \u0026#34;interfaceCount=\u0026#34; + interfaceCount + \u0026#34;, indexs=\u0026#34; + Arrays.toString(indexs) + \u0026#39;}\u0026#39;; } }   解析方法和字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  /** * \u0026lt;pre\u0026gt; * field_info { * u2 access_flags; * u2 name_index; * u2 descriptor_index; * u2 attributes_count; * attribute_info attributes[attributes_count]; * } * \u0026lt;/pre\u0026gt; */ class FieldOrMethod extends Section { private int infoSize = 0; int count; //u2  static class Entity { int accessFlag; //u2  int nameIndex; //u2  int descriptorIndex; //u2  int attributesCount; //u2  private ArrayList\u0026lt;AttributeInfo\u0026gt; mAttributeInfos = new ArrayList\u0026lt;\u0026gt;(); public int size() { int infoSize = 0; for (AttributeInfo info : mAttributeInfos) { infoSize += info.size(); } return 8 + infoSize; } public void parse(byte[] bytes, int offset) { accessFlag = Utils.read2Number(bytes, offset); offset += 2; nameIndex = Utils.read2Number(bytes, offset); offset += 2; descriptorIndex = Utils.read2Number(bytes, offset); offset += 2; attributesCount = Utils.read2Number(bytes, offset); offset += 2; for (int i = 0; i \u0026lt; attributesCount; i++) { AttributeInfo attributeInfo = new AttributeInfo(); attributeInfo.parse(bytes, offset); mAttributeInfos.add(attributeInfo); offset += attributeInfo.size(); } } static final int PUBLIC = 0x0001; static final int PRIVATE = 0x0002; static final int PROTECTED = 0x0004; static final int STATIC = 0x0008; static final int FINAL = 0x0010; // field special  static final int VOLATILE = 0x0040; static final int TRANSIENT = 0x0080; static final int SYNTHETIC = 0x1000; static final int ENUM = 0x4000; // method special  static final int SYNCHRONIZED = 0x0020; static final int BRIDGE = 0x0040; static final int VARARGS = 0x0080; static final int NATIVE = 0x0100; static final int ABSTRACT = 0x0400; static final int STRICTFP = 0x0500; private static String accessFlagReadable(int access) { StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;[\u0026#34;); if ((access \u0026amp; PUBLIC) == PUBLIC) sb.append(\u0026#34;Public,\u0026#34;); if ((access \u0026amp; PRIVATE) == PRIVATE) sb.append(\u0026#34;Private,\u0026#34;); if ((access \u0026amp; PROTECTED) == PROTECTED) sb.append(\u0026#34;Protected,\u0026#34;); if ((access \u0026amp; STATIC) == STATIC) sb.append(\u0026#34;Static,\u0026#34;); if ((access \u0026amp; FINAL) == FINAL) sb.append(\u0026#34;Final,\u0026#34;); if ((access \u0026amp; VOLATILE) == VOLATILE) sb.append(\u0026#34;Volatile,\u0026#34;); if ((access \u0026amp; TRANSIENT) == TRANSIENT) sb.append(\u0026#34;Transient,\u0026#34;); if ((access \u0026amp; SYNTHETIC) == SYNTHETIC) sb.append(\u0026#34;Synthetic,\u0026#34;); if ((access \u0026amp; ENUM) == ENUM) sb.append(\u0026#34;Enum,\u0026#34;); if ((access \u0026amp; SYNCHRONIZED) == SYNCHRONIZED) sb.append(\u0026#34;, Synchronized\u0026#34;); if ((access \u0026amp; BRIDGE) == BRIDGE) sb.append(\u0026#34;,Bridge\u0026#34;); if ((access \u0026amp; VARARGS) == VARARGS) sb.append(\u0026#34;,Varargs\u0026#34;); if ((access \u0026amp; NATIVE) == NATIVE) sb.append(\u0026#34;,Native\u0026#34;); if ((access \u0026amp; ABSTRACT) == ABSTRACT) sb.append(\u0026#34;,Abstract\u0026#34;); if ((access \u0026amp; STRICTFP) == STRICTFP) sb.append(\u0026#34;,Strictfp\u0026#34;); sb.append(\u0026#34;]\u0026#34;); return sb.toString(); } @Override public String toString() { return \u0026#34;Entity{\u0026#34; + \u0026#34;accessFlag=\u0026#34; + accessFlagReadable(accessFlag) + \u0026#34;, nameIndex=\u0026#34; + nameIndex + \u0026#34;, name=\u0026#34; + ((UTF8) BytecodeParser.constantItemHashMap.get(nameIndex)).value + \u0026#34;, descriptorIndex=\u0026#34; + descriptorIndex + \u0026#34;, attributesCount=\u0026#34; + attributesCount + \u0026#34;, mAttributeInfos=\u0026#34; + mAttributeInfos + \u0026#39;}\u0026#39;; } } private final String name; private final ArrayList\u0026lt;Entity\u0026gt; mEntities = new ArrayList\u0026lt;\u0026gt;(); public FieldOrMethod(String name, int start, byte[] bytes) { super(start, bytes); this.name = name; } @Override int size() { return infoSize + 2; } @Override public void parse() { int offset = start; count = Utils.read2Number(bytes, offset); offset += 2; for (int i = 0; i \u0026lt; count; i++) { Entity entity = new Entity(); entity.parse(bytes, offset); mEntities.add(entity); infoSize += entity.size(); offset += entity.size(); } } @Override public String toString() { return \u0026#34;FieldOrMethod{\u0026#34; + \u0026#34;count=\u0026#34; + count + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, mEntities=\u0026#34; + mEntities + \u0026#39;}\u0026#39;; } }   解析属性表 字段、方法、类都能拥有自己的属性表。只是某些属性只会出现在字段上(比如 volatile)或方法上(比如 synchronized)。\nu2 attribute_name_index; u4 attribute_length; attribute_name_index 和 attribute_length 是每个属性都有的两个字段，所以提出来由父类实现解析。\n/** * \u0026lt;pre\u0026gt; * attribute_info { * u2 attribute_name_index; * u4 attribute_length; * u1 info[attribute_length]; * } * \u0026lt;/pre\u0026gt; */ class AttributeInfo implements Parsable { private int nameIndex; //u2 private int attributeLength; //u4 private Info mInfo; @Override public void parse(byte[] bytes, int offset) { nameIndex = Utils.read2Number(bytes, offset); offset += 2; attributeLength = Utils.read4Number(bytes, offset); offset += 4; // 根据属性名称找到匹配的属性 ConstantItem constantItem = BytecodeParser.constantItemHashMap.get(nameIndex); UTF8 utf8 = (UTF8) constantItem; String infoName = utf8.value; mInfo = Info.getMatchInfo(infoName); if (mInfo == null) { System.err.println(\u0026quot;Not found matching Attributes: \u0026quot; + infoName); return; } mInfo.parse(bytes, offset); } public int size() { return 2 + 4 + attributeLength; } @Override public String toString() { return \u0026quot;AttributeInfo{\u0026quot; + \u0026quot;nameIndex=\u0026quot; + nameIndex + \u0026quot;, attributeLength=\u0026quot; + attributeLength + \u0026quot;, mInfo=\u0026quot; + mInfo + '}'; } } abstract class Info implements Parsable { public int size() { return contentSize(); } abstract protected int contentSize(); abstract public void parseInner(byte[] bytes, int offset); @Override public void parse(byte[] bytes, int offset) { parseInner(bytes, offset); } @Nullable public static Info getMatchInfo(String name) { switch (name) { case \u0026quot;Code\u0026quot;: return new CodeInfo(); case \u0026quot;ConstantValue\u0026quot;: return new ConstantValue(); case \u0026quot;Exceptions\u0026quot;: return new Exceptions(); case \u0026quot;LineNumberTable\u0026quot;: return new LineNumberTable(); case \u0026quot;LocalVariableTable\u0026quot;: return new LocalVariableTable(); case \u0026quot;LocalVariableTypeTable\u0026quot;: return new LocalVariableTypeTable(); case \u0026quot;SourceFile\u0026quot;: return new SourceFile(); case \u0026quot;InnerClasses\u0026quot;: return new InnerClasses(); case \u0026quot;Deprecated\u0026quot;: return new Deprecated(); case \u0026quot;Synthetic\u0026quot;: return new Synthetic(); case \u0026quot;StackMapTable\u0026quot;: // TODO StackMapTable 待实现 return null; case \u0026quot;Signature\u0026quot;: return new Signature(); default: return null; } } } Code 属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  //region Info /** * \u0026lt;pre\u0026gt; * Code_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 max_stack; * u2 max_locals; * u4 code_length; * u1 code[code_length]; * u2 exception_table_length; * { u2 start_pc; * u2 end_pc; * u2 handler_pc; * u2 catch_type; * } exception_table[exception_table_length]; * u2 attributes_count; * attribute_info attributes[attributes_count]; * } * \u0026lt;/pre\u0026gt; */ class CodeInfo extends Info { class ExceptionTable implements Parsable { int startPc; //u2  int endPc; //u2  int handlePc; // u2  int catchType; //u2  public int size() { return 2 + 2 + 2 + 2; } @Override public void parse(byte[] bytes, int offset) { startPc = Utils.read2Number(bytes, offset); offset += 2; endPc = Utils.read2Number(bytes, offset); offset += 2; handlePc = Utils.read2Number(bytes, offset); offset += 2; catchType = Utils.read2Number(bytes, offset); } @Override public String toString() { return \u0026#34;ExceptionTable{\u0026#34; + \u0026#34;startPc=\u0026#34; + startPc + \u0026#34;, endPc=\u0026#34; + endPc + \u0026#34;, handlePc=\u0026#34; + handlePc + \u0026#34;, catchType=\u0026#34; + catchType + \u0026#39;}\u0026#39;; } } int maxStack; //u2  int maxLocals; //u2  int codeLength; //u4  int[] code; // u1[codeLength]  int exceptionTableLength; //u2  ExceptionTable[] exceptionTable; int attributeCount; //u2  AttributeInfo[] attributes; private int attributesSize; @Override public int contentSize() { return attributesSize + 2 + 2 + 4 + codeLength + exceptionTableLength; } @Override public void parseInner(byte[] bytes, int offset) { maxStack = Utils.read2Number(bytes, offset); offset += 2; maxLocals = Utils.read2Number(bytes, offset); offset += 2; codeLength = Utils.read4Number(bytes, offset); offset += 4; code = new int[codeLength]; for (int i = 0; i \u0026lt; codeLength; i++) { code[i] = Utils.readUnsignedByte(bytes, offset); offset += 1; } exceptionTableLength = Utils.read2Number(bytes, offset); offset += 2; exceptionTable = new ExceptionTable[exceptionTableLength]; for (int i = 0; i \u0026lt; exceptionTableLength; i++) { exceptionTable[i] = new ExceptionTable(); exceptionTable[i].parse(bytes, offset); offset += exceptionTable[i].size(); } attributeCount = Utils.read2Number(bytes, offset); offset += 2; attributes = new AttributeInfo[attributeCount]; for (int i = 0; i \u0026lt; attributeCount; i++) { attributes[i] = new AttributeInfo(); attributes[i].parse(bytes, offset); offset += attributes[i].size(); attributesSize += attributes[i].size(); } } public String toString() { return \u0026#34;CodeInfo{\u0026#34; + \u0026#34;maxStack=\u0026#34; + maxStack + \u0026#34;, maxLocals=\u0026#34; + maxLocals + \u0026#34;, codeLength=\u0026#34; + codeLength + \u0026#34;, code=\u0026#34; + Arrays.toString(code) + \u0026#34;, exceptionTableLength=\u0026#34; + exceptionTableLength + \u0026#34;, exceptionTable=\u0026#34; + Arrays.toString(exceptionTable) + \u0026#34;, attributeCount=\u0026#34; + attributeCount + \u0026#34;, attributes=\u0026#34; + Arrays.toString(attributes) + \u0026#39;}\u0026#39;; } }   常量属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class ConstantValue extends Info { int constantValueIndex; //u2  @Override public void parseInner(byte[] bytes, int offset) { constantValueIndex = Utils.read2Number(bytes, offset + 2); } @Override public int contentSize() { return 2; } @Override public String toString() { return \u0026#34;ConstantValue{\u0026#34; + \u0026#34;constantValueIndex=\u0026#34; + constantValueIndex + \u0026#39;}\u0026#39;; } }   异常属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  /** * \u0026lt;pre\u0026gt; * Exceptions_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 number_of_exceptions; * u2 exception_index_table[number_of_exceptions]; * } * \u0026lt;/pre\u0026gt; */ class Exceptions extends Info { int numberOfExceptions; //u2  int[] exceptionIndexTable; //u2[numberOfExceptions]  @Override public int contentSize() { return 2; } @Override public void parseInner(byte[] bytes, int offset) { numberOfExceptions = Utils.read2Number(bytes, offset); offset += 2; exceptionIndexTable = new int[numberOfExceptions]; for (int i = 0; i \u0026lt; numberOfExceptions; i++) { exceptionIndexTable[i] = Utils.read2Number(bytes, offset); offset += 2; } } @Override public String toString() { return \u0026#34;Exceptions{\u0026#34; + \u0026#34;numberOfExceptions=\u0026#34; + numberOfExceptions + \u0026#34;, exceptionIndexTable=\u0026#34; + Arrays.toString(exceptionIndexTable) + \u0026#39;}\u0026#39;; } }   字节码与源码行号对应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  /** * \u0026lt;pre\u0026gt; * LineNumberTable_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 line_number_table_length; * { u2 start_pc; * u2 line_number; * } line_number_table[line_number_table_length]; * } * \u0026lt;/pre\u0026gt; */ class LineNumberTable extends Info { class LineNumberInfo implements Parsable { int startPc; //u2  int lineNumber; //u2  public static final int size = 4; @Override public void parse(byte[] bytes, int offset) { startPc = Utils.read2Number(bytes, offset); offset += 2; lineNumber = Utils.read2Number(bytes, offset); } @Override public String toString() { return \u0026#34;LineNumberInfo{\u0026#34; + \u0026#34;startPc=\u0026#34; + startPc + \u0026#34;, lineNumber=\u0026#34; + lineNumber + \u0026#39;}\u0026#39;; } } int lineNumberTableLength; //u2  private LineNumberInfo[] mLineNumberInfos; @Override protected int contentSize() { return mLineNumberInfos.length * LineNumberInfo.size + 2; } @Override public void parseInner(byte[] bytes, int offset) { lineNumberTableLength = Utils.read2Number(bytes, offset); offset += 2; mLineNumberInfos = new LineNumberInfo[lineNumberTableLength]; for (int i = 0; i \u0026lt; lineNumberTableLength; i++) { mLineNumberInfos[i] = new LineNumberInfo(); mLineNumberInfos[i].parse(bytes, offset); offset += LineNumberInfo.size; } } @Override public String toString() { return \u0026#34;LineNumberTable{\u0026#34; + \u0026#34;lineNumberTableLength=\u0026#34; + lineNumberTableLength + \u0026#34;, mLineNumberInfos=\u0026#34; + Arrays.toString(mLineNumberInfos) + \u0026#39;}\u0026#39;; } }   局部变量属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  /** * \u0026lt;pre\u0026gt; * LocalVariableTable_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 local_variable_table_length; * { u2 start_pc; * u2 length; * u2 name_index; * u2 descriptor_index; * u2 index; * } local_variable_table[local_variable_table_length]; * } * \u0026lt;/pre\u0026gt; */ class LocalVariableTable extends Info { class LocalVairableTableItem implements Parsable { int startPc; int length; int nameIndex; int descriptorIndex; int index; public static final int size = 10; @Override public void parse(byte[] bytes, int offset) { startPc = Utils.read2Number(bytes, offset); length = Utils.read2Number(bytes, offset + 2); nameIndex = Utils.read2Number(bytes, offset + 2); descriptorIndex = Utils.read2Number(bytes, offset + 4); index = Utils.read2Number(bytes, offset + 6); } @Override public String toString() { return \u0026#34;LocalVairableTableItem{\u0026#34; + \u0026#34;startPc=\u0026#34; + startPc + \u0026#34;, length=\u0026#34; + length + \u0026#34;, nameIndex=\u0026#34; + nameIndex + \u0026#34;, descriptorIndex=\u0026#34; + descriptorIndex + \u0026#34;, index=\u0026#34; + index + \u0026#39;}\u0026#39;; } } int localVariableTableLength; //u2  private LocalVairableTableItem[] items; @Override protected int contentSize() { return localVariableTableLength * LocalVairableTableItem.size + 2; } @Override public void parseInner(byte[] bytes, int offset) { localVariableTableLength = Utils.read2Number(bytes, offset); offset += 2; items = new LocalVairableTableItem[localVariableTableLength]; for (int i = 0; i \u0026lt; localVariableTableLength; i++) { items[i] = new LocalVairableTableItem(); items[i].parse(bytes, offset); offset += LocalVairableTableItem.size; } } @Override public String toString() { return \u0026#34;LocalVariableTable{\u0026#34; + \u0026#34;localVariableTableLength=\u0026#34; + localVariableTableLength + \u0026#34;, items=\u0026#34; + Arrays.toString(items) + \u0026#39;}\u0026#39;; } }   源代码文件属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /** * \u0026lt;pre\u0026gt; * SourceFile_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 sourcefile_index; * } * \u0026lt;/pre\u0026gt; */ class SourceFile extends Info { int sourceFileIndex; //u2  @Override protected int contentSize() { return 2; } @Override public void parseInner(byte[] bytes, int offset) { sourceFileIndex = Utils.read2Number(bytes, offset); } @Override public String toString() { return \u0026#34;SourceFile{\u0026#34; + \u0026#34;sourceFileIndex=\u0026#34; + sourceFileIndex + \u0026#34; -\u0026gt; \u0026#34; + ((UTF8) BytecodeParser.constantItemHashMap.get(sourceFileIndex)).value + \u0026#39;}\u0026#39;; } }   内部类属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  /** * \u0026lt;pre\u0026gt; * InnerClasses_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 number_of_classes; * { u2 inner_class_info_index; * u2 outer_class_info_index; * u2 inner_name_index; * u2 inner_class_access_flags; * } classes[number_of_classes]; * } * \u0026lt;/pre\u0026gt; */ class InnerClasses extends Info { class Classes implements Parsable { int innerClassInfoIndex, outerClassInfoIndex, innerNameInex, innerClassAccessFlags; //u2  public static final int size = 8; @Override public void parse(byte[] bytes, int offset) { innerClassInfoIndex = Utils.read2Number(bytes, offset); offset += 2; outerClassInfoIndex = Utils.read2Number(bytes, offset); offset += 2; innerNameInex = Utils.read2Number(bytes, offset); offset += 2; innerClassAccessFlags = Utils.read2Number(bytes, offset); } @Override public String toString() { return \u0026#34;Classes{\u0026#34; + \u0026#34;innerClassInfoIndex=\u0026#34; + innerClassInfoIndex + \u0026#34;, outerClassInfoIndex=\u0026#34; + outerClassInfoIndex + \u0026#34;, innerNameInex=\u0026#34; + innerNameInex + \u0026#34; -\u0026gt; \u0026#34; + ((UTF8) BytecodeParser.constantItemHashMap.get(innerNameInex)).value + \u0026#34;, innerClassAccessFlags=\u0026#34; + innerClassAccessFlags + \u0026#34; -\u0026gt; \u0026#34; + AccessFlags.printAccess(innerClassAccessFlags) + \u0026#39;}\u0026#39;; } } int numberOfClasses; //u2  private Classes[] mClasses; @Override protected int contentSize() { return numberOfClasses * Classes.size + 2; } @Override public void parseInner(byte[] bytes, int offset) { numberOfClasses = Utils.read2Number(bytes, offset); offset += 2; mClasses = new Classes[numberOfClasses]; for (int i = 0; i \u0026lt; numberOfClasses; i++) { mClasses[i] = new Classes(); mClasses[i].parse(bytes, offset); offset += Classes.size; } } @Override public String toString() { return \u0026#34;InnerClasses{\u0026#34; + \u0026#34;numberOfClasses=\u0026#34; + numberOfClasses + \u0026#34;, mClasses=\u0026#34; + Arrays.toString(mClasses) + \u0026#39;}\u0026#39;; } }   泛型签名属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  /** * \u0026lt;pre\u0026gt; * Signature_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 signature_index; * } * \u0026lt;/pre\u0026gt; */ class Signature extends Info { int signatureIndex; //u2  @Override protected int contentSize() { return 2; } @Override public void parseInner(byte[] bytes, int offset) { signatureIndex = Utils.read2Number(bytes, offset); } @Override public String toString() { ConstantItem constantItem = BytecodeParser.constantItemHashMap.get(signatureIndex); String signature = constantItem.toString(); if (constantItem instanceof UTF8) { signature = ((UTF8) constantItem).value; } else if (constantItem instanceof METHOD_REF) { signature = constantItem.toString(); } else if (constantItem instanceof STRING) { signature = ((UTF8) BytecodeParser.constantItemHashMap.get(((STRING) constantItem).index)).value; } return \u0026#34;Signature{\u0026#34; + \u0026#34;signatureIndex=\u0026#34; + signatureIndex + \u0026#34; -\u0026gt; \u0026#34; + signature + \u0026#39;}\u0026#39;; } }   StackMapTable 属性 StackMapTable 用于优化类型检查效率的。https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  /** * https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.4 * \u0026lt;pre\u0026gt; * StackMapTable_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 number_of_entries; * stack_map_frame entries[number_of_entries]; * } * * union stack_map_frame { * same_frame; * same_locals_1_stack_item_frame; * same_locals_1_stack_item_frame_extended; * chop_frame; * same_frame_extended; * append_frame; * full_frame; * } * \u0026lt;/pre\u0026gt; */ class StackMapTable extends Info { class StackMapFrame { /** * \u0026lt;pre\u0026gt; * same_frame { * u1 frame_type = SAME; // 0-63 * } * \u0026lt;/pre\u0026gt; */ class SameFrame { int frame_type; //u1  } /** * \u0026lt;pre\u0026gt; * same_locals_1_stack_item_frame { * u1 frame_type = SAME_LOCALS_1_STACK_ITEM; // 64-127 * verification_type_info stack[1]; * } * \u0026lt;/pre\u0026gt; */ class SameLocals1StackItemFrame { } class SameLocals1StackItemFrameExtended { } class ChopFrame { } class SameFrameExtended { } class AppendFrame { } class FullFrame { } } int numberOfEntries; //u2  private StackMapFrame[] mStackMapFrames; @Override protected int contentSize() { return 0; } @Override public void parseInner(byte[] bytes, int offset) { } }   Synthetic 编译器合成属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * \u0026lt;pre\u0026gt; * Synthetic_attribute { * u2 attribute_name_index; * u4 attribute_length; //always zero * } * \u0026lt;/pre\u0026gt; */ class Synthetic extends Info { @Override protected int contentSize() { return 0; } @Override public void parseInner(byte[] bytes, int offset) { } }   Deprecated 属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * \u0026lt;pre\u0026gt; * Deprecated_attribute { * u2 attribute_name_index; * u4 attribute_length; * } * \u0026lt;/pre\u0026gt; */ class Deprecated extends Info { @Override protected int contentSize() { return 0; } @Override public void parseInner(byte[] bytes, int offset) { } }   LocalVariableTypeTable 局部变量类型属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77  /** * \u0026lt;pre\u0026gt; * LocalVariableTypeTable_attribute { * u2 attribute_name_index; * u4 attribute_length; * u2 local_variable_type_table_length; * { u2 start_pc; * u2 length; * u2 name_index; * u2 signature_index; * u2 index; * } local_variable_type_table[local_variable_type_table_length]; * } * \u0026lt;/pre\u0026gt; */ class LocalVariableTypeTable extends Info { class Local_variable_type_table implements Parsable { int start_pc; int length; int name_index; int signature_index; int index; public static final int size = 10; @Override public void parse(byte[] bytes, int offset) { start_pc = Utils.read2Number(bytes, offset); length = Utils.read2Number(bytes, offset + 2); name_index = Utils.read2Number(bytes, offset + 4); signature_index = Utils.read2Number(bytes, offset + 6); index = Utils.read2Number(bytes, offset + 8); } @Override public String toString() { return \u0026#34;Local_variable_type_table{\u0026#34; + \u0026#34;start_pc=\u0026#34; + start_pc + \u0026#34;, length=\u0026#34; + length + \u0026#34;, name_index=\u0026#34; + name_index + \u0026#34;, signature_index=\u0026#34; + signature_index + \u0026#34;, index=\u0026#34; + index + \u0026#39;}\u0026#39;; } } int lvtt_length; //u2  Local_variable_type_table[] mTables; @Override protected int contentSize() { return lvtt_length * Local_variable_type_table.size + 2; } @Override public void parseInner(byte[] bytes, int offset) { lvtt_length = Utils.read2Number(bytes, offset); offset += 2; mTables = new Local_variable_type_table[lvtt_length]; for (int i = 0; i \u0026lt; lvtt_length; i++) { mTables[i] = new Local_variable_type_table(); mTables[i].parse(bytes, offset); offset += Local_variable_type_table.size; } } @Override public String toString() { return \u0026#34;LocalVariableTypeTable{\u0026#34; + \u0026#34;lvtt_length=\u0026#34; + lvtt_length + \u0026#34;, mTables=\u0026#34; + Arrays.toString(mTables) + \u0026#39;}\u0026#39;; } } //endregion   数值处理的工具类 由于 Java 的所有数字类型都是 signed 类型，就会导致 unsigned 的数到了 Java 中可能越界溢出。所以统一使用 Java 的 int 代表 unsigned byte。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Utils { /** * 获取占4字节的数 */ static int read4Number(byte[] bytes, int offset) { return ((bytes[offset] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((bytes[offset + 1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((bytes[offset + 2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((bytes[offset + 3] \u0026amp; 0xFF)); } /** * 获取占2字节的数, 为了避免 java 中只有 signed short 越界出现显示了负数, 所以返回 int */ static int read2Number(byte[] bytes, int offset) { return ((bytes[offset] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (bytes[offset + 1] \u0026amp; 0xFF); } static int readUnsignedByte(byte[] bytes, int offset) { return (bytes[offset] \u0026amp; 0xFF); } /** * 获得占8字节的数 */ static long read8Number(byte[] bytes, int offset) { return ( ((long) bytes[offset] \u0026amp; 0xFF) \u0026lt;\u0026lt; 56) | (((long) bytes[offset + 1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 48) | (((long) bytes[offset + 2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 40) | (((long) bytes[offset + 3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 32) | (((long) bytes[offset + 3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | (((long) bytes[offset + 3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | (((long) bytes[offset + 3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | (((long) bytes[offset + 3] \u0026amp; 0xFF)); } }   ","description":"按照 JVM 字节码的存储格式规范，实现了一段程序解析字节码结构。","id":24,"section":"posts","tags":null,"title":"使用Java解析class字节码结构","uri":"https://jiyang.site/posts/2020-01-20-%E4%BD%BF%E7%94%A8java%E8%A7%A3%E6%9E%90class%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/"},{"content":"Android Jetpack 提供了 ViewModel, 以用来维护 Activity 或 Fragment 中需要的数据。其能够在因配置改变(比如屏幕旋转)造成的 Activity 和 Fragment 重建时, 依然维护其内部的数据。\n背景 首先，根据官方文档能得出 ViewModel 的适用场景（也可以叫出现的目的）：\n 在发生配置改变时 Activity 和 Fragment 会被销毁重建，它们内部的临时性数据(不是通过 Intent 传入的数据)就会丢失. 如果把这些临时数据放到 ViewModel 中, 则可以避免数据的丢失。当然也可以利用 onSaveInstanceState 来保留临时数据，但是如果临时数据的量较大，onSaveInstanceState 由于涉及了跨进程通信，较大的数据量会造成 marshalling 和 unmashlling 消耗较大。而利用 ViewModel 其实是没有跨进程通信的消耗。但是它没有 onSaveInstanceState 提供的 Activity 被回收之后的数据恢复功能：在 Activity 位于后台时系统会在内存不足时将其回收，当 Activity 再次回到前台时，系统会把 onSaveInstanceState 中保存的数据通过 onRestoreInstanceState 和 onCreate 里的 savedInstanceState 参数传递给 Activity。 ViewModel 顾名思义能知道它本质就是用来储存与视图相关的数据的，官方也是推荐将 Activity(Fragment) 中的数据及数据操作提取到 ViewModel 中，让视图的显示控制和数据分离。感觉就是利用 ViewModel 做 MVP 模式了。 ViewModel 能感知 Activity或Fragment 的生命周期的改变，在 Activity或Fragment 销毁时执行一些数据清理工作(ViewModel 的实现类可以通过重写onCleared方法)。  先摊牌 后面的查找实现原理的内容可能较多，可能会让读者觉得较拖沓，因此先抛出经过查找实现原理而找到的结论。\n 我将 ViewModel 的实现原理总结为：隔山打牛\n  Activity(Fragment) 的 ViewModel 都存储在 ViewModelStore 中，每个 Activity(Fragment) 都会拥有一个 ViewModelStore 实例 ViewModelProvider 负责向使用者提供访问某个 ViewModel 的接口，其内部会持有当前 Activity(Fragment) 的 ViewModelStore，然后将操作委托给 ViewModelStore 完成 ViewModel 能在 Activity(Fragment) 在由于配置重建时恢复数据的实现原理是：Activity(指 support library 中的 ComponentActivity) 会将 ViewModelStore 在 Activity(Fragment) 重建之前交给 ActivityThread 中的 ActivityClientRecord 持有，待 Activity(Fragment) 重建完成之后，再从 ActivityClientRecord 中获取 ViewModelStore 如果应用的进程位于后台时，由于系统内存不足被销毁了。即使利用 ViewModel 的也不能在 Activity(Fragment) 重建时恢复数据。因为存储 ViewModel 的 ViewModelStore 是交给 ActivityThread 中的 ActivityClientRecord 暂存的，进程被回收了，ActivityThread 也就会被回收，ViewModelStore 也就被回收了，ViewModel 自然不复存在了  分析入口 JetPack 提供的组件都是基于 Android SDK 现有组件进行的封装, 没有修改 SDK 已有的那些类。ViewModel 也是如此, 其实现是基于 AndroidX(以前的 support library)中的 ComponentActivity。\n结合 ViewModel 的功能特点，我将从以下几个方面入手，进而理清 ViewModel 的实现原理。\n ViewModel 中涉及的类和数据结构。 ViewModel 如何保证 Activity 或 Fragment 因为配置改变而发生重建时，ViewModel 中的数据能得以保留。  核心数据结构 核心数据结构将介绍 ViewModel 中涉及的一些类和数据结构。\nViewModel ViewModel 是一个抽象类，使用者需要继承它，ViewModel 内部的变量和方法较少。\nprivate volatile boolean mCleared = false;\n表示当前的 ViewModel 是否已经被销毁了。\nprotected void onCleared()\n子类通过复写这个方法能够在 ViewModel 被销毁时进行额外的操作(比如释放资源等)。\nfinal void clear()\nViewModelStore ViewModelStore 顾名思义，它是负责储存 ViewModel 的一个类。引用 ViewModelStore 代码注释中的一段话表示它的功能:\n ViewModelStore 的实例必须在发生配置更改时得以保留：如果此 ViewModelStore 的所有者由于配置的改变而被销毁并重新创建，那么所有者的新实例应该具有相同的 ViewModelStore 旧实例。\n HashMap\u0026lt;String, ViewModel\u0026gt; mMap = new HashMap\u0026lt;\u0026gt;();\nmMap 是ViewModelStore 中有且仅有的成员变量，看它的泛型类型参数就能明白，它就是 ViewModelStore 用来存储 ViewModel 的池子。\nfinal void put(String key, ViewModel viewModel)\n向 ViewModelStore 的池子中存入 ViewModel, 如果池子中已经有 key 对应 ViewModel了，旧的会被新的替换，而且会调用旧的 ViewModel 的 onCleared 方法。(🤔️不是应该调用 ViewModel 的 clear 去释放资源吗？)\n1 2 3 4 5 6  final void put(String key, ViewModel viewModel) { ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) { oldViewModel.onCleared(); } }   ViewModel get(String key)\n从池子(mMap)中获取 key 对应的 ViewModel\n1 2 3  final ViewModel get(String key) { return mMap.get(key); }   Set\u0026lt;String\u0026gt; keys()\n返回 mMap 的所有 key\nfinal void clear()\n清空 mMap 中的所有 ViewModel，并调用每一个的 clear 方法\n1 2 3 4 5 6  public final void clear() { for (ViewModel vm : mMap.values()) { vm.clear(); } mMap.clear(); }   这里注意下 ViewModelStore 的 get 和 put 方法的声明，访问权限都是包层级的，也就表示我们使用者是无法直接通过 ViewModelStore 通过 key 拿到对应的 ViewModel 的。\nViewModelProvider  一个为范围(Application, Activity, Fragment)提供 ViewModels 的实用工具类\n 先看下 ViewModelProvider 有哪些字段：\nprivate final Factory mFactory;\n1 2 3  public interface Factory { \u0026lt;T extends ViewModel\u0026gt; T create(@NonNull Class\u0026lt;T\u0026gt; modelClass); }   Factory 表示创建 ViewModel 的工厂，final 的声明表示它必须在 ViewModelProvider 的构造函数中就赋值。\nfinal ViewModelStore mViewModelStore;\nfinal 的声明表示 mViewModelStore 也必须在构造函数中就赋值。\nstatic final String DEFAULT_KEY =\u0026quot;androidx.lifecycle.ViewModelProvider.DefaultKey\u0026quot;;\nDEFAULT_KEY，用来在提交 ViewModel 到 ViewModelStore 时构造 key\n以下是 ViewModelProvider 中的方法：\n构造方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public ViewModelProvider(@NonNull ViewModelStoreOwner owner) { this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory() : NewInstanceFactory.getInstance()); } public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { this(owner.getViewModelStore(), factory); } public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { mFactory = factory; mViewModelStore = store; }   public T get(@NonNull Class modelClass)\npublic T get(@NonNull String key, @NonNull Class modelClass)\n以上两个方法就是获取 ViewModel 的方法，也是 ViewModel 库向使用者提供的两个公开的接口。第一个 get 方法会利用 DEFAULT_KEY 构造一个 key，然后调用第二个 get 方法。\n1 2 3 4 5  public \u0026lt;T extends ViewModel\u0026gt; T get(@NonNull Class\u0026lt;T\u0026gt; modelClass) { String canonicalName = modelClass.getCanonicalName(); // 构建一个 key  return get(DEFAULT_KEY + \u0026#34;:\u0026#34; + canonicalName, modelClass); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public \u0026lt;T extends ViewModel\u0026gt; T get(@NonNull String key, @NonNull Class\u0026lt;T\u0026gt; modelClass) { // 从 ViewModelStore 中获取 ViewModel  ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { return (T) viewModel; } else { if (viewModel != null) { } } // ViewModelStore 中还没有对应 ViewModel, 就创建  if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); } else { viewModel = (mFactory).create(modelClass); } // 将创建的 ViewModel 存入 ViewModelStore  mViewModelStore.put(key, viewModel); return (T) viewModel; }   ViewModelStoreOwner ViewModelStoreOwner 是一个接口，它声明了一个 getViewModelStore 方法需要实现类实现。\n 实现此接口的类的职责是保留其拥有的 ViewModelStore 在配置更改期间不会被销毁。\n 1 2 3 4 5  public interface ViewModelStoreOwner { @NonNull ViewModelStore getViewModelStore(); }   ComponentActivity ComponentActivity 是 androidx.activity 包中增加的，FragmentActivity 继承自它。\n1 2 3 4 5 6  public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner   ComponentActivity 中与 ViewModel 有关的两个变量:\nViewModelStore mViewModelStore;\n表示当前 Activity 的 ViewModelStore, 一个 Activity 拥有一个 ViewModelStore\nViewModelProvider.Factory mDefaultFactory;\n创建 ViewModel 的工厂实现，ComponentActivity 中使用的是 SavedStateViewModelFactory, SavedStateViewModelFactory 与 Activity 的重建相关。\nViewModelStore getViewModelStore();\nComponentActivity 中实现了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public ViewModelStore getViewModelStore() { // 如果 mViewModelStore 还未赋值，则创建一个实例赋值给它  if (mViewModelStore == null) { // 与 Activity 重建时恢复数据有关，后面会再详谈  NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { // 创建 ViewModelStore, 赋值给 ComponentActivity 的 mViewModelStore 变量  mViewModelStore = new ViewModelStore(); } } return mViewModelStore; }   ViewModelStore 的创建 ViewModelStore 是负责储存 ViewModel 的，所以一般是需要先有个容器，才能存 ViewModel。而 ViewModelStore 又是由 ViewModelStoreOwner 提供的。\n我通过在 ViewModeStoreOwner 的 getViewModelStore 方法打断点查看方法栈的调用过程。通过几次断点，我发现 FragmentActivity 和非 FragmentActivity 的创建时机是有所区别的，所以后面分开看待。\nFragmentActivity 先看 FragmentActivity 的调用栈:\n getViewModelStore:262, ComponentActivity (androidx.activity) getViewModelStore:887, FragmentActivity$HostCallbacks (androidx.fragment.app) attachController:3022, FragmentManager (androidx.fragment.app) attachHost:116, FragmentController (androidx.fragment.app) onCreate:283, FragmentActivity (androidx.fragment.app) onCreate:18, ViewModelActivity performCreate:7136, Activity (android.app) performCreate:7127, Activity (android.app) callActivityOnCreate:1271, Instrumentation (android.app) performLaunchActivity:2893, ActivityThread (android.app) handleLaunchActivity:3048, ActivityThread (android.app)  从调用栈可看出一个 FragmentActivity 会在 onCreate 时调用到 getViewModelStore。\n至此能得出：只要是继承自 FragmentActivity 的 Activity(比如: AppCompatActivity) 就会在 onCreate 时创建 ViewModelStore 实例，并用自己的 mViewModelStore 变量引用到。\n那么为何 FragmentActivity 在 onCreate 时就需要创建 ViewModelStore 呢?\n看调用栈能发现 getViewModelStore 方法是在 FragmentManager 的 attachController 方法中调用的：\n1 2 3 4 5 6 7 8 9 10 11 12 13  void attachController(@NonNull FragmentHostCallback\u0026lt;?\u0026gt; host, @NonNull FragmentContainer container) { mHost = host; // Get the FragmentManagerViewModel  if (parent != null) { mNonConfig = parent.mFragmentManager.getChildNonConfig(parent); } else if (host instanceof ViewModelStoreOwner) { // 没有嵌套 Fragment 的 Fragment 会走到这里  ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore(); mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore); } else { mNonConfig = new FragmentManagerViewModel(false); } }   1 2 3 4 5  static FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) { // 创建 FragmentManagerViewModel, viewModelProvider 的 get 内部会把 ViewModel 添加到 ViewModelStore  ViewModelProvider viewModelProvider = new ViewModelProvider(viewModelStore, FACTORY); return viewModelProvider.get(FragmentManagerViewModel.class); }   原因找到了: FragmentActivity 在 onCreate 里就调用了 getViewModelStore, 是为了让 FragmentManagerViewModel 尽早的添加到 Activity 的 ViewModelStore 中。\n其他 Activity 没有继承自 FragmentActivity 的 Activity 在 onCreate 里不会创建 ViewModelStore， 而是等到有用到的地方才会创建。\n比如我在自己的 Activity 的 onCreate post 一个 Runnable, 然后按照 ViewModel 文档的描述, 通过 ViewModelProvider 获取 ViewModel:\nrunOnUiThread { val mMode = ViewModelProvider(this).get(MMode::class.java) } 执行之后时的栈为:\n getViewModelStore:262, ComponentActivity (androidx.activity) \u0026lt;init\u0026gt;:94, ViewModelProvider (androidx.lifecycle) run:20, ViewModelActivity$onCreate$1 runOnUiThread:6282, Activity (android.app)  所以 ViewModelStore 的创建时机在基于 FragmentActivity 的 Activity 和 基于 ComponentActivity 的 Activity 上有所区别。在 FragmentActivity 上是在 onCreate 中创建；在 ComponentActivity 上是在利用 ViewModelProvider 获取 ViewModel 时再创建。\n总的来说 ViewModelStore 就是 ComponentActivity 里的一个成员字段，且只会创建一次。\n再看 ViewModelProvider，它其实只是一个用来访问 ViewModelStore 的门面，它内部没有存任何数据。所以每次要获取 ViewModel 时都是创建一个新的 ViewModelProvider 实例。\nViewModel 的重建保留 ViewModel 要实现和 onSaveInstanceState 方法同样的功效，那它就需要在 Activity(或Fragment) 销毁时保留内部的数据，待 Activity 重建时恢复数据。\n前面提到过，Jetpack 中的库都是基于现有 SDK 实现进行的封装，不会修改 SDK 已有的实现。ViewModel 要实现重建保留的功能，肯定需要一个时机来做保留的动作。我们知道 SDK 已有的实现中，一个 Activity 在因为配置改变而要销毁重建时一定会调用的一个方法就是onSaveInstanceState，所以先去检查下 ComponentActivity 在这个方法中有没有动什么手脚。\n1 2 3 4 5 6 7 8  protected void onSaveInstanceState(@NonNull Bundle outState) { Lifecycle lifecycle = getLifecycle(); if (lifecycle instanceof LifecycleRegistry) { ((LifecycleRegistry) lifecycle).setCurrentState(Lifecycle.State.CREATED); } super.onSaveInstanceState(outState); mSavedStateRegistryController.performSave(outState); }   发现没有与 ViewModel 相关的，于是这条路不通了。无路可走时造路走，最后大法 Find Usage，找出使用到 mViewModelStore 的地方，看看有什么特殊没有。\n Field mViewModelStore Found usages (6 usages found) ComponentActivity (6 usages found) onRetainNonConfigurationInstance() (1 usage found) 183 ViewModelStore viewModelStore = mViewModelStore; getViewModelStore() (5 usages found) 266 if (mViewModelStore == null) { 271 mViewModelStore = nc.viewModelStore; 273 if (mViewModelStore == null) { 274 mViewModelStore = new ViewModelStore(); 277 return mViewModelStore;  发现除了 getViewModelStore，另外一个使用的方法是 onRetainNonConfigurationInstance() ,继续查找这个方法的使用方：\n Method onRetainNonConfigurationInstance() Found usages (9 usages found) Activity.java (6 usages found) 2422 Object activity = onRetainNonConfigurationInstance(); LocalActivityManager.java (1 usage found) 615 Object instance = r.activity.onRetainNonConfigurationInstance();  Activity 的 retainNonConfigurationInstances 方法调用了子类的 onRetainNonConfigurationInstance() 方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  NonConfigurationInstances retainNonConfigurationInstances() { //需要 Activity 子类实现的 onRetainNonConfigurationInstance 方法  Object activity = onRetainNonConfigurationInstance(); NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) { mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; } return nci; }   在查找 Activity 的 retaionNonConfigurationInstances 方法的调用者，Android Studio 显示找不到了。因为它的调用者是 ActivityThread(@hide 注释的)，那就进入 ActivityThread 搜索看看。\n在 ActivityThread 的 performDestroyActivity 找到了调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) { // 从 mActivities 中获取 token 对应的 ActivityClientRecord  ActivityClientRecord r = mActivities.get(token); Class\u0026lt;? extends Activity\u0026gt; activityClass = null; if (r != null) { //...  // 如果参数 getNonConfigInstance 为 true  if (getNonConfigInstance) { try { // 将 ViewModelStore 存入 ActivityClientRecord 的 lastNonConfiguratinInstances 字段中  r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances(); } catch (Exception e) {} } //...  } mActivities.remove(token); return r; }   那么这个 getNonConfigInstance 参数是在哪里赋值为 true 的呢?\n通过定位发现：在 ActivityThread.H 收到 RELAUNCH_ACTIVITY 消息时，会走到 performDestroyActivity 方法，并且 在 RELAUNCH_ACTIVITY 消息的消费链上 handleRelaunchActivityInner 方法会把 getNonConfingInstance 赋值为 true。\n在 Activity destroy 执行完之后，立马会执行 handleLaunchActivity 方法去重建 Activity。\n在创建了新的 Activity 对象之后，就会把 lastNonConfigurationInstances 写入到 Activity 的字段中。因为这里的 lastNonConfigurationInstances 一直是存在 ActivityClientRecord (代码中的r)中的，而 ActivityClientRecord 是维护在 ActivityThread 中的，所以 Activity 对象的销毁和重建不会影响 ActivityThread 中的 ActivityClientRecord 对象，也正是因为这样 ActivityClientRecord 才能持有独立与 Activity 生命周期之外的数据。\n通过上面知道 lastNonConfigurationInstances 在 ComponentActivity 中存储的实际是 Activity 的 ViewModelStore 对象。所以 ViewModelStore 靠着 ActivityClientRecord 就实现了与 Activity 生命周期的无关性。\n","description":"Android Jetpack 提供了 ViewModel, 以用来维护 Activity 或 Fragment 中需要的数据。其能够在因配置改变(比如屏幕旋转)造成的 Activity 和 Fragment 重建时, 依然维护其内部的数据。","id":25,"section":"posts","tags":null,"title":"ViewModel 的实现原理","uri":"https://jiyang.site/posts/2020-01-12-viewmodel-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"content":"Understanding Linux Networking internal 系列之 Critical Data Structures\n背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要有两个: sk_buff 和 net_device。\n struct sk_buff: 是整个网络数据包存储的地方。这个数据结构会被网络协议栈中的各层用来储存它们的协议头、用户数据和其他它们完成工作需要的数据。 struct net_device: 在 Linux 内核中，这个数据结构将用来代表网络设备。它会包含设备的硬件和软件配置信息。 在 Linux 的网络实现中，核心数据结构还有struct sock, 它被用来储存 socket 的信息。但是 Socket 其实是内核为用户态程序提供的一组 Api, 用来访问内核的网络栈实现，所以它不属于内核内部的网络实现，也就不再这里介绍了。  本文将着重理解 net_device 数据结构，上一文为对 sk_buff 的理解。\nnet_device net_device 数据结构储存着与网络设备有关的所有信息。无论真实设备还是虚拟设备，每个设备都一种这样的结构。系统上所有设备的 net_device 信息会被放到一个全局的列表中，全局指针 dev_base 指向这个列表。net_device 定义在 include/linux/netdevice.h。\nnet_device 结构体里的字段相当多并且有许多属于不同功能特有的字段和属于不同层的字段。\n网络设备可以根据类型（比如：以太网卡和令牌环网卡）进行分类。对于相同类型的所有设备，net_device 的某些字段被设置为相同的值；对于不同型号的设备则必须将某些字段设置为不同值。因此，几乎对于每种类型，Linux 提供了一个通用的函数来初始化参数，这些参数的值在所有型号的设备中都保持不变。每个设备驱动程序除了设置其驱动的设备具有唯一值的那些字段外，也会调用这个函数来初始化通用的参数。当然驱动程序也能够重写已经被内核初始化了的字段。\nnet_device 结构体中的字段大致可以分为以下几类：\n Configuration 与配置相关的字段 Statistics 与统计相关 Device status 与设备状态相关 List management 维护 net_device 列表相关的函数 Traffic management 流量管理函数 Feature specific 特有功能的函数 Generic 通用的一些字段 Function pointers 一些函数指针  Identifiers net_device 结构体包含了3个表示标识符的字段：\n int ifindex：一个唯一 ID，每个设备通过调用 dev_new_index 分配一个唯一的 ID int iflink：这个字段被（虚拟）隧道设备使用，用来标示隧道设备另一端将要到达的真实的设备 unsigned short dev_id：这个字段用于区分可以同时在不同操作系统之间共享同一设备的虚拟实例  Configuration 内核为某些配置字段提供默认值，具体取决于网络设备的类别，某些字段留给驱动程序填充。驱动程序可以改变默认值，并且一些字段能够在运行时通过命令去修改（比如：ifconfig ip命令）。实际上，在加载设备模块时，用户通常会设置几个参数（base_addr，if_port，dma 和 irq）。另一方面，虚拟设备一般不使用这些参数。\nchar name[IFNAMESIZ]\n设备的名称，比如 eth0\nunsigned long mem_start\nunsigned long mem_end\n这两个字段描述了设备与内核共享的内存的开始和结束位置。它们仅在设备驱动程序中初始化和访问；高层不需要关心它们。\nunsigned long base_addr\nI/O 内存映射到设备自身内存的开始地址。\nunsigned int irq\n(interrupt number)中断编号，当设备想与内核通信时使用。可以在多个设备之间共享。驱动程序使用request_irq 函数分配此变量，并使用 free_irq 释放它。\nunsigned char if_port\n(interface port) 设备使用接口在计算机上的端口。\n 比如我们笔记本电脑上的网卡其实支持双绞线(就是用水晶头的那个接口)和同轴电缆两种网络接入方式，双绞线和同轴电缆在我们电脑上会被分配两个端口号，网卡在工作时就需要知道自己要从哪个端口去读写数据。\n unsigned char dma\n设备使用的DMA通道。从内核获取和是否 DMA 通道，需要使用 request_dma 和 free_dma 函数。启用或关闭已经获取的 DMA 通道，需要使用 enable_dma 和 disable_dma 函数。DMA 并非适用于所有设备，因为某些总线没有使用它。\nunsigned short flags\nunsigned short gflags\nunsigned short priv_flags\nflags 标志位字段，其中的某些位表示网络设备的功能（例如 IFF_MULTICAST），其他位表示设备的状态（例如 IFF_UP 或 IFF_ RUNNING）。设备驱动程序通常在初始化时设置功能，状态标志的管理则通过内核对外部事件的响应进行。\n ~$ ifconfig lo lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 //...  比如 ifconfig lo 命令的结果中，UP LOOPBACK RUNNING 就对应到 flags 中的 IFF_UP,IFF_LOOPBACK,IFF_RUNNING 标志位。\npriv_flags 存储用户空间不可见的标志。现在，该字段由VLAN和网桥虚拟设备使用。\ngflags 几乎从未使用过，出于兼容性原因而存在。 上面的标志位能够通过 dev_change_flags 函数修改。\nint features\n标记的另一个位图用于存储其他设备功能。该数据结构包含的多个标志变量不是多余的。features 字段表示网卡与 CPU 进行通信的能力，例如网卡是否可以对高速内存进行 DMA 通信，或对硬件中的所有数据包进行校验和。该参数由设备驱动程序初始化。可以在 include/linux/netdev_features.h 中找到带有明确注释的 NETIF_F_XXX 宏。\nunsigned int mtu\nMTU 代表最大传输单位，它表示设备（比如：以太网网卡）可以处理的最大帧大小。\n以太网中常用设备的 MTU:\n   设备类型 MTU(单位：字节)     Ethernet 1500   Token Ring 4 MB/s 4464   Token Bus 8182   Token Ring 6 MB/s 17914   Hyperchannel 65535    以太网 MTU 值得聊下。以太网帧规范将最大有效负载大小定义为 1500 字节。有时，你会发现以太网 MTU 定义为 1518 或 1514：第一个是包含报头的以太网帧的最大大小，第二个是包含报头，但不包括帧校验序列（校验和的4个字节）的最大大小。\n1998年，Alteon Networks 提出了一项将以太网帧的最大有效负载增加到 9KB 的倡议。后来，该提案通过IETF Internet 草案正式化，但IEEE从未接受。在 IEEE 规范中，超过 1500 字节的帧通常称为巨型帧，并与千兆以太网一起使用以提高吞吐量（这是因为较大的帧意味着用于大型数据传输的帧减少，中断次数减少，因此CPU使用率降低，标头开销减少等）。要讨论增加以太网 MTU 的好处以及IEEE 为什么不同意此扩展的标准化，可以搜索白皮书 \u0026ldquo;Use of Extended Frame Sizes in Ethernet Networks\u0026rdquo;。Extended Ethernet Frame Size Support 下面也有 IEEE 不同意扩展到 9KB 的回复。\nunsigned short type\n设备属于的类别。\nunsigned short hard_header_len\n设备头的字节长度。比如以太网设备头的长度是 14 字节。每个设备头的长度在该设备的头文件中定义。ETH_HLEN 定义在 include/uapi/linux/if_ether.h 中。\nunsigned char broadcase[MAX_ADDR_LEN]\n链路层广播地址。\nunsigned char dev_addr[MAX_ADDR_LEN]\nunsigned char addr_len\ndev_addr 是设备链路层的地址；地址的长度（以字节为单位）由addr_len给出。addr_ len的值取决于设备的类型。以太网设备的地址为6个字节。\nint promiscuity\n表示设备是否开启混杂模式。\n接口类型和端口 有些设备带有不止一个连接器（最常见的组合是 BNC(同轴电缆)和 RJ45(双绞线水晶头)），并允许用户根据自己的需要选择其中之一。此参数用于设置设备的端口类型。如果配置命令没有强制设备驱动程序选择特定的端口类型，则只需选择默认端口类型。\n在某些情况下，单个设备驱动程序可以处理不同类型的接口。在这种情况下，接口可以通过简单地按特定顺序尝试所有端口类型来发现要使用的端口类型。\n这段代码显示了一个设备驱动程序如何根据配置方式来设置接口型号：\n1 2 3 4 5 6 7 8  switch (dev-\u0026gt;if_port) { case IF_PORT_10BASE2: writeb((readb(addr) \u0026amp; 0xf8) | 1, addr); break; case IF_PORT_10BASET: writeb((readb(addr) \u0026amp; 0xf8), addr); break; }   混杂模式 混杂模式的解释可以看 wiki。\n可以注意到 net_device 中的 promiscuity 是一个 int 类型，并不是一个常见的用 char 来表示布尔的变量。用 int 的原因是：promiscuity 字段其实是开启混杂模式的计数器。因为可能多个程序会要求设备开启混杂模式。进入混杂模式时，计数器都会递增；离开混杂模式时，计数器都会递减。直到计数器为零，设备才会关闭混杂模式。函数 set_promiscuity 用来管理混杂模式。\n只要 promiscuity 不为0，flags 的 IFF_PROMISC 位标志也将置1，并由配置接口的函数检查。\nStatistics net_device 没有提供用于保留统计信息的字段集合，而是包含一个名为 priv 的指针，该指针由驱动程序设置为指向存储有关接口信息的私有数据结构。私有数据包含了统计信息，例如发送和接收的数据包数量以及遇到的错误数量。\npriv 指向的数据结构的格式取决于设备类型和特定型号，不同的以太网卡可能使用不同的私有结构。但是，几乎所有结构都包含一个 net_device_stats 类型的字段（在 include/linux/netdevice.h 中定义），该字段包含所有网络设备共有的统计信息，并且可以使用 get_stats 方法进行检索。\nDevice Status 为了控制与 NIC(Network interface control: 对网络设备的抽象称呼，比如：网卡就是一种 NIC) 的交互，每个设备驱动程序都必须维护诸如时间戳和标志之类的信息，以指示接口需要哪种行为。在多处理器系统中，内核还必须确保正确处理了来自不同 CPU 的对同一设备的并发访问。net_device 的几个字段专用于这类的信息：\nunsigned long state\n网络排队子系统使用的一组标志。它们由枚举 netdev_state_t 中的常量索引，该常量在 include/linux/netdevice.h 中定义，并为 state 的每个位设置诸如 _ _LINK_STATE_XOFF 之类的常量。单个位是使用通用函数 set_bit 和 clear_bit 设置和清除的，这些函数通常通过包装函数来调用，该包装函数隐藏使用的位的详细信息。例如，要停止设备队列，子系统将调用 netif_stop_queue(network interface stop queue)，如下所示：\n1 2 3 4 5 6 7 8 9  static inline void netif_stop_queue(struct net_device *dev) { netif_tx_stop_queue(netdev_get_tx_queue(dev, 0)); } static __always_inline void netif_tx_stop_queue(struct netdev_queue *dev_queue) { set_bit(__QUEUE_STATE_DRV_XOFF, \u0026amp;dev_queue-\u0026gt;state); }   流量控制子系统将在后面文章介绍。\nenum {\u0026hellip;} reg_state\n(registration state)设备的注册状态。\nunsigned long trans_start\n最后一帧传输开始的时间。设备驱动程序在开始传输之前进行设置。如果在给定的时间后网卡仍未完成传输，则该字段用于检测网卡的问题。传输时间过长意味着有问题。在这种情况下，驱动程序通常会重置网卡。\nunsigned long last_rx\n接收到最后一个数据包的时间。目前，它还没有用于任何特定目的，但是可以在需要时使用。\n*struct net_device master\n存在一些协议，这些协议允许将一组设备组合在一起并被视为一个设备。这些协议包括EQL（用于串行网络接口的均衡器负载均衡器），Bonding（也称为 EtherChannel和中继）和流量控制的TEQL（真实均衡器）排队规则。组中的设备之一被选为所谓的主机(master)，它扮演着特殊的角色。该字段是指向该组主设备的 net_device 数据结构的指针。如果一个设备不是该组的成员，则指针为NULL。\nspinlock_t xmit_lock\nint xmit_lock_owner\nxmit_lock 锁用于序列化对驱动程序函数 hard_start_ xmit 的访问。这意味着每个CPU一次只能在任何给定设备上执行一次传输。xmit_lock_owner 是持有锁的CPU的ID。在单处理器系统上，它始终为0；在多处理器系统上未被锁定时，则始终为–1。当设备驱动程序支持时，也可能具有无锁传输。\n*void atalk_ptr\n*void ip_ptr\n*void dn_ptr\n*void ip6_ptr\n*void ec_ptr\n*void ax25_ptr\n这6个字段是指向特定协议特定数据结构的指针，每个数据结构都包含该协议专用的参数。\n例如，ip_ptr 指向 in_device 类型的数据结构，该数据结构包含了在设备上配置的IP 地址列表中的不同 IPv4 相关参数。\nList Management net_device 数据结构被插入到全局列表和两个哈希表中。下面的字段被用来维护全局列表和哈希表：\n*struct net_device next\n指向在全局列表中的下一个 net_device 的指针。\nstruct hlist_node name_hlist\nstruct hlist_node index_hlist\n将 net_device 链接到两个哈希表的数据列表中。\nTraffic Management Linux 提供了一些流量控制的机制。相关的字段也定义在 net_device 中:\n*struct net_device next_sched\n由软件中断使用\n*struct Qdisc qdisc\n*struct Qdisc qdisc_sleeping\n*struct Qdisc qdisc_ingress\nstruct list_head qdisc_list\n这些字段用于管理入口和出口数据包队列，以及从不同的CPU访问设备。\nspinlock_t queue_lock\nspinlock_t ingress_lock\n流量控制模块为每个网络设备定义一个专用出口队列。queue_lock 用于避免同时访问它。ingress_lock 对入口流量执行相同的操作。\nunsigned long tx_queue_len\n设备的传输队列的长度。当内核打开了流量控制时，可能不使用 tx_queue_len。可以使用 sysfs 文件系统调整其值（/sys/class/net/device_name/ 目录）。\nGeneric 除了前面讨论的net_device结构的列表管理字段之外，还有一些其他字段用于管理结构并确保在不需要它们时将其删除：\natomic_t refcnt\nnet_device 被引用的计数。在此计数器变为零之前，无法注销该设备。\nint watchdog_timeo\nstruct timer_list watchdog_timer\n这些字段与前面讨论的tx_timeout变量一起实现了 watchdog 定时器。\n*int (poll)(\u0026hellip;)\nstruct list_head poll_list\nint quota\nint weight\n由 NAPI 功能使用\n*const struct iw_handler_def wireless_handlers\n*struct iw_public_data wireless_data\n无线设备使用的其他参数和函数指针\nstruct list_head todo_list\n网络设备的注册和注销分两个步骤进行。 todo_list用于处理第二个。\nstruct class_device class_dev\n由新的通用内核驱动程序基础结构使用。\nFunction Pointers net_device 中定义了许多函数指针，它们按用途大致能分为：\n 传输和接收数据帧 增加或者解析链路层 header 改变设备的配置 获取统计信息 和特别的功能交互  *int (init)(\u0026hellip;)\n*void (uninit)(\u0026hellip;)\n*void (destructor)(\u0026hellip;)\n*int (open)(\u0026hellip;)\n*int (stop)(\u0026hellip;)\n以上函数指针，被用来初始化、清空、销毁、打开、关闭一个设备。\nstruct net_device_stats (get_stats)(\u0026hellip;)\nstruct iw_statistics (get_wireless_stats)(\u0026hellip;)\n设备驱动程序收集的一些统计信息可以让用户空间应用程序显示，例如 ifconfig 和ip 命令，而其他统计信息则由内核使用。这两种方法用于收集统计信息。 get_stats 在普通设备上运行，而 get_wireless_stats 在无线设备上运行。\n*int (hard_start_xmit)(\u0026hellip;)\n用于传输帧\n*int (hard_header)(\u0026hellip;)\n*int (rebuild_header)(\u0026hellip;)\n*int (hard_header_cache)(\u0026hellip;)\n*void (header_cache_update)(\u0026hellip;)\n*int (hard_header_parse)(\u0026hellip;)\n*int (neigh_setup)(\u0026hellip;)\n由相邻层使用的函数指针。\n*int (do_ioctl)(\u0026hellip;)\n我们知道用户态进程能够使用 ioctl 这个系统调用，向设备发出命令。上面这个函数就是用来处理 ioctl 命令的。\n*int (set_mac_address)(\u0026hellip;)\n更改设备的 MAC 地址。当设备不提供此功能时（如Bridge虚拟设备），则将其设置为NULL。\n*int (set_config)(\u0026hellip;)\n配置驱动程序的参数，例如硬件参数 irq，io_addr 和 if_port。较高层的参数（例如协议地址）由 do_ioctl 处理。\n*int (change_mtu)(\u0026hellip;)\n改变设备的 MTU。更改这个字段对设备驱动程序没有影响，只是会强制内核软件按照新的 MTU 去处理分片。\n*void (tx_timeout)(\u0026hellip;)\n在 watchdog 计时器到期时调用的方法，计时器确定传输是否花费了可疑的长时间完成。除非定义了此方法，否则 watchdog 计时器甚至不会启动。\n","description":"Understanding Linux Networking internal 系列之 Critical Data Structures","id":26,"section":"posts","tags":null,"title":"理解Linux内部网络实现之关键数据结构 net_device","uri":"https://jiyang.site/posts/2020-01-05-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-net_device/"},{"content":"Understanding Linux Networking internal 系列之 Critical Data Structures\n背景 在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要有两个: sk_buff 和 net_device。\n struct sk_buff: 是整个网络数据包存储的地方。这个数据结构会被网络协议栈中的各层用来储存它们的协议头、用户数据和其他它们完成工作需要的数据。 struct net_device: 在 Linux 内核中，这个数据结构将用来代表网络设备。它会包含设备的硬件和软件配置信息。 在 Linux 的网络实现中，核心数据结构还有struct sock, 它被用来储存 socket 的信息。但是 Socket 其实是内核为用户态程序提供的一组 Api, 用来访问内核的网络栈实现，所以它不属于内核内部的网络实现，也就不再这里介绍了。  本文将先着重理解 sk_buff 数据结构。\nSocket Buffer: sk_buff  sk_buff: 在本文中后面部分也会被称为缓冲区\n 在 Linux 内核的网络代码中，这或许是最重要的数据结构，用来表示已接收或将要传输的数据。定义在 \u0026lt;include/linux/skbuff.h\u0026gt; 中，它由许多变量组成，目标就是满足所有网络协议的需要。\nsk_buff 的结构随着内核的迭代已经被添加了许多新的选项，已经存在的字段也被重新整理了很多遍。可将内部的字段分为以下几类：\n Layout 负责内存布局的字段 General 通用的字段 Feature-specific 对应特别功能字段 Management functions 一些用来管理 sk_buff 的函数  sk_buff 在不同的网络层被使用（MAC 或其他在 L2 的协议，在 L3 的 IP 协议，在 L4 的 TCP 或 UDP 等），当它从一层传递到另一层时，各个字段也会发生变化。在被传递到 L3 之前，L4 会追加头信息，然后在被传递到 L2 之前，L3 会追加头信息。从一层传递到另一层时，通过追加头信息的方式比将数据在层之间拷贝会更有效率。由于要在 buff 的开头增加空间（与平时常见的在尾部追加空间相比）是一项复杂的操作，内核便提供了 skb_reserve 函数执行这个操作。因此，随着 buffer 从上层到下层的传递，每层协议做的第一件事就是调用 skb_reserve 去为它们的协议头在 buffer 的头部分配空间。在后面，我们将通过一个例子去了解内核如何在当 buffer 在各个层间传递时，确保为每一层保留了足够的空间让它们添加它们自己的协议头。\n在接收数据时，buffer 会被从下层到上层传递，在从下到上的过程中，前一层的协议头对于当前层来说已经没有用了。比如：L2 的协议头只会被处理 L2 协议的设备驱动程序使用，L3 并不关心 L2 的头。那么内核怎么做的呢? 内核的实现是：** sk_buff 中有一个指针会指向当前位于的层次的协议的协议头的内存开始地址，于是从 L2 到 L3 时，只需将指向 L2 头部的指针移动到 L3 的头部即可**（又是一步追求效率的操作）。\n网络选项和内核结构 内核的网络代码提供了大量有用但不是必须的选项，例如防火墙，多播等功能。这些选项都需要内核数据结构中的其他字段。因此，sk_buff 使用 C 语言的预处理命令 #ifdef 来做条件编译。例如在 sk_buff 定义的后面部分:\n1 2 3 4 5 6 7 8 9 10  struct sk_buff { //......  #ifdef CONFIG_NET_SCHED  __u32 tc_index; #ifdef CONFIG_NET_CLS_ACT  __u32 tc_verd; __u32 tc_classid; #endif  #endif }   通过在编译 Linux 时配置不同的编译选项，能够让编译出来的内核支持不同的功能。\nLayout Fields 在 sk_buff 中存在一些字段，它们存在的意义只是为了搜索的方便和数据结构的组织。这类字段称为 Layout Fileds。Linux 内核把系统中所有的 sk_buff 实例维护在一个双向链表中。但是组织这个链表比传统的双向链表要复杂一点。\n和任何双向链表类似，sk_buff 链表的每个节点也通过 next 和 prev 分别指向后继和前驱节点。但是 sk_buff 链表还要求：每个节点必须能够很快的找到整个链表的头节点。为了实现这个要求，一个额外的数据结构(sk_buff_head)被添加到链表的头部，作为一个空节点：\n1 2 3 4 5 6 7 8  struct sk_buff_head { /* These two members must be first. */ struct sk_buff\t*next; struct sk_buff\t*prev; __u32\tqlen; spinlock_t\tlock; };    qlen: 表示链表中的节点数 lock: 用作多线程同步  sk_buff 和 sk_buff_head 开始的两个节点(next prev)是相同的。即使 sk_buff_head 比 sk_buff 更轻量化，也允许这两种结构在链表中共存。另外，可以使用相同函数来操作 sk_buff 和 sk_buff_head。\n为了实现通过每个节点都能快速找到链表头，每个节点都会包含一个指向链表中唯一的 sk_buff_head 的指针（list）。\nsk_buff 其他字段 *struct sock sk\n一个指向 sock 数据结构的指针，表示 sock 对应 socket 拥有这个 sk_buff。当数据是由本地进程生成或接收时需要这个指针，因为数据和 socket相关的信息会被 L4（TCP或UDP）和用户态的程序使用。当一个 sk_buff 仅仅是被转发时（也就是说，源和目标地址不在本地计算机上），这个指针是不需要的，因此将会是 NULL。\nunsigned int len\n表示在 buffer 中数据区域的大小。该长度既包括主缓冲区的数据长度，也包括片段中的数据。因为协议头在向上传递中会被丢弃，在向下传递中会被添加，所以它的值会随着 buffer 在各层间传递而改变。\nunsiged int data_len\n和 len 不同的是，data_len 只记录分段中的数据大小。\nunsigned int mac_len\nMAC 头部的长度\natomic_t users\nsk_buff 的引用计数，或引用了此 sk_buff 缓冲区的对象数。 主要用途是避免在有人还在使用时就释放了 sk_buff。users的值可以通过 atomic_inc 和 atomic_dec直接增加和减少，但更多的时候是通过skb_get和kfree_skb` 函数进行。\nunsigned int truesize\n这个字段表示 buffer 的总大小，包括了 sk_buff 自己的占用。在执行 alloc_skb 函数时该字段被初始化。\n1 2 3  #define SKB_TRUESIZE(X) ((X) +\t\\ SKB_DATA_ALIGN(sizeof(struct sk_buff)) +\t\\ SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))   *unsigned char head\n*unsigned char end\n*unsigned char data\n*unsigned char tail\n上面4个指针用来表示 buffer 中数据域的边界。当每一层为了任务而准备 buffer 时，为了协议头或数据，可能会分配更多的空间。 head 和 end 指向了 buffer 被分配的内存区域的开始和结束， data 和 tail 指向其中实际数据域的开始和结束。\n每一层能够在 head 和 data 之间的区域填充协议头，或者在 tail 和 end 之间的区域填充新的数据。\n*void (destructor)(\u0026hellip;)\n这个函数指针能够在运行时被赋值，从而在一个 buffer 被移除时，执行一些操作。当一个 buffer 不属于一个 socket 时，这个函数指针通常为空。当一个 buffer 属于一个 socket 时，这个函数指针通常被设置为 sock_rfree 或 sock_wfree。两个 sock_xxx 函数用于更新 socket 在它的队列中持有的大量内存。\nGeneral Fields 在 sk_buff 中存在一些通用目的的字段，这些字段没有与特定的内核功能绑定：\nstruct timeval stamp\n这个字段通常仅对接收到的数据包有意义。这是一个时间戳，表示何时接收到一个数据包，或者何时计划发送一个数据包。它由接收 net_timestamp 参数的函数 netif_rx 设置，在接收每个数据包后由设备驱动程序调用。\n*struct net_device dev\n该字段描述了网络设备。 dev代表的设备的作用取决于缓冲区中存储的数据包是要发送还是刚刚被接收。\n当收到数据包后，设备驱动程序会使用指向接收数据接口的指针来更新此字段。\n当要发送数据包时，此参数表示将通过其发送出去的设备。\n*struct net_device input_dev\n表示数据包到来的设备。当数据包是在本地生成的，其值是 NULL。\n*struct net_device real_dev\n该字段仅对虚拟设备有意义，代表与虚拟设备关联的实际设备。 例如，Bonding（将两个或多个网络接口组合或合并为一个接口） 和 VLAN(virtual local area network) 接口使用它来记住从何处接收到真实设备入口流量。\nunion {\u0026hellip;} h\nunion {\u0026hellip;} nh\nunion {\u0026hellip;} mac\n上面的3个指针表示了 TCP/IP 协议栈中的协议头: h 代表 L4, nh 代表 L3, mac 代表 L2。每个字段都指向的是各种共用体结构，某个结构只能被内核中对应的层的协议理解。比如：h 共用体就包含了L4上的每个协议能理解的头信息。每个共用体的一个成员称为raw，用于初始化。 所有以后的访问都通过协议特定的成员进行。\n当接收到数据包时，负责处理第 n 层协议头的函数从第 n-1 层接收一个 buffer，其中skb-\u0026gt;data 指向第 n 层协议头的开头。处理第n层的函数会为此层初始化适当的指针（例如，L3 的处理函数会为 skb-\u0026gt;nh 赋值）以保留 skb-\u0026gt;data 字段，因为当 skb-\u0026gt;data 被赋值为 buffer 内的其他偏移量时，该指针的内容将在下一层的处理过程中丢失。然后，该函数完成第 n 层的处理，并在将数据包传递到第 n+1 层处理程序之前，更新 skb-\u0026gt;data 使其指向第 n 层协议头的末尾（即第n+1 层协议头的开始位置）。\nstruct dst_entry dst\n由路由子系统使用。 因为数据结构非常复杂，并且需要了解其他子系统的工作原理，所以留在以后在详解。\nchar cb[40]\ncontrol buffer 的简称，或存储一些私有信息，由各层维护以供内部使用。它是在 sk_buff 结构中静态分配的（当前大小为40个字节），并且足够大以容纳每一层所需的任何私有数据。在每一层的代码中，访问都是通过宏进行的，以使代码更具可读性。例如，TCP使用该空间存储 tcp_skb_cb 数据结构，该数据结构在 include/net/tcp.h 中定义：\n1 2 3 4 5 6 7 8  struct tcp_skb_cb { //... \t__u32\tseq;\t/* Starting sequence number\t*/ __u32\tend_seq;\t/* SEQ + FIN + SYN + datalen\t*/ __u8\ttcp_flags;\t/* TCP header flags. (tcp[13])\t*/ __u32\tack_seq;\t/* Sequence number ACK\u0026#39;d\t*/ //... };   这是 TCP 代码访问结构的宏。宏仅由一个指针转换组成：\n1  #define TCP_SKB_CB(__skb)\t((struct tcp_skb_cb *)\u0026amp;((__skb)-\u0026gt;cb[0]))   这是一个示例，其中 TCP 模块在收到分段后填写 cb 结构：\n1 2 3 4 5 6 7 8 9  static void tcp_v4_fill_cb(struct sk_buff *skb, const struct iphdr *iph, const struct tcphdr *th) { TCP_SKB_CB(skb)-\u0026gt;seq = ntohl(th-\u0026gt;seq); TCP_SKB_CB(skb)-\u0026gt;end_seq = (TCP_SKB_CB(skb)-\u0026gt;seq + th-\u0026gt;syn + th-\u0026gt;fin + skb-\u0026gt;len - th-\u0026gt;doff * 4); TCP_SKB_CB(skb)-\u0026gt;ack_seq = ntohl(th-\u0026gt;ack_seq); TCP_SKB_CB(skb)-\u0026gt;tcp_flags = tcp_flag_byte(th); TCP_SKB_CB(skb)-\u0026gt;tcp_tw_isn = 0; TCP_SKB_CB(skb)-\u0026gt;ip_dsfield = ipv4_get_dsfield(iph); TCP_SKB_CB(skb)-\u0026gt;sacked\t= 0; }   unsigned int csum\nunsigned char ip_summed\n上面两个字段代表校验和和状态相关的标志。\nunsigned char cloned\n一个布尔标志，设置后表示此结构是另一个sk_buff缓冲区的克隆。\nunsigned char pkt_type\n该字段根据 L2 目的地址对帧的类型进行分类。可能的值在 include/linux/if_packet.h 中列出。对于以太网设备，此参数由函数 eth_type_trans 初始化。\n主要的一些值：\n PACKET_HOST：接收到的帧的目的地址就是当前接收接口。也就是说，数据包已到达其目的地 PACKET_MULTICAST：接收到的帧的目标地址是当前接收接口已注册过的的多播地址之一 PACKET_BROADCAST：接收帧的目的地址是接收接口的广播地址 PACKET_OTHERHOST：接收帧的目的地址不属于与接口关联的目的地址（单播，组播和广播）；因此，如果启用了转发，则必须转发该帧，否则将其丢弃 PACKET_OUTGOING：表示数据包正在发送 PACKET_LOOPBACK：数据包被发送到回环设备。多亏了此标志，内核在处理回环设备时，可以跳过某些实际设备所需的操作 PACKET_FASTROUTE：数据包正在使用快速路由功能进行路由  unsigned short protocol\n从 L2 处的网卡设备驱动程序的角度来看，这是在更高层次上使用的协议。典型协议有 IP，IPv6和ARP。完整列表可在 include/linux/if_ether.h 中找到。由于每个协议都有其自己的处理传入数据包的处理函数，因此驱动程序使用此字段来通知其上一层使用什么处理函数。每个驱动程序都调用 netif_rx 来调用上层网络层的处理函数，因此必须在调用该函数之前初始化协议字段。\nunsigned short security\n表示数据包的安全级别。 该字段最初是为与 IPsec 一起使用而引入的。\nFeature-Specific Fields Linux内核是模块化的，允许你选择要包括的内容和要忽略的内容。因此，只有在编译内核时开启支持像 Netfilter 或 QoS 之类的特定功能的情况下，某些字段才会包含在 sk_buff 数据结构中：\nunsigned long nfmark\n__u32 nfcache\n__u32 nfctinfo\nstruct nf_conntrack *nfct unsigned int nfdebug\nstruct nf_bridge_info *nf_bridge\n这些参数由Netfilter使用。\nunion {\u0026hellip;} private\n高性能并行接口HIPPI使用此共用体。\n__u32 tc_index\n__u32 tc_verd\n__u32 tc_classid\n这些参数由流量控制使用。\nManagement Functions 内核提供了许多很简短的简单函数来操纵 sk_buff 节点或链表。\n如果查看文件 include/linux/skbuff.h 和 net/core/skbuff.c，你会发现几乎所有功能都有两个版本，名称分别为 do_ something 和 __do_something。通常，第一个是包装函数，它在对第二个调用的调用周围添加了额外的健全性检查或锁定机制。内部 __do_something 函数通常不直接调用。该规则的例外通常是编码不良的函数，这些函数最终将被修复。\n下图为分别对 sk_buff 执行 skb_put(a)，skb_push(b)，skb_pull(c)，skb_reserve(d) 的前后对比：\n skb_put：在数据域尾部追加一段空间 skb_push：在数据域的头部追加一段空间 skb_pull：将 skb-\u0026gt;data 指针在数据域下移指定字节 skb_reserve：在 sk_buff 中 skb-\u0026gt;data 之前的空间追加一段空间（在每层追加自己的协议头时常用到）  内存分配  alloc_skb dev_alloc_skb  alloc_skb 是分配缓冲区的主要函数，在 net/core/skbuff.c 中定义。由于数据缓冲区（由 sk_buff 的 head end data tail 指针维护的内存区域）和链表（sk_buff 自身）是两个不同的结构，所以创建单个缓冲区涉及两个内存分配（一个分配给数据缓冲区，另一个分配给 sk_buff 自身结构）。\nalloc_skb 通过调用函数 kmem_cache_alloc 从缓存中获取 sk_buff 数据结构，并通过调用 kmalloc 获取数据缓冲区，而 kmalloc 也会使用缓存的内存（如果可用）：\n1 2 3 4 5 6 7  struct sk_buff *skb; u8 *data skb = kmem_cache_alloc_node(cache, gfp_mask \u0026amp; ~__GFP_DMA, node); size = SKB_DATA_ALIGN(size); size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info)); data = kmalloc_reserve(size, gfp_mask, node, \u0026amp;pfmemalloc);   在调用 kmalloc 之前，使用宏 SKB_DATA_ALIGN 调整了大小参数以强制对齐。返回之前，该函数将初始化结构体中的一些参数，从而产生下图所示的最终结果：\n在图右侧存储块的底部，可以看到为了强制对齐而引入的 Padding 区域。 skb_shared_info 块主要用于处理 IP 的分片（IP协议根据 MTU 和 MSS 对数据包进行的分片传输）。\ndev_alloc_skb\ndev_alloc_skb 是供设备驱动程序使用的缓冲区分配函数。这类驱动程序预计将在中断模式下被执行。它就是简单的包装了下 alloc_skb, 相比 alloc_skb 多分配了一些字节的空间，并请求了原子操作（GFP_ATOMIC），因为设备驱动程序将在中断处理程序中调用。\n内存释放  kfree_skb dev_kfree_skb  这两个函数释放一个缓冲区，会让释放的缓冲区返回到缓冲池（缓存）中。dev_kfree_skb 只是通过宏定义的一个标示，内部还是调用的 kfree_skb。\nkfree_skb 仅在 skb-\u0026gt;users 计数器为1时（没有缓冲区的用户时）才释放缓冲区。 否则，该函数只会使该计数器递减。因此，如果一个缓冲区有三个用户，则只有当调用第三次 dev_kfree_skb 或 kfree_skb 时才会真正释放内存。\n数据保留和对齐  skb_reserve skb_put skb_push skb_pull  skb_reserve 在缓冲区的头部保留一些空间，通常用于允许插入协议头或强制将数据在某个边界上对齐。它通过移动标记数据域开始和结束的 data 和 tail 指针来完成操作。\n查看以太网网卡驱动程序的代码（比如: drivers/net/ethernet/3com/3c59x.c vortex_rx 函数），你能看到它们在将任何数据存储在他们刚刚分配的缓冲区中之前都会使用以下命令：\n1  skb_reserve(skb, 2);\t/* Align IP on 16 byte boundaries */   因为他们知道他们将要把协议头为 14 个字节的以太网帧复制到缓冲区中，所以参数2将缓冲区的 head 指针下移了 2 个字节。这将让紧跟在以太网头之后的 IP 头，从缓冲区的开头在 16 字节边界上对齐。\n下图展示了 skb_reserve 在数据从上到下传递（发送数据）时的作用（为下层协议在数据区的头部分配空间）：\n 当要求 TCP 传输某些数据时，它会按照某些条件（TCP Max Segment Size(mss)，对分散收集 I/O 支持等）分配一个缓冲区。 TCP 在缓冲区的头部保留（通过调用 skb_reserve）足够的空间，以容纳所有层（TCP，IP，Link 层）的所有协议头。参数 MAX_TCP_HEADER 是所有级别的所有协议头的总和，并考虑到最坏的情况：因为 TCP 层不知道将使用哪种类型的接口进行传输，因此它为每个层保留最大的标头。它甚至考虑到多个 IP 协议头的可能性（因为当内核编译为支持 IP in IP 时，你可以拥有多个IP 协议头）。 TCP 的 payload （应用层传输的数据）被复制到缓冲区中。请注意上图只是个例子。TCP 的 payload 可以被不同地组织；例如，可以将其存储为片段。 TCP 层添加它的协议头。 TCP 层将缓冲区移交给 IP 层，IP层也添加协议头。 IP 层将缓冲区移交给下一层，下一层也添加它的协议头。  请注意，当缓冲区在网络栈中向下移动时，每个协议会将 skb-\u0026gt;data 指针向下移动，在其协议头中复制，并更新 skb-\u0026gt;len。\n注意，skb_reserve 函数实际上并没有将任何内容移入或移出数据缓冲区。 它只是更新两个指针：\n1 2 3 4 5  static inline void skb_reserve(struct sk_buff *skb, int len) { skb-\u0026gt;data += len; skb-\u0026gt;tail += len; }    感觉这里是用空间来换了时间，在一开始就分配需要用到的全部空间，然后就可以通过只移动指针来提高效率了。\n skb_push 将一个数据块添加到缓冲区的开头，而 skb_put 将一个数据块添加到末尾。像 skb_reserve 一样，这些函数实际上并不会向缓冲区添加任何数据。他们只是将指针移到它的头或尾。数据填充应该由其他功能显式操作。skb_pull 通过将 head 指针向前移动来从缓冲区的头中删除数据块。\nskb_shared_info 结构体 \u0026amp; skb_shinfo 函数 在上面网卡驱动拷贝帧到缓冲区的例子中出现过 skb_shared_info。它是用来保留与数据域有关的其他信息。这个数据结构紧跟在标记数据域结束的 end 指针后面。\n1 2 3 4 5 6 7  struct skb_shared_info { atomic_t dataref; __u8 nr_frags; struct sk_buff\t*frag_list; skb_frag_t\tfrags[MAX_SKB_FRAGS]; //... };    dataref：代表数据域的「用户」数（数据域被引用的次数） nr_frags, frag_list, frags：用于处理 IP 片段  skb_is_nonlinear 函数可用于检查缓冲区是否已分段，而 skb_linearize 函数可用于将多个片段合为单个缓冲区。\nsk_buff 中没有专门的指针指向 skb_shared_info 区域，skb_shinfo 函数就是方便得到指向 skb_shared_info 区域指针的函数:\n1 2 3 4 5 6  #define skb_shinfo(SKB)\t((struct skb_shared_info *)(skb_end_pointer(SKB)))  static inline unsigned char *skb_end_pointer(const struct sk_buff *skb) { return skb-\u0026gt;end; }   克隆和拷贝 当相同的缓冲区需要由不同的消费者处理，并且他们可能更改 sk_buff 结构中的内容（协议头的h和 nh 指针等 Layout 字段）时，为了提高效率，内核并没有克隆缓冲区的结构和数据域，而是仅复制 sk_buff 的结构，并使用引用计数进行操作，以避免过早释放共享数据块。skb_clone 函数负责拷贝一个 buffer。\n使用克隆的一种情况是，需要将入口数据包分发给多个接收者，例如协议处理程序和一个或多个网络分接头（Network taps）。\nsk_buff 克隆不会链接到任何链表，也没有引用套接字所有者。克隆和原始缓冲区中的 skb-\u0026gt;cloned 字段均设置为1。在克隆中将 skb-\u0026gt;users 设置为1，以便第一次尝试删除它（被克隆的 sk_buff）时会成功，并且数据域的引用数（dataref）递增（因为现在有一个新的 sk_buff 指向了）。\nskb_clone 会调用 __skb_clone:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static struct sk_buff *__skb_clone(struct sk_buff *n, struct sk_buff *skb) { #define C(x) n-\u0026gt;x = skb-\u0026gt;x // 定义的宏，如果 x 是普通变量则是值赋值 // 如果 x 是指针，则是指向同一块区域  n-\u0026gt;next = n-\u0026gt;prev = NULL; n-\u0026gt;sk = NULL; __copy_skb_header(n, skb); //... \tn-\u0026gt;destructor = NULL; C(tail); C(end); C(head); C(head_frag); C(data); // data 是一个指针, 所以没有克隆数据域，只是指向了数据域的内存地址 \tC(truesize); refcount_set(\u0026amp;n-\u0026gt;users, 1); //设置克隆的 sk_buff 的用户数为1 \tatomic_inc(\u0026amp;(skb_shinfo(skb)-\u0026gt;dataref)); //增加数据域的引用次数 \tskb-\u0026gt;cloned = 1; return n; #undef C }   下图为一个被分段（一个缓冲区，其中一些数据存储在与frags数组链接的数据片段中）了的缓冲区克隆的例子:\n当缓冲区被克隆时，无法修改数据块的内容。这意味着代码无需做同步保证即可访问数据。但是，当一个函数不仅需要修改 sk_buff 结构的内容，还需要修改数据域时，就必须要克隆数据域了。如果真要修改数据域，开发者也有两个选项可用。\n 当开发者知道自己仅仅需要修改的数据在 skb-\u0026gt;start 和 skb-\u0026gt;end 的区域时，开发者可以使用 pskb_copy 方法只克隆那个区域。 当开发者认为自己或许也需要修改分段数据域时，就必须使用 skb_copy。  pskb_copy 和 skb_copy 的不同如下图中的(a)和(b):\n在决定克隆或复制缓冲区时，每个子系统的程序员都无法预料其他内核组件（或其子系统的其他用户）是否需要该缓冲区中的原始信息。内核是非常模块化的，并且以非常动态和不可预测的方式进行更改，因此每个子系统都不知道其他子系统可以使用缓冲区做什么。因此，每个子系统的程序员只需跟踪他们对缓冲区所做的任何修改，并注意在修改任何内容之前先进行复制，以防内核的其他部分需要原始信息。\n队列管理函数 有一些函数用来维护 sk_buff 双向链表（也可以称为队列 queue）中的节点。下面是一些常用的功能函数：\nskb_queue_head_init\n使用空节点初始化 sk_buff_head。\nskb_queue_head, skb_queue_tail\n将一个缓冲区添加到队列的头部或尾部。\nskb_dequeue, skb_dequeue_tail\n从队列的头和尾取出一个节点。\nskb_queue_purge\n清空队列。\nskb_queue_walk\n使用 for 循环遍历队列，其实现如下：\n1 2 3 4  #define skb_queue_walk(queue, skb) \\ for (skb = (queue)-\u0026gt;next;\t\\ skb != (struct sk_buff *)(queue);\t\\ skb = skb-\u0026gt;next)   可以看到其实现是定义了一个宏，预处理编译之后 skb_queue_walk 就会被替换为上面的代码，因为 sk_buff 的队列是一个双向链表，去过遍历到了头节点，说明遍历完成了。\n操作队列的所有函数都必须保证是原子操作。也就是说，它们必须获取 sk_buff_head 结构提供的队列自旋锁。否则，它们可能会被异步事件中断，这些异步事件会使队列中的元素入队或出队，例如到期计时器调用的函数会导致争用条件。\n 本文大部分内容出自:《Understanding Linux Network Internals》 https://itbook.store/books/9780596002558\n ","description":"Understanding Linux Networking internal 系列之 Critical Data Structures","id":27,"section":"posts","tags":null,"title":"理解Linux内部网络实现之关键数据结构 sk_buff","uri":"https://jiyang.site/posts/2020-01-02-%E7%90%86%E8%A7%A3linux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B-sk_buff/"},{"content":"继上次实现了 Ping 之后，尝试进入更底层的网络接口层实现局域网的 ARP 报文收发\nARP 协议概述 ARP(Address Resolution Protocol) 地址解析协议是用来通过网络层地址(IP地址)去寻找数据链路层地址(MAC地址)的网络传输协议.\n在以太网(Ethernet)协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的 MAC 地址。而在 TCP/IP 协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用 IP 协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是 ARP 协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。另外，当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。—— 地址解析协议\n报文格式 以太网首部: net/ethernet.h\n1 2 3 4 5 6  typedef struct ether_header { u_char ether_dhost[ETHER_ADDR_LEN]; /* 目标以太网地址 */ u_char ether_shost[ETHER_ADDR_LEN]; /* 源以太网地址 */ u_short ether_type; /* 帧类型 */ } ether_header_t; // ETHER_ADDR_LEN 为 6   ARP 请求/应答: net/if_arp.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  struct arphdr { u_short ar_hrd; /* 硬件类型 format of hardware address */ #define ARPHRD_ETHER 1 /* ethernet hardware format */#define ARPHRD_IEEE802 6 /* token-ring hardware format */#define ARPHRD_FRELAY 15 /* frame relay hardware format */#define ARPHRD_IEEE1394 24 /* IEEE1394 hardware address */#define ARPHRD_IEEE1394_EUI64 27 /* IEEE1394 EUI-64 */\tu_short ar_pro; /* 协议类型 format of protocol address */ u_char ar_hln; /* 硬件地址长度 length of hardware address */ u_char ar_pln; /* 协议地址长度 length of protocol address */ u_short ar_op; /* 操作码 one of: */ #define ARPOP_REQUEST 1 /* request to resolve address */#define ARPOP_REPLY 2 /* response to previous request */#define ARPOP_REVREQUEST 3 /* request protocol address given hardware */#define ARPOP_REVREPLY 4 /* response giving protocol address */#define ARPOP_INVREQUEST 8 /* request to identify peer */#define ARPOP_INVREPLY 9 /* response identifying peer *//* * The remaining fields are variable in size, * according to the sizes above. */ #ifdef COMMENT_ONLY \tu_char ar_sha[]; /* 源硬件地址 sender hardware address */ u_char ar_spa[]; /* 源协议地址 sender protocol address */ u_char ar_tha[]; /* 目标硬件地址 target hardware address */ u_char ar_tpa[]; /* 目标协议地址 target protocol address */ #endif };   实现 在 Linux 系统上, 可以通过 PF_PACKET 创建由用户态程序收发数据链接层数据的 Packet Socket, 从而发送完全自定义的 ARP 报文。但是在基于 BSD 的系统(比如 MacOS) 上, 是不支持 PF_PACKET 类型的 Socket 的，这时候就要利用 BPF(Berkeley Packet Filter)伯克利包过滤器来实现原始链路层数据的收发. —— BPF\nBerkeley Packet Filter 数据包过滤器显示为字符特殊设备 /dev/bpfN(N为0~N, 一台机器上可能会提供多个 bpf 文件)。打开设备后，必须使用 ioctl 调用并结合 BIOCSETIF, 将文件描述符绑定到特定的网络接口。给定的接口可以由多个侦听器共享，并且每个描述符下面的过滤器将看到相同的数据包流。\u0026mdash; man bpf\n打开 BPF 设备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  int openBpf() { char _buf[32]; int bfd = -1; int i = 0; // 查找一个可用的 BPF 设备  for (i = 0; i \u0026lt; 255; i++) { snprintf(_buf, sizeof(_buf), \u0026#34;/dev/bpf%u\u0026#34;, i); bfd = open(_buf, O_RDWR); if (bfd \u0026gt; 0) { break; } } return bfd; }   设置 BPF 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int setupBpf(int fd, const char *ifname) { // ifname 为硬件接口名字, 比如 en0 就代表网卡一  struct ifreq request; strlcpy(request.ifr_name, ifname, sizeof(request.ifr_name) - 1); /* 将硬件接口和BPF文件描述符绑定 */ int resp = ioctl(fd, BIOCSETIF, \u0026amp;request); if (resp \u0026lt; 0) { perror(\u0026#34;BIOCSETIF failed: \u0026#34;); return -1; } /* 返回附加接口下的数据链接层的类型, 也就是返回我们绑定的硬件接口(en0)支持的数据层类型 */ u_int type; if (ioctl(fd, BIOCGDLT, \u0026amp;type) \u0026lt; 0) { perror(\u0026#34;BIOCGDLT failed: \u0026#34;); return -1; } if (type != DLT_EN10MB) { // 如果不是支持 10MB 的网卡  printf(\u0026#34;unsupported datalink type\\n\u0026#34;); return -1; } /* 启用即时模式, 启用即时模式后，读取数据包后立即返回。否则, 读取将阻塞, 直到内核 buffer 变满或发生超时 */ int enable = 1; if (ioctl(fd, BIOCIMMEDIATE, \u0026amp;enable) \u0026lt; 0) { perror(\u0026#34;BIOCSIMMEDIATE failed: \u0026#34;); return -1; } return 0; }   DNS 解析 1 2 3 4 5 6 7 8 9  /* 根据域名或IP地址获取实际 IP地址, 并写入到 sockaddr_in 结构体中 */ struct sockaddr_in getsockaddrbyhost(const char *host) { hostent *h = gethostbyname(host); struct sockaddr_in addr; bzero(\u0026amp;addr, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_addr = *(in_addr *)(h-\u0026gt;h_addr); return addr; }   获取本机 IP地址和 MAC地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int getAddrs(struct sockaddr_in *protocolAddr, u_char *hardwareAddr) { struct ifaddrs *addrs, *addr; struct sockaddr_dl hardwareDl; /* getifaddrs 会返回当前计算机网络接口的信息, 可以看作它会把 ifconfig 命令的内容返给你 */ if (getifaddrs(\u0026amp;addrs) \u0026lt; 0) { perror(\u0026#34;[getifaddrs]\u0026#34;); return -1; } addr = addrs; /* 这里我固定了获取网卡一(en0)的地址 */ while (addr) { if (strcmp(\u0026#34;en0\u0026#34;, addr-\u0026gt;ifa_name) == 0 \u0026amp;\u0026amp; addr-\u0026gt;ifa_addr-\u0026gt;sa_family == AF_INET) { memcpy(protocolAddr, (struct sockaddr_in *)(addr-\u0026gt;ifa_addr), sizeof(struct sockaddr_in)); } if (strcmp(\u0026#34;en0\u0026#34;, addr-\u0026gt;ifa_name) == 0 \u0026amp;\u0026amp; addr-\u0026gt;ifa_addr-\u0026gt;sa_family == AF_LINK) { memcpy(\u0026amp;hardwareDl, (struct sockaddr_dl *)(addr-\u0026gt;ifa_addr), sizeof(struct sockaddr_dl)); } addr = addr-\u0026gt;ifa_next; } freeifaddrs(addrs); if (!protocolAddr || !hardwareAddr) { LOG_D(TAG, \u0026#34;not get ifaddrs\u0026#34;); return -1; } memcpy(hardwareAddr, LLADDR(\u0026amp;hardwareDl), hardwareDl.sdl_alen); return 0; }   发送 ARP 报文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80  void arp(const char *host) { /* 获取目标机器的IP地址 */ sockaddr_in targetaddr = getsockaddrbyhost(host); LOG_D(TAG, \u0026#34;target: %s\u0026#34;, inet_ntoa(targetaddr.sin_addr)); /* 获取本机的IP地址和MAC地址 */ struct sockaddr_in protocolAddr; struct sockaddr_dl hardwarAddr; u_char senderHardwareAddress[ETHER_ADDR_LEN]; if (getAddrs(\u0026amp;protocolAddr, senderHardwareAddress) \u0026lt; 0) { perror(\u0026#34;[getAddrs]\u0026#34;); exit(1); } /* ether_header: 14, arp_header: 28 */ int etherSize = 14; int arpSize = 28; int packSize = etherSize + arpSize; char buf[packSize]; bzero(buf, sizeof(buf)); /* 填充以太网头部 */ ether_header_t *eaddr = (ether_header_t *)buf; static const u_char etherBroadcast[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; // 目标MAC地址设为广播地址  memcpy(eaddr-\u0026gt;ether_dhost, etherBroadcast, 6); // 帧类型设为 ARP  eaddr-\u0026gt;ether_type = htons(ETHERTYPE_ARP); /* 填充 ARP 请求 */ struct arphdr *arphdr = (struct arphdr *)(buf + etherSize); // 硬件类型  arphdr-\u0026gt;ar_hrd = htons(ARPHRD_ETHER); // 协议类型  arphdr-\u0026gt;ar_pro = htons(ETHERTYPE_IP); // 硬件地址长度  arphdr-\u0026gt;ar_hln = sizeof(senderHardwareAddress); // 协议地址长度  arphdr-\u0026gt;ar_pln = sizeof(targetaddr.sin_addr); // 操作码 ARPOP_REQUEST 表示请求  arphdr-\u0026gt;ar_op = htons(ARPOP_REQUEST); int offset = sizeof(arphdr-\u0026gt;ar_hrd) + sizeof(arphdr-\u0026gt;ar_pro) + sizeof(arphdr-\u0026gt;ar_op) + sizeof(arphdr-\u0026gt;ar_hln) + sizeof(arphdr-\u0026gt;ar_pln) + etherSize; // 源硬件地址  memcpy(buf + offset, senderHardwareAddress, ETHER_ADDR_LEN); offset += ETHER_ADDR_LEN; // 源协议地址  memcpy(buf + offset, \u0026amp;(protocolAddr.sin_addr), 4); offset += 4; // 目标硬件地址  memset(buf + offset, 0, ETHER_ADDR_LEN); offset += ETHER_ADDR_LEN; // 目标协议地址  memcpy(buf + offset, \u0026amp;(targetaddr.sin_addr), 4); /* 输出 ARP 请求 */ outputArp(arphdr); /* 打开 BPF 设备并设置 */ int bfd = openBpf(); if (bfd \u0026lt; 0) { LOG_D(TAG, \u0026#34;[openBpf] failed\u0026#34;); exit(1); } setupBpf(bfd, \u0026#34;en0\u0026#34;); /* 写入数据 */ ssize_t writed = write(bfd, buf, packSize); if (writed \u0026lt; 0) { perror(\u0026#34;writev failed.\u0026#34;); } else { LOG_D(TAG, \u0026#34;writed %d\u0026#34;, writed); /* 写入成功之后读取数据 */ readBpf(bfd); } close(bfd); }   读取 ARP 报文 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  void readBpf(int fd) { int bufSize; /* Returns the required buffer length for reads on bpf files */ if (ioctl(fd, BIOCGBLEN, \u0026amp;bufSize) \u0026lt; 0) { perror(\u0026#34;BIOCGBLEN failed: \u0026#34;); exit(1); } LOG_D(TAG, \u0026#34;BIO Buffer: %d\u0026#34;, bufSize); char re[bufSize]; int finish = 1; while (finish) { /* 从 BPF 设备中读取数据 */ ssize_t readed = read(fd, re, bufSize); if (readed \u0026lt; 0) { perror(\u0026#34;read failed.\u0026#34;); break; } else if (readed == 0) { LOG_D(TAG, \u0026#34;read end.\u0026#34;); break; } LOG_D(TAG, \u0026#34;read %d bytes data.\u0026#34;, readed); /* 接收的数据的头部是 bpf_hdr */ const struct bpf_hdr *bpfHeader = (struct bpf_hdr *)re; LOG_D(TAG, \u0026#34;bpf header tstamp: %\u0026#34;, bpfHeader-\u0026gt;bh_tstamp); LOG_D(TAG, \u0026#34;bpf header len: %d\u0026#34;, bpfHeader-\u0026gt;bh_hdrlen); LOG_D(TAG, \u0026#34;bpf header data len: %d\u0026#34;, bpfHeader-\u0026gt;bh_datalen); LOG_D(TAG, \u0026#34;bpf header cap len: %d\u0026#34;, bpfHeader-\u0026gt;bh_caplen); /* 从 re 中取出以太网头部 */ ether_header_t *eaddr = (ether_header_t *)(re + bpfHeader-\u0026gt;bh_hdrlen); u_short etherType = ntohs(eaddr-\u0026gt;ether_type); if (etherType == ETHERTYPE_ARP) { LOG_D(TAG, \u0026#34;Received ARP\u0026#34;); /* 从 re 中取出ARP数据 */ const struct arphdr *arp = (struct arphdr *)(re + bpfHeader-\u0026gt;bh_hdrlen + sizeof(ether_header_t)); /* 由于会收到很多局域网中其他设备发出的 ARP 请求, 所以只接收第一次的 Reply, 表示是对我们发出的 Request 的响应. 更严谨的应该根据 Reply 包中的目标ip地址和目标mac地址是不是我们的地址来过滤 */ if (arp-\u0026gt;ar_op == ntohs(ARPOP_REPLY)) { LOG_D(TAG, \u0026#34;Received ARP Reply\u0026#34;); outputArp(arp); finish = 0; } } } }   结果 arp 192.168.31.1\n target: 192.168.31.1 Hardware type: 1 Protocol type: 2048 Opereation code: 1 Hardware address len: 6 Protocol address len: 4 Source hardware address: 0x88000000:0xe9000000:0xfe000000:0x53000000:0xed000000:0x16000000 Source ip address: 192.168.31.77 Dest hardware address: 0:0:0:0:0:0 Dest ip address: 192.168.31.1 writed 42 BIO Buffer: 4096 Received ARP Received ARP Received ARP Reply Hardware type: 1 Protocol type: 2048 Opereation code: 2 Hardware address len: 6 Protocol address len: 4 Source hardware address: 0x28000000:0x6c000000:0x7000000:0x3c000000:0xca000000:0x8d000000 Source ip address: 192.168.31.1 Dest hardware address: 0x88000000:0xe9000000:0xfe000000:0x53000000:0xed000000:0x16000000 Dest ip address: 192.168.31.77     Request Reply          完整源码 https://github.com/stefanJi/NetUtitily/blob/master/src/arp.cpp\n","description":"继上次实现了 Ping 之后，尝试进入更底层的网络接口层实现局域网的 ARP 报文收发","id":28,"section":"posts","tags":["ARP"],"title":"实现Arp报文发送和接收","uri":"https://jiyang.site/posts/2019-12-27-%E5%AE%9E%E7%8E%B0arp%E6%8A%A5%E6%96%87%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6/"},{"content":"为了加深自己对计算机网络的理解, 想自己实现一些操作系统提供的网络工具, 于是先从 ping 开始\n首先, ping 命令的作用是检测两个网络设备在 TCP/IP 网络下是否能连通. 其底层基于 ICMP 协议, 而 ICMP 协议位于 TCP/IP 协议栈的网络层. 模拟 ping 命令则需要模拟发送 ICMP 报文的过程.\n基础  万丈高楼平地起\n 协议基础 先简单回顾下 TCP/IP 协议栈. 如下图, TCP/IP 栈分为4层, 每一层包括一些协议, 这些协议又主要分为两个类别, 基于流的协议和基于数据包的协议:\n 基于流的协议, 主要就是基于 TCP, 基于流的协议提供双向、有序、可靠、非重复数据通信 基于数据包的协议则主要有 UDP, IP, ICMP 等, 基于数据包的协议也提供双向数据流通信, 但是不保证数据的可靠性 流和数据包的区别也主要在传输层, 等到了下面的网络层和网络接口层, 它们都会封装为数据报和帧  再用 HTTP 请求回顾下数据从应用层走到网卡的过程:\nNetwork Interface\" src=\"https://image.youcute.cn/tcp-ip-follow.png\" style=\"max-height:200px\" \n每经过一层, 其对应的 Header 就会被添加到上层传下来的数据包的头部, 为什么是添加到头部呢？因为每个协议的头部数据大小是有规则的, 而应用层的数据大小是不确定的, 而且像 TCP 还会对超过 MWS(max window size) 的数据进行分片传递, 每层协议头都追加到头部就能够方便接收方由下而上的对原始数据包进行头部剥离, 而不用关心其后面的实际数据到底有多少.\n既然这里是通过发送 ICMP 报文模拟 ping 命令, 那么 ICMP 报文又是如何封装的呢?\n如上图所示, 由于 ICMP 协议位于网络层, 所以实现它并不需要它上面的传输层和应用层的协议(这也是一种分层设计思想, 分层设计里应该只有一个方向的依赖. 比如 TCP/IP 栈中只会上层协议依赖下层协议, 不会出现下层协议依赖上层协议). 因此整个数据包中其实只有3个 Header: 以太网 Header, Ip Header 和 ICMP Header.\n通过 Wireshark 也可以看下 ICMP 数据包的封装过程:\n   ICMP IP Ethernet Frame            最下面的十六进制是原始数据流的二进制的缩写, 绿色高亮的部分对应于某一层的数据部分.\n套接字基础 上面回顾了网络协议, 那说了这么多, 我们到底怎样才能真正在操作系统上面用到或者实现上面所说的那些协议呢？\n答案就是套接字: Sokcet, Socket 最初由 Unix 系统发明, 由于其功能强大, 后来几乎所有操作系统都实现了它.\n创建一个 Socket 的方法为:\n1  int socket(int domain, int type, int protocol);   调用此系统方法, 你就能够创建一个 Socket, 该方法将返回一个指向 socket 的文件描述符. 这个方法创建的套接字, 可以访问 TCP/IP 栈中不同层上的协议, 可谓很强大了. 根据能影响到 TCP/IP 栈中的哪一层, 套接字分为不同的种类.\n传输层 Stream 和 Datagram Socket 为了获得对传输层的访问, type 参数必须是 SOCK_STREAM(使用TCP) 或者 SOCK_DGRAM(使用UDP), 这样创建的套接字被称为 stream 或者 datagram socket.\ndomain 参数则可以为:\n PF_UNIX, PF_LOCAL: 面向本地的 Socket PF_INET : 基于 IPv4 PF_INET6 : 基于 IPv6 \u0026hellip;  传递的 protocol 参数为协议编号, 这里创建 Stream 和 Datagram Socket 应该传递 0\n1 2  sd = socket(PF_INET, SOCK_STREAM, 0); sd = socket(PF_INET, SOCK_DGRAM, 0);   大多数的应用层协议都创建的这种 socket, 但这类 socket 有很大的限制, 只能访问和修改应用层传递的数据, 传输层及以下层协议的 header 在使用这类 socket 将访问不到. 因为在发送数据时下层协议的 header 将会由系统追加；在接收数据时, 下层协议的 header 信息会先被操作系统剥离, 到了应用时就只剩数据部分了.\nman 2 socket 可以看 socket 的一些详细解释.\n网络层 Raw Socket 为了突破 Stream Socket 和 Datagram Socket 的限制, 触达网络层, 于是出现了名为 Raw Socket 的狠角色.\n要创建这种狠角色, 首先只有 super 用户有权限. type 参数要为 SOCK_RAW, domain 参数规则和上面 Stream Socket 一样, protocol 可以为 0 或者任何你想要由自己组装数据包的协议, 比如:\n1 2 3 4 5 6 7 8 9 10 11  /* 由自己填充 TCP 头 */ s = socket(AF_INET, SOCK_RAW, IPPROTO_TCP); /* 由自己填充 UDP 头 */ s = socket(AF_INET, SOCK_RAW, IPPROTO_UDP); /* 由自己填充 ICMP 头 */ s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); /* 由自己填充任何协议头 */ s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);   经过上面方法创建的 socket, 我们就能自己填充对应协议的 header 了, 但是 IP 数据包的 header 还是会被操作系统的 TCP/IP 栈实现去填充.\n如果我们想自己填充 IP 数据包, 还需要设置 socket 的 option 参数打开 IP_HDRINCL:\n1 2 3 4 5  int on = 1; if ((setsockopt(s, IPPROTO_IP, IP_HDRINCL, \u0026amp;on, sizeof(on))) == -1) { LOG_D(TAG, \u0026#34;[setsockopt] IP_HDRINCL errno: %d\u0026#34;, errno); }   数据链接层 Packet Socket  Pakcet Socket 只有 Linux 支持: http://man7.org/linux/man-pages/man7/packet.7.html\nMac OS 等基于 BSD 的系统则要使用 Berkeley Packet Filter 实现对原始链路层封包的收发\n 通过 Raw Socket, 我们已经能够自由定制网络层及以上各层的数据包了, 这时如果还想自己定制更底层网络接口层的数据包, domain 参数就需要使用 PF_PACKET. 使用这种 Socket 就能够访问底层的网卡数据了.只有 SOCK_RAW 和 SOCK_DGRAM 两种 type 参数支持 Packet Socket.\n SOCK_RAW  当使用 SOCK_RAW 参数时: 操作系统将从网卡拿到的数据包, 原封不动的传递给我们的程序, 各层协议的数据都都将保持在数据包中; 同时发送数据时, 各个协议数据包都要我们自己组装\n SOCK_DGRAM  当使用 SOCK_DGRAM 参数时: 操作系统在将网卡的数据传递给我们的程序时, 会先去除网络接口层的 header 数据; 发送数据时, 除开网络接口层的 header 不用我们自己组装, 上层的各个协议数据包也要我们自己组装\n模拟实现 Ping 接下来利用 Raw Socket 发送网络层上的 ICMP 报文到目标主机, 从而模拟实现 ping 命令\nICMP 协议  https://tools.ietf.org/html/rfc792\n ICMP 消息有多种类型, 因此其数据结构中定义了几种共用体.\n在数据中位于第一个字节的是 Type, ping 中则是发送发送 Echo Request 消息, 响应方回复 Echo Reply 消息. 他俩的结构一样, 只是 Type 的值不同:\n Echo or Echo Reply Message 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Code | Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identifier | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Data ... +-+-+-+-+-   Type: Type 和 Code 是一种组合的关系, 通过 Type 和 Code 可以组合多种不同的消息类型 Type 0 且 Code 0: 表示 Echo Reply Type 8 且 Code 0: 表示 Echo Request Checksum: 根据 ICMP Header 和 Data 计算的校验和 Identifier: 一个标识符, 发起请求方可以设置一个标识符, 用来筛选 ICMP 响应  下面是 MacOS(BSD base OS) 中 icmp 数据结构的定义:\n sysroot/usr/include/netinet/ip_icmp.h\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /* * Structure of an icmp header. */ struct icmp { uint8_t icmp_type;\t/* type of message */ uint8_t icmp_code;\t/* type sub code */ uint16_t icmp_cksum;\t/* ones complement cksum of struct */ union { uint8_t ih_pptr;\t/* ICMP_PARAMPROB */ struct in_addr ih_gwaddr;\t/* ICMP_REDIRECT */ struct ih_idseq { uint16_t icd_id; uint16_t icd_seq; } ih_idseq; int32_t ih_void; /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */ struct ih_pmtu { uint16_t ipm_void; uint16_t ipm_nextmtu; } ih_pmtu; struct ih_rtradv { uint8_t irt_num_addrs; uint8_t irt_wpa; uint16_t irt_lifetime; } ih_rtradv; } icmp_hun; // 定义了一些结构体区域内的宏, 方便调用 // 比如 sturct icmp *pk = new icmp(); // 要设置 sequence number, 则需要设置 pk-\u0026gt;icmp_hun.ih_idseq.icd_seq = 0; // 可以利用宏 icmp_seq, 等效简写为 pk-\u0026gt;icmp_seq = 0; #define\ticmp_pptr\ticmp_hun.ih_pptr #define\ticmp_gwaddr\ticmp_hun.ih_gwaddr #define\ticmp_id\ticmp_hun.ih_idseq.icd_id #define\ticmp_seq\ticmp_hun.ih_idseq.icd_seq #define\ticmp_void\ticmp_hun.ih_void #define\ticmp_pmvoid\ticmp_hun.ih_pmtu.ipm_void #define\ticmp_nextmtu\ticmp_hun.ih_pmtu.ipm_nextmtu #define\ticmp_num_addrs\ticmp_hun.ih_rtradv.irt_num_addrs #define\ticmp_wpa\ticmp_hun.ih_rtradv.irt_wpa #define\ticmp_lifetime\ticmp_hun.ih_rtradv.irt_lifetime \tunion { struct id_ts { uint32_t its_otime; uint32_t its_rtime; uint32_t its_ttime; } id_ts; struct id_ip { struct ip idi_ip; /* options and then 64 bits of data */ } id_ip; uint32_t id_mask; int8_t\tid_data[1]; } icmp_dun; #define\ticmp_otime\ticmp_dun.id_ts.its_otime #define\ticmp_rtime\ticmp_dun.id_ts.its_rtime #define\ticmp_ttime\ticmp_dun.id_ts.its_ttime #define\ticmp_ip\ticmp_dun.id_ip.idi_ip #define\ticmp_mask\ticmp_dun.id_mask #define\ticmp_data\ticmp_dun.id_data };   实现  以下是在 MacOS 上的实现, Linux 上头文件和一些数据结构会有所差别\n 通过一个定时器每隔 1 秒向本博客发送一个 ICMP Echo Request\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119  #include \u0026#34;log.h\u0026#34;#include \u0026lt;errno.h\u0026gt;#include \u0026lt;memory\u0026gt;#include \u0026lt;sys/socket.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;#include \u0026lt;netinet/in.h\u0026gt;#include \u0026lt;netinet/ip.h\u0026gt;#include \u0026lt;netinet/ip_icmp.h\u0026gt;#include \u0026lt;netdb.h\u0026gt;#include \u0026lt;arpa/inet.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;signal.h\u0026gt;#include \u0026lt;sys/time.h\u0026gt;#include \u0026#34;checksum.cpp\u0026#34; namespace NetUtility { #define TAG \u0026#34;NetUtility\u0026#34; #define BUFFER_SIZE 1500  void doping(int signal); int s; struct sockaddr_in serveraddr; int step, max = 0; char *hostname, *ipadrr; void ping(const char *host, int maxstep) { max = maxstep; struct timeval tval; struct itimerval timer; struct sigaction act; /* Setting the handler for the SIGALRM and SIGINI signals */ memset(\u0026amp;act, 0, sizeof(act)); act.sa_handler = \u0026amp;doping; sigaction(SIGALRM, \u0026amp;act, NULL); sigaction(SIGINT, \u0026amp;act, NULL); // Host resolve domain name service  hostent *h = gethostbyname(host); hostname = h-\u0026gt;h_name; ipadrr = inet_ntoa(*(struct in_addr *)(h-\u0026gt;h_addr)); s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP); int n = 1; if (s == -1) { LOG_D(TAG, \u0026#34;create socket fd failed. errno: %d\u0026#34;, errno); if (errno == EPERM) { LOG_D(TAG, \u0026#34;Operation not permitted\u0026#34;); } if (errno == EACCES) { LOG_D(TAG, \u0026#34;Permission to create a socket of the specified type and/or protocol is denied\u0026#34;); } exit(errno); } setuid(getuid()); // Set broadcast  int on = 1; if ((setsockopt(s, SOL_SOCKET, SO_BROADCAST, \u0026amp;on, sizeof(on))) == -1) { LOG_D(TAG, \u0026#34;[setsockopt] SO_BROADCAST errno: %d\u0026#34;, errno); } // Set buffer  int size = 60 * 1024; if ((setsockopt(s, SOL_SOCKET, SO_RCVBUF, \u0026amp;size, sizeof(size))) == -1) { LOG_D(TAG, \u0026#34;[setsockopt] SO_RCVBUF errno: %d\u0026#34;, errno); } /* Starting a timer to send the SIGALRM signal */ timer.it_value.tv_sec = 0; timer.it_value.tv_usec = 1; /* Timer first every second */ timer.it_interval.tv_sec = 1; timer.it_interval.tv_usec = 0; /* Starting the real-time timer */ setitimer(ITIMER_REAL, \u0026amp;timer, NULL); bzero(\u0026amp;serveraddr, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; serveraddr.sin_addr = *((struct in_addr *)h-\u0026gt;h_addr); // Receive from  int bytes = 0; struct sockaddr_in from; socklen_t from_len = sizeof(from); char buffer[BUFFER_SIZE]; while (1) { bytes = recvfrom(s, buffer, sizeof(buffer), 0, (struct sockaddr *)\u0026amp;from, \u0026amp;from_len); if (bytes \u0026lt; 0) { if (errno == EINTR) { continue; } LOG_D(TAG, \u0026#34;recvfrom() failed\u0026#34;); continue; } gettimeofday(\u0026amp;tval, NULL); LOG_D(TAG, \u0026#34;%d bytes from %s\u0026#34;, bytes, ipadrr); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  void doping(int signal) { if (signal != SIGALRM || step \u0026gt;= max) { exit(1); } int icmplen; struct icmp *icmp; char sendbuf[BUFFER_SIZE]; icmp = reinterpret_cast\u0026lt;struct icmp *\u0026gt;(sendbuf); /* Fill all filed of the ICMP message */ icmp-\u0026gt;icmp_type = ICMP_ECHO; icmp-\u0026gt;icmp_code = 0; icmp-\u0026gt;icmp_id = getpid(); icmp-\u0026gt;icmp_seq = step; gettimeofday((struct timeval *)icmp-\u0026gt;icmp_data, NULL); icmplen = 8 + 56; icmp-\u0026gt;icmp_cksum = 0; icmp-\u0026gt;icmp_cksum = checksum(reinterpret_cast\u0026lt;unsigned short *\u0026gt;(icmp), icmplen); if (sendto( s, sendbuf, icmplen, 0, reinterpret_cast\u0026lt;sockaddr *\u0026gt;(\u0026amp;serveraddr), sizeof(sockaddr)) \u0026lt; 0) { LOG_D(TAG, \u0026#34;[send to] error: %d\u0026#34;, errno); } if (step == 0) { LOG_D(TAG, \u0026#34;PING %s (%s): %d data bytes\u0026#34;, hostname, ipadrr, icmplen); } step++; } }; // namespace NetUtility   1 2 3 4 5  int main() { NetUtility::ping(\u0026#34;jiyang.site\u0026#34;, 6); return 0; }   Android 中实现 Android 系统基于 Linux, Android 也为使用底层的系统方法提供了一个类 Os.java, 通过这个类的中与 Socket 相关的方法也能实现几种类型的 Socket. 但是需要 App 有 root 权限.\n Android/sdk/sources/android-28/android/system/Os.java\n 1 2 3 4 5 6 7 8 9  val sd = Os.socket(OsConstants.AF_INET, OsConstants.SOCK_RAW, OsConstants.IPPROTO_ICMP) val address = InetAddress.getByName(\u0026#34;10.184.20.144\u0026#34;) val date = ByteArray(4) date[0] = 8 //type date[1] = 0 //code date[2] = 100 //checksum date[3] = 1 // identifier date[4] = 0 //seq val send = Os.sendto(sd, date, 0, date.size, 0, address, 0)   参考  伯克利套接字 https://medium.com/@c_bata_/how-to-write-cross-platform-packet-capture-using-raw-socket-and-bpf-bab3b614bc03  ","description":"为了加深自己对计算机网络的理解, 想自己实现一些操作系统提供的网络工具, 于是先从 ping 开始","id":29,"section":"posts","tags":["ICMP"],"title":"实现 ping Utility","uri":"https://jiyang.site/posts/2019-12-15-%E5%AE%9E%E7%8E%B0-ping-utility/"},{"content":"最近使用 Android Jetpack 中 WorkManager 组件做了一个上报一些做分析用途数据的需求, 用着感觉挺香的. 于是想看下其内部的实现原理.\n背景 使用 WorkManager 的原因在于 Android 系统在每个版本上都对 App 运行后台任务加了限制, 不同版本有不同的限制, 其目的都是为了节省用户设备的电量消耗. 参考: https://developer.android.com/guide/background .\nWorkManager 的功能  https://developer.android.com/topic/libraries/architecture/workmanager\n   当用户设备满足一些条件的情况下才执行的任务, 比如用户手机使用的是无线网络，电量充足，储存空间充足的情况下才执行某些任务.\n  向后兼容到 API 14\n API 23+ 使用 JobScheduler API 14-22 结合 BroadcastReceiver 和 AlarmManager     可以为任务添加约束, 例如无线网络可用或充电状态下才执行\n  可以提交一次性或定期任务\n  可以监视和管理提交的任务\n  可以将多个任务链接在一起(并行、串行、组合)\n  即使应用或设备重启也能保证任务的执行\n  类似 Doze 模式一样节电\n  运行在非主线程\n  简单例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  // 实现 Worker class UploadWorker(appContext: Context, workerParams: WorkerParameters) : Worker(appContext, workerParams) { override fun doWork(): Result { // 这里运行在非主线程  uploadImages() // 返回任务执行成功、失败、重试、取消  return Result.success() } } // 创建约束条件 val constraints = Constraints.Builder() .setRequiresBatteryNotLow(true) // 电量不低  .setRequiredNetworkType(NetworkType.CONNECTED) // 连接了网络  .setRequiresCharging(true) // 充电中  .setRequiresStorageNotLow(true) // 储存空间不低  .setRequiresDeviceIdle(true) // 设备空闲中  .build() // 定义输入数据 // 输入数据通过 key value 匹配, key 为 String, value 为基本数据类型和 String val imageData = workDataOf(Constants.KEY_IMAGE_URI to imageUriString) // 创建请求 val request = OneTimeWorkRequestBuilder\u0026lt;UploadWorker\u0026gt;() .setInputData(imageData) // 输入数据  .setConstraints(constraints) // 约束条件  .setBackoffCriteria( // 重试任务时的策略  BackoffPolicy.LINEAR, OneTimeWorkRequest.MIN_BACKOFF_MILLIS, TimeUnit.MILLISECONDS) .build() //提交任务 WorkManager.getInstance(context).enque(request);   实现原理 在实现原理上, 这里先提出几个问题:\n 如何确保任务一定会被执行, 即使在应用重启或手机重启之后 如何确保是在非主线程运行的 如何去匹配我们创建请求时提交的约束的 如何监控和管理任务  整体流程 从上图中可以看出一个 WorkRequest 被提交之后的流程:\n WorkRequest 的信息会经 Internal TaskExecutor 储存到数据库 当满足约束条件时, WorkFactory 从数据库拿出 WorkRequest 的信息构造出 Worker, 然后在 Executor 中执行 Worker 的 doWork 方法.  有几个组件:\n WorkRequest: 一个接口, 定义了 Worker 的相关信息都在这个里面, 有两个实现类 OneTimeWorkRequest 和 PeriodicWorkRequest 分别对应一次性任务和周期任务 Internal TaskExecutor: WorkManager 内部的线程池, 用来执行将提交的 WorkRequest 储存到数据库的动作 WorkerFactory: 根据 WorkRequest 里的信息创建 Worker 实例的工厂类 Worker: 我们自己实现的 Woker, 例子中的 UploadWorker Executor: 执行 Worker doWork 方法的线程池, 默认是调用 Executors.newFixedThreadPool 创建的线程池, 也可以自己配置这个线程池  WorkManager 的初始化 WorkManger 将会是一个单例对象, 但是从例子代码中没有看的调用初始化的地方. 通过文档可知 WorkManager 有两种初始化方式:\n 应用启动之后, 它自己自动初始化 按需初始化, 到了需要用到的地方才初始化. 可以避免初始化影响应用的启动速度  自动初始化 利用 ContentProvider, ContentProvider 会在应用启动之后调用 onCreate 方法, 所以自动初始化就是在 onCreate 中执行 WorkManager 的初始化\n1 2 3 4 5 6 7 8  public class WorkManagerInitializer extends ContentProvider { @Override public boolean onCreate() { // Initialize WorkManager with the default configuration.  WorkManager.initialize(getContext(), new Configuration.Builder().build()); return true; } }   按需初始化 因为 WorkManagerInitializer 这个 ContentProvider 会被 WorkManager 库注册到应用的 manifest.xml 中, 所以如果要使用按需初始化, 需要主动移除这个 ContentProvider 并让 Application 实现 Configuration.Provider 接口:\n1 2 3 4 5  \u0026lt;provider android:name=\u0026#34;androidx.work.impl.WorkManagerInitializer\u0026#34; android:authorities=\u0026#34;${applicationId}.workmanager-init\u0026#34; tools:node=\u0026#34;remove\u0026#34; android:exported=\u0026#34;false\u0026#34; /\u0026gt;   1 2 3 4 5 6 7  public final class MApp extends Application implements Configuration.Provider { @Override public Configuration getWorkManagerConfiguration() { return new Configuration.Builder().build(); } }   这样之后, 就不会在应用启动时调用 WorkManagerInitializer 的 onCreate 了. 但是每次获取实例就需要使用 getInstance(Context ctx) 带参数的那个, 因为要在 getInstance 里做初始化.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public static @NonNull WorkManagerImpl getInstance(@NonNull Context context) { synchronized (sLock) { WorkManagerImpl instance = getInstance(); if (instance == null) { Context appContext = context.getApplicationContext(); if (appContext instanceof Configuration.Provider) { initialize(appContext, ((Configuration.Provider) appContext).getWorkManagerConfiguration()); instance = getInstance(appContext); } else { } } return instance; } }   初始化 初始化工作的 initialize 方法里:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public static void initialize(@NonNull Context context, @NonNull Configuration configuration) { synchronized (sLock) { if (sDelegatedInstance == null) { context = context.getApplicationContext(); if (sDefaultInstance == null) { // 创建单例  sDefaultInstance = new WorkManagerImpl( context, configuration, new WorkManagerTaskExecutor(configuration.getTaskExecutor())); } sDelegatedInstance = sDefaultInstance; } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public WorkManagerImpl( @NonNull Context context, @NonNull Configuration configuration, @NonNull TaskExecutor workTaskExecutor, boolean useTestDatabase) { Context applicationContext = context.getApplicationContext(); // 创建数据库  WorkDatabase database = WorkDatabase.create(applicationContext, configuration.getTaskExecutor(), useTestDatabase); Logger.setLogger(new Logger.LogcatLogger(configuration.getMinimumLoggingLevel())); // 创建 schedulers  List\u0026lt;Scheduler\u0026gt; schedulers = createSchedulers(applicationContext, workTaskExecutor); // 创建 processor  Processor processor = new Processor( context, configuration, workTaskExecutor, database, schedulers); internalInit(context, configuration, workTaskExecutor, database, schedulers, processor); }   创建任务 通过例子中的代码能看到最终组装出来的是一个 WorkRequest 对象, 那么这个对象其实就是定义了我们要执行的任务信息, 每个组装信息都能通过 Builder 构建.\nWorkRequest WorkRequest 的 Buidler 是一个抽象类, 一次性和周期任务分别实现了自己的 Buidler.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // WorkRequest.Builder public abstract static class Builder\u0026lt;B extends Builder, W extends WorkRequest\u0026gt; { boolean mBackoffCriteriaSet = false; UUID mId; WorkSpec mWorkSpec; Set\u0026lt;String\u0026gt; mTags = new HashSet\u0026lt;\u0026gt;(); Builder(@NonNull Class\u0026lt;? extends ListenableWorker\u0026gt; workerClass) { mId = UUID.randomUUID(); // 分配一个 uuid  mWorkSpec = new WorkSpec(mId.toString(), workerClass.getName()); // 创建 WorkSpec  addTag(workerClass.getName()); // 传入的 Worker 的 className 作为一个 tag  } public final W build() { W returnValue = buildInternal(); // 子类实现 buildInternal 方法  // Create a new id and WorkSpec so this WorkRequest.Builder can be used multiple times.  mId = UUID.randomUUID(); mWorkSpec = new WorkSpec(mWorkSpec); mWorkSpec.id = mId.toString(); return returnValue; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // OneTimeWorkRequest.Builder public static final class Builder extends WorkRequest.Builder\u0026lt;Builder, OneTimeWorkRequest\u0026gt; { public Builder(@NonNull Class\u0026lt;? extends ListenableWorker\u0026gt; workerClass) { super(workerClass); // 为 inputMergerClassName 单独赋个值  mWorkSpec.inputMergerClassName = OverwritingInputMerger.class.getName(); } @Override OneTimeWorkRequest buildInternal() { if (mBackoffCriteriaSet \u0026amp;\u0026amp; Build.VERSION.SDK_INT \u0026gt;= 23 \u0026amp;\u0026amp; mWorkSpec.constraints.requiresDeviceIdle()) { throw new IllegalArgumentException(\u0026#34;Cannot set backoff criteria on an idle mode job\u0026#34;); } return new OneTimeWorkRequest(this); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // PeriodicWorkRequest.Builder public static final class Builder extends WorkRequest.Builder\u0026lt;Builder, PeriodicWorkRequest\u0026gt; { public Builder( @NonNull Class\u0026lt;? extends ListenableWorker\u0026gt; workerClass, long repeatInterval, @NonNull TimeUnit repeatIntervalTimeUnit) { super(workerClass); // 周期任务的间隔执行时间  mWorkSpec.setPeriodic(repeatIntervalTimeUnit.toMillis(repeatInterval)); } PeriodicWorkRequest buildInternal() { if (mBackoffCriteriaSet \u0026amp;\u0026amp; Build.VERSION.SDK_INT \u0026gt;= 23 \u0026amp;\u0026amp; mWorkSpec.constraints.requiresDeviceIdle()) { throw new IllegalArgumentException(\u0026#34;Cannot set backoff criteria on an idle mode job\u0026#34;); } return new PeriodicWorkRequest(this); } }   WorkSpec 查看 WorkSpec 的定义能发现其利用 Room 实现的数据库字段和类字段的映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class WorkSpec { @ColumnInfo(name = \u0026#34;id\u0026#34;) @PrimaryKey @NonNull public String id; @ColumnInfo(name = \u0026#34;state\u0026#34;) @NonNull public WorkInfo.State state = ENQUEUED; @ColumnInfo(name = \u0026#34;worker_class_name\u0026#34;) @NonNull public String workerClassName; @ColumnInfo(name = \u0026#34;input_merger_class_name\u0026#34;) public String inputMergerClassName; @ColumnInfo(name = \u0026#34;input\u0026#34;) @NonNull public Data input = Data.EMPTY; @ColumnInfo(name = \u0026#34;output\u0026#34;) @NonNull public Data output = Data.EMPTY; @ColumnInfo(name = \u0026#34;initial_delay\u0026#34;) public long initialDelay; @ColumnInfo(name = \u0026#34;interval_duration\u0026#34;) public long intervalDuration; @ColumnInfo(name = \u0026#34;flex_duration\u0026#34;) public long flexDuration; @Embedded @NonNull public Constraints constraints = Constraints.NONE; @ColumnInfo(name = \u0026#34;run_attempt_count\u0026#34;) @IntRange(from = 0) public int runAttemptCount; @ColumnInfo(name = \u0026#34;backoff_policy\u0026#34;) @NonNull public BackoffPolicy backoffPolicy = BackoffPolicy.EXPONENTIAL; @ColumnInfo(name = \u0026#34;backoff_delay_duration\u0026#34;) public long backoffDelayDuration = WorkRequest.DEFAULT_BACKOFF_DELAY_MILLIS; }   在创建任务的时候, 每个任务会:\n 分配一个 uuid 创建一个 WorkSpec 添加 Worker 的类名为 tag 一次性任务设置 inputMergerClassName 周期任务设置周期执行的间隔时间  提交任务 看下第一个问题: 如何确保任务一定会被执行, 即使在应用重启或手机重启之后.\n在应用重启或手机重启之后依然能执行提交的任务, 那说明任务肯定需要存储到磁盘的. 看流程图中也能看出有数据库的参与, 带着这个猜想看下源码. 任务的提交从调用 enqueue 开始:\n1 2  WorkManager.getInstance(context).enqueue(request); // getInstance 返回的是 WorkManagerImpl 单列对象   1 2 3 4 5 6 7 8  //WorkManager#enqueue(WorkRequest) public final Operation enqueue(@NonNull WorkRequest workRequest) { // 单个 workReeust 会被装到 List 中, 后续方法都接收 List\u0026lt;WorkReuest\u0026gt;  return enqueue(Collections.singletonList(workRequest)); } //最终调用到抽象方法 enqueue, 也就是调用 WorkManagerImpl 的实现 public abstract Operation enqueue(@NonNull List\u0026lt;? extends WorkRequest\u0026gt; requests);   1 2 3 4 5 6 7 8  //WorkManagerImpl#enqueue public Operation enqueue(List\u0026lt;? extends WorkRequest\u0026gt; workRequests) { if (workRequests.isEmpty()) { throw new IllegalArgumentException(\u0026#34;enqueue needs at least one WorkRequest.\u0026#34;); } // 后续工作交给 WorkContinuationImpl  return new WorkContinuationImpl(this, workRequests).enqueue(); }   1 2 3 4 5 6 7 8 9 10 11 12 13  //WorkContinuationImpl#enqueue public Operation enqueue() { // 防止重复提交, mEnqueued 会在 EnqueueRunnable 中被标记为 true  if (!mEnqueued) { EnqueueRunnable runnable = new EnqueueRunnable(this); // EnqueueRunnable 被提交到线程池执行  mWorkManagerImpl.getWorkTaskExecutor().executeOnBackgroundThread(runnable); mOperation = runnable.getOperation(); } else { Logger.get().warning(TAG, String.format(\u0026#34;Already enqueued work ids (%s)\u0026#34;, TextUtils.join(\u0026#34;, \u0026#34;, mIds))); } return mOperation; }   EnqueueRunnable 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //EnqueueRunnable#run public void run() { try { // 判断 Worker 是否有循环引用  if (mWorkContinuation.hasCycles()) { throw new IllegalStateException(String.format(\u0026#34;WorkContinuation has cycles (%s)\u0026#34;, mWorkContinuation)); } // 储存到数据库, 并返回是否需要执行  boolean needsScheduling = addToDatabase(); if (needsScheduling) { // 需要执行:  // 启用 RescheduleReceiver: 一个广播接收器  final Context context = mWorkContinuation.getWorkManagerImpl().getApplicationContext(); PackageManagerHelper.setComponentEnabled(context, RescheduleReceiver.class, true); // 在后台执行 work  scheduleWorkInBackground(); } mOperation.setState(Operation.SUCCESS); } catch (Throwable exception) { mOperation.setState(new Operation.State.FAILURE(exception)); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //EnqueueRunnable#addToDatabase public boolean addToDatabase() { WorkManagerImpl workManagerImpl = mWorkContinuation.getWorkManagerImpl(); WorkDatabase workDatabase = workManagerImpl.getWorkDatabase(); // 开始一个事务  workDatabase.beginTransaction(); try { boolean needsScheduling = processContinuation(mWorkContinuation); workDatabase.setTransactionSuccessful(); return needsScheduling; } finally { // 关闭事务  workDatabase.endTransaction(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  // addToDatabase 经过几个调用 // EnqueueRunnable#processContinuation // EnqueueRunnable#enqueueContinuation // 最终会走到: EnqueueRunnable#enqueueWorkWithPrerequisites private static boolean enqueueWorkWithPrerequisites( WorkManagerImpl workManagerImpl, @NonNull List\u0026lt;? extends WorkRequest\u0026gt; workList, String[] prerequisiteIds, String name, ExistingWorkPolicy existingWorkPolicy) { boolean needsScheduling = false; // prerequisiteIds 这里会为空, 与 WorkContinuation 的构造函数的 parent 参数有关  //...  for (WorkRequest work : workList) { // 获取 WorkRequest 中的 WorkSpec  WorkSpec workSpec = work.getWorkSpec(); if (hasPrerequisite \u0026amp;\u0026amp; !hasCompletedAllPrerequisites) { //...  } else { if (!workSpec.isPeriodic()) { // 如果是周期任务, 则将周期执行的开始时间设为当前时间  workSpec.periodStartTime = currentTimeMillis; } else { workSpec.periodStartTime = 0L; } } // 在 Api 23~35 将带有电量和存储空间约束的 Worker 代理给 ConstraintTrackingWorker  if (Build.VERSION.SDK_INT \u0026gt;= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL \u0026amp;\u0026amp; Build.VERSION.SDK_INT \u0026lt;= 25) { tryDelegateConstrainedWorkSpec(workSpec); } else if (Build.VERSION.SDK_INT \u0026lt;= WorkManagerImpl.MAX_PRE_JOB_SCHEDULER_API_LEVEL \u0026amp;\u0026amp; usesScheduler(workManagerImpl, Schedulers.GCM_SCHEDULER)) { tryDelegateConstrainedWorkSpec(workSpec); } if (workSpec.state == ENQUEUED) { needsScheduling = true; } // 将 WorkSpace 插入到 WorkSpec 表  workDatabase.workSpecDao().insertWorkSpec(workSpec); for (String tag : work.getTags()) { // 将 tag 和 worker 的 uuid 绑定, 插入到 WorkTag 表  workDatabase.workTagDao().insert(new WorkTag(tag, work.getStringId())); } if (isNamed) { // 如果是命名 Worker, 将 name 和 worker 的 uuid 绑定, 插入到 WorkName 表  workDatabase.workNameDao().insert(new WorkName(name, work.getStringId())); } } return needsScheduling; }      DB 表 WorkSpec WorkTag           整体流程图 执行任务 //TODO\n","description":"最近使用 Android Jetpack 中 WorkManager 组件做了一个上报一些做分析用途数据的需求, 用着感觉挺香的. 于是想看下其内部的实现原理.","id":30,"section":"posts","tags":null,"title":"理解 WorkManager 的实现","uri":"https://jiyang.site/posts/2019-12-07-%E7%90%86%E8%A7%A3-workmanager-%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"content":"给定一个由 \u0026lsquo;1\u0026rsquo;（陆地）和 \u0026lsquo;0\u0026rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围\n问题 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围.\n输入: 11110 11010 11000 00000 输出: 1 输入: 11000 11000 00100 00011 输出: 3 思考 由题意可知: 如果二维网格中的一系列 1 是连续不间断的, 则说明他们是一个岛屿. 所以可以计数一个 1 节点能到达的所有节点, 能到达的 1 节点都属于同一个岛屿, 在查找路径过程中如果遇到了 0 则代表走到了岛屿边界, 结束该节点的路径查找, 继续找下一个没有被访问过 1 节点作为查找的起点.\n综上, 可使用 BFS 思想, 以一个 1 节点为起点, 找到该节点能到达的所有路径, 这些路径便组成了一个岛. 下一次查找则需要从一个没有被访问过的 1 节点开始, 所以需要把在上一条路径上的出现过点都标记为已访问, 避免后续找其他岛时从之前的岛的节点上开始.\n方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94  class Solution { // 从每个节点开始 BFS 遍历, 直到遇到 0 结束. BFS 会遍历完与一个节点相连的所有节点, 同时要保证一个节点只会被访问1次(通过将节点记为 0 表示已经访问过)  public int numIslands(char[][] grid) { if(grid==null || grid.length == 0) { return 0; } int m = grid.length; int n = grid[0].length; int count = 0; // 上下左右邻居与当前节点的索引的差值  int[][] neiber = {{-1,0}, {1,0}, {0,-1}, {0,1}}; for(int i=0; i\u0026lt; m; i++) { for (int j=0; j\u0026lt;grid[i].length; j++) { // 遇到 0 节点不用访问  if(grid[i][j] == \u0026#39;0\u0026#39;){ continue; } count ++; Deque\u0026lt;Integer\u0026gt; que = new ArrayDeque(); que.add(i*n+j); while(!que.isEmpty()) { int cur = que.pop(); int row = cur/n; int column = cur%n; // System.out.println(\u0026#34;v:\u0026#34; + row+\u0026#34;,\u0026#34;+ column);  // 代替下面注释的添加邻居的代码  for(int k=0; k\u0026lt; neiber.length; k++){ int r = neiber[k][0] + row; int col = neiber[k][1] + column; if(r \u0026gt; -1 \u0026amp;\u0026amp; r \u0026lt; grid.length \u0026amp;\u0026amp; col \u0026gt; -1 \u0026amp;\u0026amp; col \u0026lt; grid[row].length \u0026amp;\u0026amp; grid[r][col] != \u0026#39;0\u0026#39;) { que.add(r*n+col); grid[r][col] = \u0026#39;0\u0026#39;; // 标记为已访问, 避免重复添加  // System.out.println(\u0026#34;enque:\u0026#34; + r + \u0026#34;,\u0026#34; + col);  } } /* // 添加邻居 if(row-1 \u0026gt; -1) { int c = (row-1)*n+column; char item = grid[row-1][column]; if(item != \u0026#39;0\u0026#39;){ que.add(c); // 避免重复添加 grid[row-1][column] = \u0026#39;0\u0026#39;; System.out.println(\u0026#34;enque:\u0026#34; + (row-1) + \u0026#34;,\u0026#34; + column); } } if(column-1 \u0026gt; -1 ){ int c = row*n+column-1; char item = grid[row][column-1]; if(item != \u0026#39;0\u0026#39;){ que.add(c); // 避免重复添加 grid[row][column-1] = \u0026#39;0\u0026#39;; System.out.println(\u0026#34;enque:\u0026#34; + row + \u0026#34;,\u0026#34; + (column-1)); } } if(row+1 \u0026lt; grid.length) { int c = (row+1)*n+column; char item = grid[row+1][column]; if(item != \u0026#39;0\u0026#39;){ que.add(c); // 避免重复添加 grid[row+1][column] = \u0026#39;0\u0026#39;; System.out.println(\u0026#34;enque:\u0026#34; + (row+1) + \u0026#34;,\u0026#34; + column); } } if(column+1 \u0026lt; grid[row].length) { int c = row*n+column+1; char item = grid[row][column+1]; if(item != \u0026#39;0\u0026#39;){ que.add(c); // 避免重复添加 grid[row][column+1] = \u0026#39;0\u0026#39;; System.out.println(\u0026#34;enque:\u0026#34; + row + \u0026#34;,\u0026#34; + (column+1)); } } */ } } } return count; } }   ","description":"给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围","id":31,"section":"posts","tags":["BFS"],"title":"岛屿数量","uri":"https://jiyang.site/posts/2019-12-03-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"content":"之前看过的 BFS(Breadth First Search), 最近遇到类似问题时却没有想起. 在此再回顾一下, 并留下记录. 好记性毕竟不如坏笔头.\n来由 在一些图的问题中, 经常遇到查找最长或最短路径、节点是否可达等与路径相关的问题时都可以结合 BFS 算法找到解决方法.\n理念 BFS 的理念如其姓名, 广度优先又可以看作树里的层序遍历, 以 广度优先 的方式遍历整个图也就是按层优先的方式遍历, 找到符合条件的节点.\n实现广度优先搜索, 需要结合队列实现层序遍历的顺序, 即优先遍历同一层节点, 下层的节点需要等上一层遍历完了再遍历.\n例子    查找 A -\u0026gt; H 的最短路径 流程     H的最短路径\" /     搜索过程    当前队列 匹配情况     A A != H, 追加 A 的下层   B G C B != H, 追加 B 的下层   G C D G != H, 追加 G 的下层   C D H C != H, 追加 C 的下层   D H E D != H, 追加 D 的下层   H E F H == H, 满足条件, 搜索结束    总结 BFS 算法不仅用在图的问题上, 其他类似路径的问题也能转化为图的问题. 比如查找二叉树中两个节点的最长或最短路径问题等.\n还需要注意如果一个节点同时被多个节点指向, 需要做去重处理.\n","description":"之前看过的 BFS(Breadth First Search), 最近遇到类似问题时却没有想起. 在此再回顾一下, 并留下记录. 好记性毕竟不如坏笔头.","id":32,"section":"posts","tags":["BFS"],"title":"BFS 广度优先搜索","uri":"https://jiyang.site/posts/2019-11-30-bfs-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"content":"理清 Java 和 Android 的线程异常处理\n问题 先看两个问题:\n 在一个纯 Java 程序(没有任何其他框架)中如果在非主线程发生了一个未捕获的异常, 整个程序会 crash 吗? 如果在 Android 中发生同样的情况, app 会 crash 吗?  测试 Java 1 2 3 4 5 6 7 8 9 10 11 12  public static void main(String[] args) { System.out.println(\u0026#34;A\u0026#34;); new Thread() { @Override public void run() { Object o = null; System.out.println(o.toString()); } }.start(); Thread.sleep(500); System.out.println(\u0026#34;B\u0026#34;); }   输出:\nA Exception in thread \u0026quot;Thread-0\u0026quot; java.lang.NullPointerException at Test$1.run(Test.java:12) B 可以看到在没有单独设置 UncaughtExceptionHandler 时, 非主线程出现了异常也不会阻断主线程的运行, 只是输出了异常.\nAndroid 1 2 3 4 5 6 7 8 9 10 11 12 13 14  protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;A\u0026#34;); new Thread() { @Override public void run() { Object o = null; Log.d(\u0026#34;TAG\u0026#34;, o.toString()); } }.start(); // 这里为了节目效果, 休眠了 500 毫秒  Thread.sleep(500); Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;B\u0026#34;); }   输出:\nD/TAG: A E/AndroidRuntime: FATAL EXCEPTION: Thread-2 Process: io.github.stefanji.playground, PID: 4815 java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.String java.lang.Object.toString()' on a null object reference at ExceptionTest$1.run(ExceptionTest.java:22) 结果运行到这里 App 直接 Crash 了.\n 测试表明 Android 在线程的异常处理上与 Java 默认上是有区别的\n Java 异常处理 Java 默认的异常处理机制流程如下图:\n当一个线程抛出异常时, JVM 会调用线程的 dispatchUncaughtException 方法, 如果线程有设置 UncaughtExceptionHandler 则会调用设置的 Handler 处理; 否则判断 parent ThreadGroup 是否存在, 如果存在则调用 parent 的 uncaughtException 方法, 否则判断是否设置过全局的 defaultUncaughtExceptionHandler, 如果设置过就调用全局的 Handler 处理; 否则就只输出.\nAndroid 异常处理 讲道理, Android 应用层是基于 Java 的, 应该沿袭 Java 的处理机制的. 但是它却直接 Crash 了, 说明它单独设置了全局 Handler 或者为每个线程设置了 Handler. 为每个线程单独设置应该不大可能, 应用中那么多开发者自己创建的线程. 看来只有设置全局的 Handler 这条路了.\n那 Android 是在哪里设置的呢? =_= 搜索大法: 在 SDK 源码中搜索 Crash 时输出的日志 E/AndroidRuntime: FATAL EXCEPTION: Thread-2....\n在 Android-28 com/android/internal/os/RuntimeInit.java 中发现了踪影:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  private static class LoggingHandler implements Thread.UncaughtExceptionHandler { public volatile boolean mTriggered = false; @Override public void uncaughtException(Thread t, Throwable e) { mTriggered = true; // Don\u0026#39;t re-enter if KillApplicationHandler has already run  if (mCrashing) return; // 系统进程异常  if (mApplicationObject == null \u0026amp;\u0026amp; (Process.SYSTEM_UID == Process.myUid())) { Clog_e(TAG, \u0026#34;*** FATAL EXCEPTION IN SYSTEM PROCESS: \u0026#34; + t.getName(), e); } else { StringBuilder message = new StringBuilder(); // The \u0026#34;FATAL EXCEPTION\u0026#34; string is still used on Android even though  // apps can set a custom UncaughtExceptionHandler that renders uncaught  // exceptions non-fatal.  // 下面刚好能匹配到应用 Crash 时的日志  message.append(\u0026#34;FATAL EXCEPTION: \u0026#34;).append(t.getName()).append(\u0026#34;\\n\u0026#34;); final String processName = ActivityThread.currentProcessName(); if (processName != null) { message.append(\u0026#34;Process: \u0026#34;).append(processName).append(\u0026#34;, \u0026#34;); } message.append(\u0026#34;PID: \u0026#34;).append(Process.myPid()); Clog_e(TAG, message.toString(), e); } } }   在 LogingHandler 里只看的日志的的输出, 没有应用 Crash 相关的. 再接着看 LogingHandler 在哪里使用的, 在 RuntimeInit.java 中搜索发现在 RuntimeInit 的一个私有内部类 KillApplicationHandler 中使用了:\n1 2 3 4 5 6 7  private static class KillApplicationHandler implements Thread.UncaughtExceptionHandler { private final LoggingHandler mLoggingHandler; public KillApplicationHandler(LoggingHandler loggingHandler) { this.mLoggingHandler = Objects.requireNonNull(loggingHandler); } }   KillApplicationHandler 又是在 commonInit 类方法中创建, 然后设置为线程的全局 ExceptionHandler.\n1 2 3 4 5 6 7 8 9 10 11 12  protected static final void commonInit() { /* * set handlers; these apply to all threads in the VM. Apps can replace * the default handler, but not the pre handler. */ LoggingHandler loggingHandler = new LoggingHandler(); // setUncaughtExceptionPreHandler 这个方法 Thread 里没有呀?  Thread.setUncaughtExceptionPreHandler(loggingHandler); // KillApplicationHandler 作为全局 Handler  Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); //... }   commonInit 是在 RuntimeInit.java 的静态 main 方法中被调用.\n而 RuntimeInit 的入口方法(main) 会在 zygote 创建新的应用进程之后被调用. 所以 KillApplicationHandler 是在应用进程启动以后就设置的. 如果我们没有单独设置过全局的 DefaultUncaughtExceptionHandler, 那么应用中任何线程出现了未捕获的异常, 且发生异常的线程没有设置过 UnCaughtExceptionHandler 时, 异常就会走到 KillApplicationHandler 的 uncaughtException 方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public void uncaughtException(Thread t, Throwable e) { try { // 调用 loggingHandler 输出日志  ensureLogging(t, e); // Don\u0026#39;t re-enter -- avoid infinite loops if crash-reporting crashes.  // 已经在 crash 中时, 就不再处理了  if (mCrashing) return; mCrashing = true; //...  } catch (Throwable t2) { if (t2 instanceof DeadObjectException) { // System process is dead; ignore  } else { try { Clog_e(TAG, \u0026#34;Error reporting crash\u0026#34;, t2); } catch (Throwable t3) { // Even Clog_e() fails! Oh well.  } } } finally { // 通知内核杀掉应用进程  Process.killProcess(Process.myPid()); // 停止 VM  System.exit(10); } }   总结 Android 应用之所以遇到非主线程抛出的未捕获异常也会 Crash 的原因是, 在应用进程被创建之后, RuntimeInit 就为线程设置 KillApplicationHandler 为全局的 UncaughtExceptionHandler. KillApplicationHandler 的处理机制是先输出异常日志, 然后杀掉应用进程.\n延伸 有时当应用发生异常 crash 之后, 应用自己又自动重启了. 这又是为什么?\n参考  https://blog.csdn.net/gaojinshan/article/details/52870739 ","description":"理清 Java 和 Android 的线程异常处理","id":33,"section":"posts","tags":null,"title":"Java 和 Android 的异常处理流程","uri":"https://jiyang.site/posts/2019-11-22-java-%E5%92%8C-android-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"content":"设计一个方法, 把一个数组随机打乱, 每一个元素不能在原来的位置上\n目的  设计一个方法, 把一个数组随机打乱, 每一个元素不能在原来的位置上\n 输入: [1, 2, 3, 4, 5, 6]\n输出:\n[2, 3, 4, 5, 6, 1] [6, 4, 2, 3, 1, 5] [5, 1, 4, 6, 3, 2] 想到的解决方法: 遍历数组(长度为len), 将当前元素(下标i)和它后面([i+1, len])的随机的一个位置交换即可. 但是 Java 的 Random().nextInt(bound) 生成的随机数区间是 [0, bound), 我期望的随机数区间是 [i, bound]. 所以难点在于让生成的随机数位于指定的区间.\n经过搜索发现, 生成指定区间的随机数的公式:\n1 2 3 4  /** [0, max) % (max - min + 1) + min =\u0026gt; [min, max] */ new Random().nextInt(max) % (max - min + 1) + min;   实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14  void random(int[] arr) { if (arr == null) { throw new NullPointerException(); } int len = arr.length; for (int i = 0; i \u0026lt; len - 1; i++) { int min = i + 1; int max = len - 1; int r = new Random().nextInt(max) % (max - min + 1) + min; int tem = arr[i]; arr[i] = arr[r]; arr[r] = tem; } }   更新 上面说的 Random 区间问题, 在其他地方看到可以从尾到头遍历数组, 这样每次需要的随机数区间就变成 [0, i) 了, 不需要再做上面求 [i, bound] 随机区间的操作. 感觉妙呀 🐱\n1 2 3 4 5 6 7 8 9 10 11 12  void random(int[] arr) { if (arr == null) { throw new NullPointerException(); } int len = arr.length; for (int i = len-1; i \u0026gt; -1; i--) { int r = new Random().nextInt(i+1); // 生成 [0, i) 区间内的随机数  int tem = arr[i]; arr[i] = arr[r]; arr[r] = tem; } }   ","description":"设计一个方法, 把一个数组随机打乱, 每一个元素不能在原来的位置上","id":34,"section":"posts","tags":null,"title":"洗牌-乱序一个数组","uri":"https://jiyang.site/posts/2019-11-21-%E6%B4%97%E7%89%8C-%E4%B9%B1%E5%BA%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/"},{"content":"理解 Fragment 的实现原理, FragmentTransaction 的事务机制等.\nFragment 的添加过程 使用如下代码:\n1 2 3 4 5 6 7  setOnClickListener { with(supportFragmentManager) { beginTransaction() .add(R.id.fragment_container, MFragment.newInstance()) .commit() } }   方法调用栈:\n通过看调用栈中绿色的分布也能大致看出, 整个过程分了两个步骤.\n 对 Fragment 的操作需要先在 Activity 获取 FragmentManager, 那 FragmentManager 是从哪里拿到的呢?\n FragmentManager 的创建 android.app.Activity 这个祖先类中的 getFragmentManager 方法已经 deprecated, 推荐我们用 android.support.v4.app.FragmentActivity#getSupportFragmentManager, 所以我们自己的 Activity 一般都继承了那些继承自 FragmentActivity 的 Activity(比如: AppCompatActivity).\nFragmentActivity  androidx.fragment.app.FragmentActivity\n FragmentActivity 的 getSupportFragmentManager:\n1 2 3 4  public FragmentManager getSupportFragmentManager() { // 调用 mFragments 的方法  return mFragments.getSupportFragmentManager(); }   mFragments 是 FragmentActivity 在内部构造的一个 FragmentController 类型的变量:\n1  final FragmentController mFragments = FragmentController.createController(new HostCallbacks());   FragmentController  androidx.fragment.app.FragmentController\n 1 2 3 4 5 6 7 8 9 10 11 12  public static FragmentController createController(FragmentHostCallback\u0026lt;?\u0026gt; callbacks) { return new FragmentController(callbacks); } private FragmentController(FragmentHostCallback\u0026lt;?\u0026gt; callbacks) { mHost = callbacks; } // FragmentController 的 getSupportFragmentManager 方法是调用的其构造时传入的 callbacks FragmentManager getSupportFragmentManager() { return mHost.mFragmentManager; }   查看 FragmentController 内部的其他方法, 最后都是代理给 mHost 执行了. mHost 就是 FragmentActivity 在创建 FragmentController 时传入的 HostCallbacks.\nHostCallbacks 是 FragmentActivity 的一个内部类, 其继承了 FragmentHostCallback:\nHostCallbacks  androidx.fragment.app.FragmentActivity.HostCallbacks\n 1 2 3 4 5  class HostCallbacks extends FragmentHostCallback\u0026lt;FragmentActivity\u0026gt; implements ViewModelStoreOwner, OnBackPressedDispatcherOwner { public HostCallbacks() { super(FragmentActivity.this /*fragmentActivity*/); } }    androidx.fragment.app.FragmentHostCallback\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public abstract class FragmentHostCallback\u0026lt;E\u0026gt; extends FragmentContainer { private final Activity mActivity; private final Context mContext; private final Handler mHandler; private final int mWindowAnimations; // 创建 FragmentManager, 使用的是 FragmentManagerImpl  final FragmentManager mFragmentManager = new FragmentManagerImpl(); // HostCallbacks 中调用的是这个构造函数  FragmentHostCallback(FragmentActivity activity) { this(activity, activity /*context*/, new Handler(), 0 /*windowAnimations*/); } FragmentHostCallback(Activity activity,Context context, Handler handler, int windowAnimations) { mActivity = activity; mContext = context; mHandler = handler; mWindowAnimations = windowAnimations; } }   FragmentManagerImpl  androidx.fragment.app.FragmentManagerImpl\n FragmentManagerImpl 继承了 FragmentManager, 自己没有特别的实现\n1 2  class FragmentManagerImpl extends FragmentManager { }   一图胜千言 至此, FragmentManager 的创建过程梳理结束, FragmentActivity 在创建时会创建一个 HostCallbacks 和 FragmentController, HostCallbacks 会在创建时创建 FragmentManager. FragmentController 会持有 HostCallbacks 对象的引用, 调用 FragmentController 的方法内部都将调用 HostCallbacks 对应的方法.\n放大上面大图左侧的部分, 可以看add 和 commit 两个操作的调用栈:\nadd 过程 整体调用栈:\nFragmentManager: beginTransaction BackStackRecord: add -\u0026gt; doAddOp FragmentTransaction: doAddOp -\u0026gt; addOp 首先, FragmentManger 的 beginTransaction 方法返回了一个 BackStackRecord 对象\n1 2 3  public FragmentTransaction beginTransaction() { return new BackStackRecord(this); }   BackStackRecord  androidx.fragment.app.BackStackRecord\n BackStackRecord 类继承自 FragmentTransaction, FragmentTransaction 是一个抽象类\n1 2 3 4  // 构造函数 public BackStackRecord(FragmentManagerImpl manager) { mManager = manager; }   比如调用 add(R.id.fragment_container, MFragment.newInstance())\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // BackStackRecord 中没有实现该方法, 所以会调用父类 FragmentTransaction 的 add public FragmentTransaction add(@IdRes int containerViewId, @NonNull Fragment fragment) { doAddOp(containerViewId, fragment, null, OP_ADD); return this; } // OP_ADD 是在 FragmentTransaction 中定义的一个常量, 看样子后面会用到**命令模式**. // 其他类似常量 int OP_NULL = 0; int OP_ADD = 1; int OP_REPLACE = 2; int OP_REMOVE = 3; int OP_HIDE = 4; int OP_SHOW = 5; int OP_DETACH = 6; int OP_ATTACH = 7; int OP_SET_PRIMARY_NAV = 8; int OP_UNSET_PRIMARY_NAV = 9; int OP_SET_MAX_LIFECYCLE = 10;   接着 doAddOp:\n1 2 3 4 5 6 7  // BackStackRecord 复写了 doAddOp, 所以会调用 BackStackRecord 自己实现的 doAddOp void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) { // 调用父类的 doAddOp  super.doAddOp(containerViewId, fragment, tag, opcmd); // 可见 Fragment 的 FragmentManager 是在这一步赋值的  fragment.mFragmentManager = mManager; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // FragmentTransaction 的 doAddOp void doAddOp(int containerViewId, Fragment fragment, @Nullable String tag, int opcmd) { final Class\u0026lt;?\u0026gt; fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); // 如果 fragment: 是匿名类 || 不是 public || 是内部类但不是静态的, 则抛出异常  if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() \u0026amp;\u0026amp; !Modifier.isStatic(modifiers))) { throw new IllegalStateException(\u0026#34;Fragment \u0026#34; + fragmentClass.getCanonicalName() + \u0026#34;...\u0026#34;); } if (tag != null) { // fragment 的 tag 指定之后不能修改  if (fragment.mTag != null \u0026amp;\u0026amp; !tag.equals(fragment.mTag)) { throw new IllegalStateException(\u0026#34;Can\u0026#39;t change tag of fragment\u0026#34;); } fragment.mTag = tag; } if (containerViewId != 0) { if (containerViewId == View.NO_ID) { throw new IllegalArgumentException(\u0026#34;Can\u0026#39;t add fragment to container view with no id\u0026#34;); } if (fragment.mFragmentId != 0 \u0026amp;\u0026amp; fragment.mFragmentId != containerViewId) { throw new IllegalStateException(\u0026#34;Can\u0026#39;t change container ID of fragment ...\u0026#34;); } fragment.mContainerId = fragment.mFragmentId = containerViewId; } // 构造一个 Op, 然后调用 addOp  addOp(new Op(opcmd, fragment)); }   1 2 3 4 5 6 7 8 9 10  // FragmentTransaction addOp void addOp(Op op) { // 将 op 添加到 mOps 中  // mOps: 类型为 ArrayList\u0026lt;Op\u0026gt;, FragmentTransaction 的一个成员变量  mOps.add(op); op.mEnterAnim = mEnterAnim; op.mExitAnim = mExitAnim; op.mPopEnterAnim = mPopEnterAnim; op.mPopExitAnim = mPopExitAnim; }   一图胜千言 至此, add 调用过程结束, 会在 BackStackRecord 的 mOps 数组中添加一条 Op 记录, Op 记录着这次操作的命令(mCmd)和操作的 Fragment(mFragnment).\ncommit 过程 整体调用栈:\nBackStackRecord: commit -\u0026gt; commitInternal FragmentManager: enqueueAction -\u0026gt; scheduleCommit HostCallBacks: getHandler.post BackStackRecord  androidx.fragment.app.BackStackRecord#commit\n 1 2 3 4  public int commit() { // 参数为: boolean allowStateLoss  return commitInternal(false); }   enqueueAction  androidx.fragment.app.BackStackRecord#commitInternal\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  int commitInternal(boolean allowStateLoss) { if (mCommitted) throw new IllegalStateException(\u0026#34;commit already called\u0026#34;); mCommitted = true; // 如果在 commit 调用之前调用了 FragmentTransaction 的 addToBackStack, mAddToBackStack 就是 true, 否则 false  if (mAddToBackStack) { mIndex = mManager.allocBackStackIndex(); } else { mIndex = -1; } // FragmentManager#enququeAction  // 第一个参数是 OpGenerator 类型  mManager.enqueueAction(this, allowStateLoss); return mIndex; }   BackStackRecord 实现了 OpGenrator 接口:\n1 2 3 4 5 6 7 8 9 10 11 12  // 实现了 OpGenrator 接口的 generateOps 方法 public boolean generateOps(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isRecordPop) { // 将自己添加到 records 数组中  records.add(this); isRecordPop.add(false); // 如果调用了 addToBackStack(), mAddToBackStack 就为 true  if (mAddToBackStack) { // 将自己添加到 FragmentManager 的 mBackStack 数组中  mManager.addBackStackState(this); } return true; }   FragmentManager  androidx.fragment.app.FragmentManager#enqueueAction\n 1 2 3 4 5 6 7 8 9 10  void enqueueAction(OpGenerator action, boolean allowStateLoss) { //...  synchronized (mPendingActions) { //...  // 添加到等待队列中  // mPendingActions: ArrayList\u0026lt;OpGenerator\u0026gt;  mPendingActions.add(action); scheduleCommit(); } }    androidx.fragment.app.FragmentManager#scheduleCommit\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  void scheduleCommit() { synchronized (mPendingActions) { boolean postponeReady = mPostponedTransactions != null \u0026amp;\u0026amp; !mPostponedTransactions.isEmpty(); // 一次只能提交一个 OpGenerator(BackStackRecord), 上面在 commit 里会通过 mCommitted 标志做过滤  boolean pendingReady = mPendingActions.size() == 1; if (postponeReady || pendingReady) { // mExecCommit: Runnable  // 通过 Handler 向主线程 Looper 中发消息. 当消息被消费时, 会执行 mExecCommit  mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); updateOnBackPressedCallbackEnabled(); } } }   commit 调用之后, mExecCommit 这个 Runnable 就作为一个 Message 的 callback 插入到主线程 MessageQueue 中, 之后 mExecCommit 会从消息池中取出, 然后执行:\n1 2 3 4 5 6  private Runnable mExecCommit = new Runnable() { @Override public void run() { execPendingActions(true); } };   execPendingActions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  boolean execPendingActions(boolean allowStateLoss) { ensureExecReady(allowStateLoss); boolean didSomething = false; // 生成待处理操作  while (generateOpsForPendingActions(mTmpRecords, mTmpIsPop)) { mExecutingActions = true; try { // 删除冗余操作并执行  removeRedundantOperationsAndExecute(mTmpRecords, mTmpIsPop); } finally { cleanupExec(); } didSomething = true; } updateOnBackPressedCallbackEnabled(); doPendingDeferredStart(); burpActive(); return didSomething; } private void cleanupExec() { mExecutingActions = false; mTmpIsPop.clear(); mTmpRecords.clear(); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  private boolean generateOpsForPendingActions(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isPop) { boolean didSomething = false; synchronized (mPendingActions) { if (mPendingActions.isEmpty()) { return false; } final int numActions = mPendingActions.size(); for (int i = 0; i \u0026lt; numActions; i++) { // 将 mPendingActions 中的 actions, 通过调用 BackStackRecord 的 generateOps, 依次转移到 records  didSomething |= mPendingActions.get(i).generateOps(records, isPop); } // 转移完成之后, 清空 mPendingActions  mPendingActions.clear(); // 执行完成之后, 移除 handler 中的回调  mHost.getHandler().removeCallbacks(mExecCommit); } return didSomething; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private void removeRedundantOperationsAndExecute(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isRecordPop) { //...  // Force start of any postponed transactions that interact with scheduled transactions:  executePostponedTransaction(records, isRecordPop); final int numRecords = records.size(); int startIndex = 0; for (int recordNum = 0; recordNum \u0026lt; numRecords; recordNum++) { // mReorderingAllowed: 可以通过 FragmentTransaction 的 setReorderingAllowed 设置为 ture  final boolean canReorder = records.get(recordNum).mReorderingAllowed; // 默认 false  if (!canReorder) { // ...  executeOpsTogether(records, isRecordPop, recordNum, reorderingEnd); startIndex = reorderingEnd; recordNum = reorderingEnd - 1; } } // ... }   1 2 3 4 5 6  private void executeOpsTogether(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isRecordPop, int startIndex, int endIndex) { // ...  executeOps(records, isRecordPop, startIndex, endIndex); // ... }   executeOps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private static void executeOps(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isRecordPop, int startIndex, int endIndex) { for (int i = startIndex; i \u0026lt; endIndex; i++) { final BackStackRecord record = records.get(i); final boolean isPop = isRecordPop.get(i); // 这里是 add 操作, isPop 为 false  if (isPop) { record.bumpBackStackNesting(-1); boolean moveToState = i == (endIndex - 1); record.executePopOps(moveToState); } else { // BackStackRecord#bumpBackStackNesting  record.bumpBackStackNesting(1); // BackStackRecord#executeOps  record.executeOps(); } } }   回到 BackStackRecord:\n androidx.fragment.app.BackStackRecord#executeOps\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  void executeOps() { final int numOps = mOps.size(); for (int opNum = 0; opNum \u0026lt; numOps; opNum++) { final Op op = mOps.get(opNum); final Fragment f = op.fragment; if (f != null) { f.setNextTransition(mTransition, mTransitionStyle); } // 执行不同命令  switch (op.cmd) { case OP_ADD: f.setNextAnim(op.enterAnim); mManager.addFragment(f, false); break; case OP_REMOVE: //...  case OP_HIDE: //...  case OP_SHOW: //...  case OP_DETACH: //...  case OP_ATTACH: //...  } } if (!mReorderingAllowed) { // 将 Fragment 切到当前状态  mManager.moveToState(mManager.mCurState, true); } }   addFragment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public void addFragment(Fragment fragment, boolean moveToStateNow) { if (DEBUG) Log.v(TAG, \u0026#34;add: \u0026#34; + fragment); makeActive(fragment); if (!fragment.mDetached) { // 不能重复添加同一个 Fragment  if (mAdded.contains(fragment)) { throw new IllegalStateException(\u0026#34;Fragment already added: \u0026#34; + fragment); } synchronized (mAdded) { // Fragment 添加到 mAdded 数组中  mAdded.add(fragment); } fragment.mAdded = true; fragment.mRemoving = false; if (fragment.mView == null) { fragment.mHiddenChanged = false; } if (moveToStateNow) { moveToState(fragment); } } }   makeActive 1 2 3 4 5 6 7 8 9 10 11 12  void makeActive(Fragment f) { // Fragment 的 mIndex 变量初始值为 -1  if (f.mIndex \u0026gt;= 0) { return; } f.setIndex(mNextFragmentIndex++, mParent); if (mActive == null) { mActive = new SparseArray\u0026lt;\u0026gt;(); } // Fragment 添加到 mActive Map 中  mActive.put(f.mIndex, f); }   moveToState 1 2 3 4 5 6 7 8 9 10 11 12  void moveToState(int newState, boolean always) { //...  mCurState = newState; if (mActive != null) { final int numAdded = mAdded.size(); for (int i = 0; i \u0026lt; numAdded; i++) { Fragment f = mAdded.get(i); moveFragmentToExpectedState(f); } //...  } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void moveFragmentToExpectedState(Fragment f) { if (f == null) { return; } int nextState = mCurState; // addFragment 时, f.mRemoving 赋值为 false  if (f.mRemoving) { if (f.isInBackStack()) { nextState = Math.min(nextState, Fragment.CREATED); } else { nextState = Math.min(nextState, Fragment.INITIALIZING); } } // 真正开始切换状态  moveToState(f, nextState, f.getNextTransition(), f.getNextTransitionStyle(), false); //... }   moveState 方法有300行代码 🤦‍♂️\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301  void moveToState(Fragment f, int newState, int transit, int transitionStyle, boolean keepActive) { // Fragments that are not currently added will sit in the onCreate() state.  if ((!f.mAdded || f.mDetached) \u0026amp;\u0026amp; newState \u0026gt; Fragment.CREATED) { newState = Fragment.CREATED; } if (f.mRemoving \u0026amp;\u0026amp; newState \u0026gt; f.mState) { if (f.mState == Fragment.INITIALIZING \u0026amp;\u0026amp; f.isInBackStack()) { // Allow the fragment to be created so that it can be saved later.  newState = Fragment.CREATED; } else { // While removing a fragment, we can\u0026#39;t change it to a higher state.  newState = f.mState; } } // Defer start if requested; don\u0026#39;t allow it to move to STARTED or higher  // if it\u0026#39;s not already started.  if (f.mDeferStart \u0026amp;\u0026amp; f.mState \u0026lt; Fragment.STARTED \u0026amp;\u0026amp; newState \u0026gt; Fragment.ACTIVITY_CREATED) { newState = Fragment.ACTIVITY_CREATED; } if (f.mState \u0026lt;= newState) { // For fragments that are created from a layout, when restoring from  // state we don\u0026#39;t want to allow them to be created until they are  // being reloaded from the layout.  if (f.mFromLayout \u0026amp;\u0026amp; !f.mInLayout) { return; } if (f.getAnimatingAway() != null || f.getAnimator() != null) { // The fragment is currently being animated... but! Now we  // want to move our state back up. Give up on waiting for the  // animation, move to whatever the final state should be once  // the animation is done, and then we can proceed from there.  f.setAnimatingAway(null); f.setAnimator(null); moveToState(f, f.getStateAfterAnimating(), 0, 0, true); } switch (f.mState) { case Fragment.INITIALIZING: if (newState \u0026gt; Fragment.INITIALIZING) { if (DEBUG) Log.v(TAG, \u0026#34;moveto CREATED: \u0026#34; + f); if (f.mSavedFragmentState != null) { f.mSavedFragmentState.setClassLoader(mHost.getContext() .getClassLoader()); f.mSavedViewState = f.mSavedFragmentState.getSparseParcelableArray( FragmentManagerImpl.VIEW_STATE_TAG); f.mTarget = getFragment(f.mSavedFragmentState, FragmentManagerImpl.TARGET_STATE_TAG); if (f.mTarget != null) { f.mTargetRequestCode = f.mSavedFragmentState.getInt( FragmentManagerImpl.TARGET_REQUEST_CODE_STATE_TAG, 0); } if (f.mSavedUserVisibleHint != null) { f.mUserVisibleHint = f.mSavedUserVisibleHint; f.mSavedUserVisibleHint = null; } else { f.mUserVisibleHint = f.mSavedFragmentState.getBoolean( FragmentManagerImpl.USER_VISIBLE_HINT_TAG, true); } if (!f.mUserVisibleHint) { f.mDeferStart = true; if (newState \u0026gt; Fragment.ACTIVITY_CREATED) { newState = Fragment.ACTIVITY_CREATED; } } } f.mHost = mHost; f.mParentFragment = mParent; f.mFragmentManager = mParent != null ? mParent.mChildFragmentManager : mHost.getFragmentManagerImpl(); // If we have a target fragment, push it along to at least CREATED  // so that this one can rely on it as an initialized dependency.  if (f.mTarget != null) { if (mActive.get(f.mTarget.mIndex) != f.mTarget) { throw new IllegalStateException(\u0026#34;Fragment \u0026#34; + f + \u0026#34; declared target fragment \u0026#34; + f.mTarget + \u0026#34; that does not belong to this FragmentManager!\u0026#34;); } if (f.mTarget.mState \u0026lt; Fragment.CREATED) { moveToState(f.mTarget, Fragment.CREATED, 0, 0, true); } } dispatchOnFragmentPreAttached(f, mHost.getContext(), false); f.mCalled = false; f.onAttach(mHost.getContext()); if (!f.mCalled) { throw new SuperNotCalledException(\u0026#34;Fragment \u0026#34; + f + \u0026#34; did not call through to super.onAttach()\u0026#34;); } if (f.mParentFragment == null) { mHost.onAttachFragment(f); } else { f.mParentFragment.onAttachFragment(f); } dispatchOnFragmentAttached(f, mHost.getContext(), false); if (!f.mIsCreated) { dispatchOnFragmentPreCreated(f, f.mSavedFragmentState, false); f.performCreate(f.mSavedFragmentState); dispatchOnFragmentCreated(f, f.mSavedFragmentState, false); } else { f.restoreChildFragmentState(f.mSavedFragmentState); f.mState = Fragment.CREATED; } f.mRetaining = false; } // fall through  case Fragment.CREATED: // This is outside the if statement below on purpose; we want this to run  // even if we do a moveToState from CREATED =\u0026gt; *, CREATED =\u0026gt; CREATED, and  // * =\u0026gt; CREATED as part of the case fallthrough above.  ensureInflatedFragmentView(f); if (newState \u0026gt; Fragment.CREATED) { if (DEBUG) Log.v(TAG, \u0026#34;moveto ACTIVITY_CREATED: \u0026#34; + f); if (!f.mFromLayout) { ViewGroup container = null; if (f.mContainerId != 0) { if (f.mContainerId == View.NO_ID) { throwException(new IllegalArgumentException( \u0026#34;Cannot create fragment \u0026#34; + f + \u0026#34; for a container view with no id\u0026#34;)); } container = (ViewGroup) mContainer.onFindViewById(f.mContainerId); if (container == null \u0026amp;\u0026amp; !f.mRestored) { String resName; try { resName = f.getResources().getResourceName(f.mContainerId); } catch (NotFoundException e) { resName = \u0026#34;unknown\u0026#34;; } throwException(new IllegalArgumentException( \u0026#34;No view found for id 0x\u0026#34; + Integer.toHexString(f.mContainerId) + \u0026#34; (\u0026#34; + resName + \u0026#34;) for fragment \u0026#34; + f)); } } f.mContainer = container; f.performCreateView(f.performGetLayoutInflater( f.mSavedFragmentState), container, f.mSavedFragmentState); if (f.mView != null) { f.mInnerView = f.mView; f.mView.setSaveFromParentEnabled(false); if (container != null) { container.addView(f.mView); } if (f.mHidden) { f.mView.setVisibility(View.GONE); } f.onViewCreated(f.mView, f.mSavedFragmentState); dispatchOnFragmentViewCreated(f, f.mView, f.mSavedFragmentState, false); // Only animate the view if it is visible. This is done after  // dispatchOnFragmentViewCreated in case visibility is changed  f.mIsNewlyAdded = (f.mView.getVisibility() == View.VISIBLE) \u0026amp;\u0026amp; f.mContainer != null; } else { f.mInnerView = null; } } f.performActivityCreated(f.mSavedFragmentState); dispatchOnFragmentActivityCreated(f, f.mSavedFragmentState, false); if (f.mView != null) { f.restoreViewState(f.mSavedFragmentState); } f.mSavedFragmentState = null; } // fall through  case Fragment.ACTIVITY_CREATED: if (newState \u0026gt; Fragment.ACTIVITY_CREATED) { if (DEBUG) Log.v(TAG, \u0026#34;moveto STARTED: \u0026#34; + f); f.performStart(); dispatchOnFragmentStarted(f, false); } // fall through  case Fragment.STARTED: if (newState \u0026gt; Fragment.STARTED) { if (DEBUG) Log.v(TAG, \u0026#34;moveto RESUMED: \u0026#34; + f); f.performResume(); dispatchOnFragmentResumed(f, false); f.mSavedFragmentState = null; f.mSavedViewState = null; } } } else if (f.mState \u0026gt; newState) { switch (f.mState) { case Fragment.RESUMED: if (newState \u0026lt; Fragment.RESUMED) { if (DEBUG) Log.v(TAG, \u0026#34;movefrom RESUMED: \u0026#34; + f); f.performPause(); dispatchOnFragmentPaused(f, false); } // fall through  case Fragment.STARTED: if (newState \u0026lt; Fragment.STARTED) { if (DEBUG) Log.v(TAG, \u0026#34;movefrom STARTED: \u0026#34; + f); f.performStop(); dispatchOnFragmentStopped(f, false); } // fall through  case Fragment.ACTIVITY_CREATED: if (newState \u0026lt; Fragment.ACTIVITY_CREATED) { if (DEBUG) Log.v(TAG, \u0026#34;movefrom ACTIVITY_CREATED: \u0026#34; + f); if (f.mView != null) { // Need to save the current view state if not  // done already.  if (mHost.onShouldSaveFragmentState(f) \u0026amp;\u0026amp; f.mSavedViewState == null) { saveFragmentViewState(f); } } f.performDestroyView(); dispatchOnFragmentViewDestroyed(f, false); if (f.mView != null \u0026amp;\u0026amp; f.mContainer != null) { // Stop any current animations:  f.mContainer.endViewTransition(f.mView); f.mView.clearAnimation(); AnimationOrAnimator anim = null; if (mCurState \u0026gt; Fragment.INITIALIZING \u0026amp;\u0026amp; !mDestroyed \u0026amp;\u0026amp; f.mView.getVisibility() == View.VISIBLE \u0026amp;\u0026amp; f.mPostponedAlpha \u0026gt;= 0) { anim = loadAnimation(f, transit, false, transitionStyle); } f.mPostponedAlpha = 0; if (anim != null) { animateRemoveFragment(f, anim, newState); } f.mContainer.removeView(f.mView); } f.mContainer = null; f.mView = null; // Set here to ensure that Observers are called after  // the Fragment\u0026#39;s view is set to null  f.mViewLifecycleOwner = null; f.mViewLifecycleOwnerLiveData.setValue(null); f.mInnerView = null; f.mInLayout = false; } // fall through  case Fragment.CREATED: if (newState \u0026lt; Fragment.CREATED) { if (mDestroyed) { // The fragment\u0026#39;s containing activity is  // being destroyed, but this fragment is  // currently animating away. Stop the  // animation right now -- it is not needed,  // and we can\u0026#39;t wait any more on destroying  // the fragment.  if (f.getAnimatingAway() != null) { View v = f.getAnimatingAway(); f.setAnimatingAway(null); v.clearAnimation(); } else if (f.getAnimator() != null) { Animator animator = f.getAnimator(); f.setAnimator(null); animator.cancel(); } } if (f.getAnimatingAway() != null || f.getAnimator() != null) { // We are waiting for the fragment\u0026#39;s view to finish  // animating away. Just make a note of the state  // the fragment now should move to once the animation  // is done.  f.setStateAfterAnimating(newState); newState = Fragment.CREATED; } else { if (DEBUG) Log.v(TAG, \u0026#34;movefrom CREATED: \u0026#34; + f); if (!f.mRetaining) { f.performDestroy(); dispatchOnFragmentDestroyed(f, false); } else { f.mState = Fragment.INITIALIZING; } f.performDetach(); dispatchOnFragmentDetached(f, false); if (!keepActive) { if (!f.mRetaining) { makeInactive(f); } else { f.mHost = null; f.mParentFragment = null; f.mFragmentManager = null; } } } } } } if (f.mState != newState) { Log.w(TAG, \u0026#34;moveToState: Fragment state for \u0026#34; + f + \u0026#34; not updated inline; \u0026#34; + \u0026#34;expected state \u0026#34; + newState + \u0026#34; found \u0026#34; + f.mState); f.mState = newState; } }   ","description":"理解 Fragment 的实现原理, FragmentTransaction 的事务机制等.","id":35,"section":"posts","tags":null,"title":"理解 Fragment","uri":"https://jiyang.site/posts/2019-11-08-%E7%90%86%E8%A7%A3-fragment/"},{"content":"问题 一个 m*n 的矩阵, 螺旋遍历输出每一项. 比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 输出: 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10\n 这个问题很久没做算法题, 然后思考了很久 🤦 才实现.\n 思考 一开始就想用遍历来输出，遍历的边界和起点，以及遍历的下标的 index 肯定要根据一些条件来动态调整.\n观察输出 1 2 3 4 | 8 12 16 | 15 14 13 | 9 5 | 6 7 11 10 可以看到是:\n 先向右 再向下 再向左 再向上  然后 1~4 循环执行.\n于是尝试先试着实现一次这样的循环(i: 行下标, j: 列下标), 那么条件就是:\n   条件 动作     i == 0 \u0026amp;\u0026amp; j \u0026lt; n 向右 j++   i \u0026lt; m \u0026amp;\u0026amp; j == n-1 向下 i++   i == m-1 \u0026amp;\u0026amp; j \u0026gt; -1 向左 j--   i \u0026gt; 0 向上 i--    这样便能执行一圈输出. 通过观察可以看的最后向上执行完后会回到最开始的起点位置(例子中的1), 那为了让圈缩小, 于是可以在1 的前一个位置(例子中的 5) 时就改变遍历的边界条件, 让起点+1, 终点 -1.\n实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * 按照螺旋方式输出矩阵 * 比如: * 1 2 3 4 * 5 6 7 8 * 9 10 11 12 * 13 14 15 16 * 输出: * 1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 */ public class PrintMatrix { public void print(final int[][] matrix) { int m = matrix.length; int n = matrix[0].length; int count = m * n; int i = 0, j = 0; int maxI = m; int maxJ = n; int minI = 0; int minJ = 0; do { System.out.print(matrix[i][j] + \u0026#34; \u0026#34;); count--; if (j == minJ \u0026amp;\u0026amp; i == minI + 1) { // 缩小圈子  minJ++; minI++; maxI--; maxJ--; } if (i == minI \u0026amp;\u0026amp; j \u0026lt; maxJ - 1) { j++; } else if (i \u0026lt; maxI - 1 \u0026amp;\u0026amp; j == maxJ - 1) { i++; } else if (i == maxI - 1 \u0026amp;\u0026amp; j \u0026gt; minJ) { j--; } else if (i \u0026gt; minI) { i--; } } while (count != 0); } }   测试 1 2 3 4 5 6 7 8 9 10  public static void main(String[] args) { int[][] mn = new int[][]{ new int[]{1, 2, 3, 4}, new int[]{5, 6, 7, 8}, new int[]{9, 10, 11, 12}, new int[]{13, 14, 15, 16} }; new PrintMatrix().print(mn); }   ","description":"一个 m*n 的矩阵, 螺旋遍历输出每一项","id":36,"section":"posts","tags":null,"title":"螺旋输出矩阵","uri":"https://jiyang.site/posts/2019-11-07-%E8%9E%BA%E6%97%8B%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5/"},{"content":"通过 Wireshark 抓包理解 HTTPS 的 SSL/TLS 握手\n SSL/TLS 的基本思想是 公钥加密, 私钥解密(非对称加密). 客户端请求时, 服务端先将自己的公钥告诉它, 然后客户端使用公钥对内容加密, 服务端收到之后使用私钥解密.\n 但是有几个问题:\n 如何保证服务端的公钥不会被篡改. 因为如果请求服务端公钥的过程被拦截, 拦截者返回了一个不正确的公钥, 就会造成问题 我们必须具有服务器的公钥。但是, 我们无法存储地球上所有服务器的公钥, 该数据非常庞大, 并且如何保证公钥的修改同步问题 公钥加密, 私钥解密(非对称加密)的方式比较耗时, 如果每次数据交换都进行会增大整个请求的耗时  为了解决上面的问题, 引入了 数字证书 和 SSL/TLS 握手:\n 数字证书: 将公钥放在数字证书中, 只要证书通过客户端验证, 那公钥就是可信的; 数字证书每次由服务端在请求前发送给客户端, 解决了公钥同步问题 SSL/TLS 握手: 在每一次对话之前, 服务端和客户端通过握手生成一个密钥, 之后的数据都通过这个密钥使用对称加密方式加密, 就避免了每次使用非对称加密的耗时问题  如何验证证书有效  服务端的公钥放在数字证书中, 那客户端是如何验证这个证书的是不是正确的呢?\n 解决方案是证书颁发机构, 或简称为 CA (根证书机构)。当我们安装操作系统或浏览器时, 可能会附带一系列受信任的 CA。在这些 CA 列表中, 还存储了 CA 的公钥。\n Mac OS: 可以在钥匙串中查看系统信任的证书 Android: /system/etc/security/cacerts 文件夹中存有系统信任的证书  比如, 当 Google.com 的服务器向我们发送其证书时, 它还会提到该证书是由 GeoTrust 签名的。如果我们信任 GeoTrust, 则可以使用 GeoTrust 的公钥验证 GeoTrust 是否确实签署了 Google.com 服务器发送给我们的证书。(CRL 或 OCSP)\n如果我们要自己签署证书, 我们需要知道私钥, 但私钥只有 GeoTrust 知道。因此攻击者就无法自己签署证书并假装自己是 Google.com。而且证书被修改后, 即使只有一位, 签名也将不正确, 客户端将拒绝它。\nOCSP 在线证书状态协议  Alice 与 Bob 使用 Carol 颁发的数字证书。该场景中 Carol 是证书颁发机构（CA）； Alice 向Bob 发送其由 Carol 颁发的数字证书，并发出请求创建连接的申请； Bob 担心 Alice 的私钥已经泄露，因此向 Carol 发送“OCSP请求”消息并包含 Alice 的数字证书序列号； Carol 的OCSP 响应端从 Bob 发送的消息中获取数字证书的序列号，并在 CA 数据库中查找该数字证书的状态； Carol 向 Bob 发送由其私钥加密的消息“OCSP响应”，并包含证书状态正常的信息； 由于 Bob 事先已经安装了 Carol 的数字证书，因此 Bob 使用 Carol 的公钥解密消息并获取到 Alice 的数字证书状态信息； Bob 验证通过后, Bob 决定与 Alice进行通信。  握手过程 高亮的部分就是 TLS 握手的过程\n   Client Hello Server Hello Server certificates Server Key exchange Client Key exchange Server final Respnse              Initial Client Message to Server Client Hello Client Hello 发送的消息:\n   属性 值 描述     Version TLS 1.0 客户端使用的 TLS 版本, Version 2 对应 SSL 2.0, version 3 对应 SSL 3.0,version 3.1 对应 TLS   Random \u0026hellip; 随机值是一个4字节的数字，由客户端的日期和时间加上一个 28 字节随机生成的数字组成，该数字最终将与服务器随机值一起使用，以生成一个 master screct，从 master screct 中可以导出加密密钥   Session ID \u0026hellip; 如果客户端有上一次会话的 session id 的话, 客户端可以携带上, 用它来恢复之前的会话. 因为创建新会话需要占用大量处理器资源来做公钥操作，可以通过恢复具有已建立会话密钥的现有会话来避免这种操作   Cipher Suites  客户端支持的加密算法   Compression Methods  客户端支持的压缩算法   application layer protocol negotiation - ALPN 协议    Server Response to Client Server Hello Server Hello 发送的消息:\n   属性 值 描述     Version TLS 1.0 服务端将选择服务端和客户端支持的最高版本   Random \u0026hellip; 服务端产生的随机值, 产生方法和客户端一样   Session ID \u0026hellip; 服务端为这次会话分配的 id, 有 3 种情况: 1. New Session ID: 如果客户端没有在 Client Hello 消息中携带 Session ID 的话，会生成一个新的; 即使 Client Hello 消息携带了 SessionID, 也有可能服务端已经不能恢复上一次会话了, 这种情况也会生成一个新的 Session ID 2. Resumed Session ID: Client Hello 携带了 Session ID 且服务器会恢复它对应的会话, 服务器就会返回和 Client Hello 携带上来一样的 Session ID 3. Null: 一个新会话，但是服务器不愿意在以后恢复它，因此不会返回任何ID   Cipher Suite  服务端从客户端支持的加密算法中选择使用的一个   Compression Methods  服务端的压缩算法   application layer protocol negotiation  ALPN 协议    Server certificates 服务端发送自己的证书: 这里发送了两个证书，一个是网站自己的证书，另一个是网站证书申请使用的二级证书。因为网站的证书不是直接从根证书机构签发的, 所以这里会发送中级颁发机构的证书.\n客户端先通过本地的根证书验证中级颁发机构的证书，然后再使用中级颁发结构的证书验证网站的证书。客户端验证证书通过后，会从网站证书中提取公钥.\n blog.jiyang.site: 网站证书 Let\u0026rsquo;s Encrypt Authority X3: 中级颁发机构证书  Server Key Exchange 这里服务端在一次通信里做了 2 件事:\n Server Key Exchange Server Hello Done  Server Key Exchange: 是一个可选步骤，服务器创建一个临时密钥并将其发送给客户端。客户端可以使用此密钥在此过程的后面加密 Client Key Exchange 消息。仅当公共密钥算法未提供加密客户端密钥交换消息所需的密钥材料时（例如，服务器的证书不包含公共密钥时），才需要执行此步骤\nServer Hello Done 此消息表明服务器握手已完成，正在等待客户端的响应\nClient Response to Server Client Key Exchange 这里客户端在一次通信里做了 3 件事:\n Client Key Exchange  客户端使用两个随机值计算出premaster secret后, 发送 Client Key Exchange message. 在将 premaster secret传输到服务器之前, 已使用服务器证书中的公钥对其进行了加密. 双方将在本地计算 master secret 并从中获取会话密钥.\n如果服务器可以解密此数据并完成协议, 则可以向客户端保证服务器具有正确的私钥. 这一步对于证明服务器的真实性至关重要. 只有具有与证书中的公钥匹配的私钥的服务器才能解密此数据并继续协议下面的步骤.\n此消息还将包括协议版本. 服务器将验证它是否与客户端问候消息中发送的原始值匹配. 此措施可防止回滚攻击. 回滚攻击通过操纵消息来工作, 以使服务器和客户端使用安全性较低的协议的较早版本.\n Change Cipher Spec  该消息通知服务器, 将使用刚刚协商的密钥和算法对Client Finished message之后的所有消息进行加密.\n Encrypted Handshake Message  这个报文的目的就是告诉对端自己在整个握手过程中收到了什么数据, 发送了什么数据. 来保证中间没人篡改报文. 其次, 这个报文作用就是确认秘钥的正确性. 因为 Encrypted handshake message 是使用对称秘钥进行加密的第一个报文, 如果这个报文加解密校验成功, 那么就说明对称秘钥是正确的.\nServer Final Response 接着服务端又在一次通信里做了 2 件事:\n Change Cipher Spec  此消息通知客户端服务器将开始使用刚刚协商的密钥来加密消息。\n Encrypted Handshake Message  和 Client 上面的 Encrypted Handshake Message 目的一样\n","description":"通过 Wireshark 抓包理解 HTTPS 的 SSL/TLS 握手","id":37,"section":"posts","tags":["TLS"],"title":"HTTPS 的 TLS 握手","uri":"https://jiyang.site/posts/2019-11-05-https-%E7%9A%84-tls-%E6%8F%A1%E6%89%8B/"},{"content":"最近 Leak Canrray 检测出了 Activity/ReportFragment 被泄漏。发现引用其的 GC Root 竟然是一个 HandlerThread。\n实例 首先看下给出的引用链:\n   GC Root Leaked Object Message           * EXCLUDED LEAK. * XXXActivity has leaked: * thread HandlerThread.!(\u0026lt;Java Local\u0026gt;)! (named 'XXHandlerThread') * ↳ Message.!(obj)! , matching exclusion field android.os.Message#obj * ↳ XXXDialogFragment$3.!(val$context)! (anonymous implementation of android.content.DialogInterface$OnCancelListener) * ↳ XXXActivity * Details: * Instance of android.os.HandlerThread | mHandler = null | mLooper = android.os.Looper@316943936 (0x12e42e40) * Instance of android.os.Message | static sPoolSize = 29 | static sPool = android.os.Message@316941920 (0x12e42660) | callback = null | data = null | flags = 0 | next = null | obj = XXXDialogFragment$3@325843528 (0x136bfa48) | replyTo = null | sendingUid = -1 | target = android.app.Dialog$ListenersHandler@325843544 (0x136bfa58) | what = 68 | when = 0 * Instance of XXXDialogFragment$3 | val$context = XXXActivity@325713968 (0x136a0030) 原因分析 从引用链上可以看到是一个 Message 被一个 HanderThread(在 Java 中，处于运行状态的 Thread 也是 GC Root) 引用了，而且通过几次查看发现每次的 GC Root 是不同的 HanderThread, 貌似是随机的。详细查看 Message 的 obj 和 what 字段，再与 Dialog 的 mCancelMessage mDismissMessage mShowMessage 对比发现, 泄漏的 Message 正是其中之一。于是去查看这几个 Message 是在什么时候被创建的 :\nDialog 创建和发送 Message  DialogFragment 在 onActivityCreated 方法中会为内部的 mDialog 设置监听器  1 2 3 4 5 6 7 8 9 10  //androidx.fragment.app.DialogFragment#onActivityCreated public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); ... // DialogFragment 实现了 OnDismissListener 和 OnCancelListener  mDialog.setCancelable(mCancelable); mDialog.setOnCancelListener(this); mDialog.setOnDismissListener(this); ... }   Dialog 在设置监听器时会调用 mListenersHandler.obtainMessage 获取一个消息, 然后设置 what 和 obj 字段  1 2 3 4 5 6 7 8 9  //android.app.Dialog#setOnDismissListener public void setOnDismissListener(@Nullable OnDismissListener listener) { // listener 就是外部传入的 DialogFragment, 也就导致 Dialog 的 mDismissMessage, mCancelMessage, mShowMessage 的 obj 引用了 DialogFragment  if (listener != null) { mDismissMessage = mListenersHandler.obtainMessage(DISMISS, listener); } else { mDismissMessage = null; } }   当调用 dialog 的 dismiss show hide 时把消息发送到 Looper 中  1 2 3 4 5 6 7  //android.app.Dialog#sendDismissMessage 例如: 发送 dismiss 消息 private void sendDismissMessage() { if (mDismissMessage != null) { // 没有直接把 mDismissMessage 发出去，而是通过 obtain 复制了一个新的  Message.obtain(mDismissMessage).sendToTarget(); } }    发送消息的时候，并没有直接将已有的 mDismissMessage 发出去，而是又调用 obtain 获取了一个新的消息发送到 Looper 的 MessageQueue 中\n 当消息回调时再进行对应的操作  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  //android.app.Dialog.ListenersHandler private static final class ListenersHandler extends Handler { private final WeakReference\u0026lt;DialogInterface\u0026gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference\u0026lt;\u0026gt;(dialog); } @Override public void handleMessage(Message msg) { //对比截图中 Message 的 what 能匹配这里的 case  switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } }   看了 Dialog 中 Message 的创建逻辑，也没有涉及 HandlerThread 的内容，那为什么 HandlerThread 会引用了这些 Message，而且一直不释放呢？\n按照正常的逻辑, Message 的生命周期应该是:\n在回收进消息池之前会先解除 Message 引用的所有对象.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  void recycleUnchecked() { flags = FLAG_IN_USE; // 清空所有引用  what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { // 放到链表头部  if (sPoolSize \u0026lt; MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } }   那说明 Dialog 在 sendDismissMessage 时发出去的 Message 是不可能一直持有其他对象的引用的, 所以只有可能是在 setOnDismissMessage 时获取的 mDismissMessage 泄漏了. 但是 mDismissMessage 是 Dialog 的一个成员变量, 理论上\n应该随着 Dialog 的释放而被 GC 回收。那这个 Message 是为何被一个 HandlerThread 持有了呢?\nHandlerThread 消费 Message 在每个 Android 应用进程中, 有一个消息池是由所有线程共用的, 通过 Message.obtain() 就是复用这个池子中已有的 Message, 池子以链表的方式实现。\nHandlerThread 则是在创建时就会自己创建一个 Looper 的线程, 所以当它 start 了之后, 就会调用 Looper.loop() 一直循环消费MessageQueue 中的消息。\n1 2 3 4 5 6 7 8  for (;;) { Message msg = queue.next(); // 在 MessageQueue 中没有新的消息时, 阻塞当前线程  if (msg == null) { return; } msg.target.dispatchMessage(msg); msg.recycleUnchecked(); }   在 MessageQueue 中没有新的消息时, 当前线程线程就会被阻塞. 同时上一条被回收的消息会暂时被当前线程持有. 所以, 有一种可能就是 Dialog 获取的 mDismissMessage 就是被 HandlerThread 在等待下一条消息时阻塞的消息. 导致 mDismissMessage 无法被 GC 回收.\n复现  首先向一个 HandlerThread(称为 BackThread) 通过 Handler 发送一条 Message(称为 A)(handler.post) 然后当 A 被 BackThread 执行之后, 再通过主线程 Handler 向主线程发送一条 Message(称为B)(runOnUiThread), 该 Message 的 obj 引用当前 Activity 这时有很大可能 B 就是 A(因为消息池的第一条消息会是A), 而 A 由于 BackThread 的 MessageQueue 没有新 Message, 被 BackThread 引用着. 当 Activity 退出后, BackThread 还继续处于阻塞状态, Message A 也就不能被 GC 回收  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class XXActivity : Activity() { private val byte = ByteArray(1024 * 1024 * 10) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val bThread = HandlerThread(\u0026#34;BackendThread\u0026#34;) bThread.start() val handler = Handler(xxThread.looper) val obj = this // 先向 BackendThread 通过 handler 发送一条 Message  handler.post { // 会产生一个 Message A  // 当 Message A 被消费时, 会被回收到消息池  runOnUiThread { // 通过 runOnUiThread 向主线程发送一条消息  val messageB = handler.obtainMessage(1, obj) // 很有可能 B 就是刚被回收的 A  Message.obtain(messageA).sendToTarget() } } } }   进入 XXActivity, 退出, 然后再做其他功能, Leak Canrray 就检测到了如下内存泄漏:\n* Details: * Instance of android.os.HandlerThread | name = \u0026quot;BackendThread\u0026quot; | tid = 507 * Instance of android.os.Message | arg1 = 0 | arg2 = 0 | callback = null | data = null | flags = 0 | next = null | obj = io.github.stefanji.playground.XXActivity@316341328 (0x12dafc50) | replyTo = null | sendingUid = -1 | target = android.os.Handler@316341560 (0x12dafd38) | what = 1 | when = 0 * Instance of io.github.stefanji.playground.XXActivity | byte = byte[10485760]@3441664000 (0xcd23a000) 解决办法 网上有说在 super.onActivityCreated 执行完之后, 再单独调用 getDialog().setOnDismissListener(null) 来置空 Message。这样其实是不行的，因为在 super.onActivityCreated 执行时有可能 Dialog.setOnDismissListener 里的 mDismissMessage 已经被其他 HandlerThread 持有了. 所以根本的方法是避免 Dialog 里的 Message 直接引用 Fragment/Activity/View.\n1. 复写 DialogFragment 的 onCreateDialog 返回自己实现的 Dialog  适用于不需要监听 Dialog 的 onShow onDismiss 事件时\n 继承 Dialog, 复写 setOnXXListener 另其不会创建 cancelMessage, dismissMessage, showMessage.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  private class MDialog(context: Context, @StyleRes themeResId: Int) : Dialog(context, themeResId) { override fun setOnCancelListener(listener: DialogInterface.OnCancelListener?) { // 空实现  } override fun setOnDismissListener(listener: DialogInterface.OnDismissListener?) { // 空实现  } override fun setOnShowListener(listener: DialogInterface.OnShowListener?) { // 空实现  } }   2. 向 HandlerThread 发送空 Message 该方法的原理是, 通过调用 HandlerThread 的 MessgeQueue 的 addIdleHandler, 添加一个当 MessageQueue 中无消息时的监听,\n当 IdleHandler 被回调时, 向对应 MessageQueue 发送一条空白 Message, 从而避免 HandlerThread 阻塞在 queue.next.\n1 2 3 4  handler.looper.queue.addIdleHandler { handler.obtainMessage().sendToTarget() true }   但是, 一般情况下, 我们应用中会存在很多 HandlerThread, 比如一些第三方库内部也会创建 HandlerThread, 这种方法就不能保证处理了每个 HandlerThread.\n3. 其他方法 其他方法应该还有, 只要达到了最终目的(避免 Dialog 里的 Message 直接引用 Fragment/Activity/View.)就行.\n总结  首先, 这种泄漏存在一定概率, 要你的应用中存在这样的经常没有新 Message 处理的 HandlerThread, 恰巧又遇到了 Dialog 中需要 obtain Message 了. 其次, 通过这个问题, 自己也加深了对 Message 消息池复用的理解.  参考  https://medium.com/square-corner-blog/a-small-leak-will-sink-a-great-ship-efbae00f9a0f\n","description":"最近 Leak Canrray 检测出了 Activity/ReportFragment 被泄漏。发现引用其的 GC Root 竟然是一个 HandlerThread。","id":38,"section":"posts","tags":["内存泄漏"],"title":"记一次 DialogFragment 造成的内存泄漏","uri":"https://jiyang.site/posts/2019-11-01-%E8%AE%B0%E4%B8%80%E6%AC%A1-dialogfragment-%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"content":"最近在看一些框架的 c++ 源码中, 发现它们在许多函数传参时会使用 std::move 调用, 于是想弄清这个目的是什么.\nstd::move 函数定义 1 2  template\u0026lt; class T \u0026gt; typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t ) noexcept; // since C++11, until C++14   1 2  template\u0026lt; class T \u0026gt; constexpr typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; t ) noexcept; // since C++14   概述: std::move 用于指示对象 t 可以“被移动”，即允许从 t 到另一对象的有效率的资源传递。\n首先可以看到 move 函数的形参为T\u0026amp;\u0026amp; t, 返回值为 std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp;. 在 c++ 里, 我知道 T\u0026amp; 表示引用传参, 那 T\u0026amp;\u0026amp; 是什么意思 ?\n\u0026amp;\u0026amp; 表示右值引用, 什么是右值引用?\n右值引用  rvalue references\n 右值引用是相对于左值的一个概念, 在一个表达式中:\n1  int i = 0;   i 就是左值, 左值能被赋值, 值能改变. 0 就是右值, 一般就是运算数. 在 c++11 之前, 右值是不能引用的, 最多就是用一个常量引用绑定右值:\n1  const int\u0026amp; a = 0;   左值和右值传参 重载两个函数, 一个接收引用传参, 一个接收右值引用\n1 2 3 4 5 6 7  void process(int\u0026amp; i) { cout \u0026lt;\u0026lt; \u0026#34;LValue process: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } void process(int\u0026amp;\u0026amp; i) { cout \u0026lt;\u0026lt; \u0026#34;RValue process: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; }   1 2 3 4 5  int main() { int a = 1; process(a); process(1); }   输出:\nLValue process: 1 RValue process: 1 右值引用的优点  右值引用是用来支持转移语义的。转移语义(Move Semantic)可以将资源 (堆，系统对象等) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。通过转移语义，临时对象中的资源能够转移其它的对象里。\n  在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。 普通的函数和操作符也可以利用右值引用操作符实现转移语义。  实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  class StdMoveTest { private: char* _data; size_t len; void _init_data(const char* d) { _data = new char[len+1]; memcpy(_data, d, len); _data[len] = \u0026#39;\\0\u0026#39;; } public: StdMoveTest(){ len = 0; _data = NULL; } StdMoveTest(const char* d) { len = strlen(d); _init_data(d); } StdMoveTest(const StdMoveTest\u0026amp; obj) { cout \u0026lt;\u0026lt; \u0026#34;Copy constructor: \u0026#34; \u0026lt;\u0026lt; obj._data \u0026lt;\u0026lt; endl; len = obj.len; _init_data(obj._data); } StdMoveTest\u0026amp; operator=(const StdMoveTest\u0026amp; obj) { cout \u0026lt;\u0026lt; \u0026#34;Copy assgin: \u0026#34; \u0026lt;\u0026lt; obj._data \u0026lt;\u0026lt; endl; if(this != \u0026amp;obj){ len = obj.len; _init_data(obj._data); } return *this; } virtual ~StdMoveTest(){ cout \u0026lt;\u0026lt; \u0026#34;destructor: \u0026#34; \u0026lt;\u0026lt; this \u0026lt;\u0026lt; \u0026#34; \u0026#34;; if(_data) { cout \u0026lt;\u0026lt; _data; free(_data); } cout \u0026lt;\u0026lt; endl; } }; int main(int argc, const char * argv[]) { StdMoveTest t; t = StdMoveTest(\u0026#34;Hello\u0026#34;); vector\u0026lt;StefanJi::StdMoveTest\u0026gt; vec; vec.push_back(StdMoveTest(\u0026#34;Word\u0026#34;)); return 0; }   输出:\nCopy assgin: Hello destructor: 0x7ffeefbff500 Hello Copy constructor: Word destructor: 0x7ffeefbff4c0 Word destructor: 0x1006066f0 Word destructor: 0x7ffeefbff518 Hello 可以看到将一个右值赋给左值时, 会调用赋值构造函数, 赋值构造函数里又会进行内存的分配. 将右值传递给 vector 时会调用拷贝构造函数生成一个新的对象. 从最后析构函数的日志中也能看出释放了两个 Hello, 两个 Word.\n加上转移赋值构造函数和转移拷贝构造函数重载:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  StdMoveTest(StdMoveTest\u0026amp;\u0026amp; obj) { cout \u0026lt;\u0026lt; \u0026#34;Move constructor: \u0026#34; \u0026lt;\u0026lt; obj._data \u0026lt;\u0026lt; endl; len = obj.len; _data = obj._data; obj.len = 0; obj._data = NULL; } StdMoveTest\u0026amp; operator=(StdMoveTest\u0026amp;\u0026amp; obj) { cout \u0026lt;\u0026lt; \u0026#34;Move assgin: \u0026#34; \u0026lt;\u0026lt; obj._data \u0026lt;\u0026lt; endl; if(this != \u0026amp;obj){ len = obj.len; _data = obj._data; obj.len = 0; obj._data = NULL; } return *this; }   输出:\nMove assgin: Hello destructor: 0x7ffeefbff500 Move constructor: Word destructor: 0x7ffeefbff4c0 destructor: 0x100603b20 Word destructor: 0x7ffeefbff518 Hello 可以看到调用了重载的转移赋值构造函数和转移拷贝构造函数, 而且析构函数的调用中能看出实际也是否了一个 Hello 和一个 Word, 从而避免了多余的内存分配.\n在添加转移重载时需要注意几个点:\n 形参的符号是右值引用符号 \u0026amp;\u0026amp; 形参就不能使用 const 修饰了, 因为我们需要修改右值 形参对对象的引用必须断开(obj._data = NULL), 因为当右值的析构函数调用时, 如果还存在对对象的引用, 那转移到新引用的资源会被释放  std::move 从上面的实例中看到只有右值引用才能调用转移构造函数和转移赋值函数, 而所有命名对象都只能是左值引用. 如果想将左值引用右值引用来使用, 则能使用 std::move 函数将左值引用转换为右值引用.\n1 2 3 4 5 6 7 8 9  int main(int argc, const char * argv[]) { StdMoveTest hello = StdMoveTest(\u0026#34;hello\u0026#34;); StdMoveTest word = StdMoveTest(\u0026#34;Word\u0026#34;); vector\u0026lt;StefanJi::StdMoveTest\u0026gt; vec; vec.push_back(hello); vec.push_back(std::move(word)); return 0; }   输出:\nCopy constructor: hello Move constructor: Word Copy constructor: hello destructor: 0x1030979a0 hello destructor: 0x10309b818 Word destructor: 0x10309b800 hello destructor: 0x7ffeefbff500 destructor: 0x7ffeefbff518 hello 注意到 std::move 的形参为 T\u0026amp;\u0026amp; t, 但是它如何接收左值引用的 ? 因为 \u0026amp;\u0026amp; 还有另外一个语义, 如果形参传递的是左值引用, 那么 t 就是左值引用, 如果传递的是右值引用, 那么 t 就是右值引用. 利用这个特点, 就能定义同时支持左值和右值得函数. 这个特性又叫 Perfect Forwarding(完美转发).\n总结  使用右值引用和转移语义能提高程序的性能, 在形参中使用 \u0026amp;\u0026amp; 能让方法更简洁的同时支持左值和右值引用. 利用 std::move 能方便的利用右值引用的特性  参考  https://en.cppreference.com/w/cpp/utility/move https://stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11 https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html ","description":"最近在看一些框架的 c++ 源码中, 发现它们在许多函数传参时会使用 `std::move` 调用, 于是想弄清这个目的是什么.","id":39,"section":"posts","tags":null,"title":"关于 std::move","uri":"https://jiyang.site/posts/2019-10-27-%E5%85%B3%E4%BA%8E-std-move/"},{"content":"理解堆的定义, 使用堆实现一个优先级队列, 查看 java.util.Timer 中的小根堆实现\n堆的定义 堆是具有下面性质的完全二叉树:\n 每个结点的值都小于或等于其左右孩子结点的值: 小根堆 每个结点的值都大于或等于其左右孩子结点的值: 大根堆  用堆来实现优先级队列的话, 入队和出队操作的时间复杂度均为 O($log_{2}n$). 因为可以根据完全二叉树的性质设计入队和出队算法。\n完全二叉树中, 结点从 1 开始按照层序编号, 若一个结点的编号为 i, 则它的双亲结点编号为 i/2, 左孩子是 2i,右孩子是 2i+1.\n堆常用数组实现, 数组的下标表示完全二叉树中结点的编号.\n存储结构               java.util.Timer java.util.Timer 中的优先级队列实现就是使用的小根堆实现:\n入队 1 2 3 4 5 6 7 8 9 10  void add(TimerTask task) { // Grow backing store if necessary  if (size + 1 == queue.length) queue = Arrays.copyOf(queue, 2*queue.length); // 将新提交的 task 放到堆的尾部  queue[++size] = task; // 然后进行向上层的遍历  fixUp(size); }   1 2 3 4 5 6 7 8 9 10 11 12 13  private void fixUp(int k) { // 保证编号 1 的结点是整个堆的最小值  while (k \u0026gt; 1) { int j = k \u0026gt;\u0026gt; 1; // k \u0026gt;\u0026gt; 1 就是它的双亲结点在数组中的下标  // 比较 k 和它的双亲结点  if (queue[j].nextExecutionTime \u0026lt;= queue[k].nextExecutionTime) // 如果 k 的值较大, 则储存在当前位置  break; // 如果 k 的值较小, 则将它与双亲结点交换  TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; } }   出队 1 2 3  TimerTask getMin() { return queue[1]; // 根结点即是堆中的最小值 }   1 2 3 4 5  void removeMin() { queue[1] = queue[size]; // 将最后一个结点值赋给根结点  queue[size--] = null; // Drop extra reference to prevent memory leak  fixDown(1); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  private void fixDown(int k) { int j; while ((j = k \u0026lt;\u0026lt; 1) \u0026lt;= size \u0026amp;\u0026amp; j \u0026gt; 0) { // j = k*2: 即 k 的左孩子结点  // 左孩子与与右孩子比较  if (j \u0026lt; size \u0026amp;\u0026amp; queue[j].nextExecutionTime \u0026gt; queue[j+1].nextExecutionTime) // 如果左孩子较大, 则 j++  j++; // j indexes smallest kid  // 依据上面是否执行 j++, 与左孩子或右孩子比较  if (queue[k].nextExecutionTime \u0026lt;= queue[j].nextExecutionTime) break; // 如果孩子中存在大于k结点的, 则交换  TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; } }   大小根堆  一个自己实现的支持大或小根堆的实现\nhttps://github.com/stefanJi/Algorithm/blob/master/src/site/jiyang/DataStructure/Heap.java\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141  /** * Create by StefanJi in 2019-10-25 */ public class Heap\u0026lt;T extends Comparable\u0026gt; { private static final int DEFAULT_SIZE = 16; public static final byte MAX_HEAP = 0; public static final byte MIN_HEAP = 1; @Retention(RetentionPolicy.SOURCE) @ByteDef({MAX_HEAP, MIN_HEAP}) @Target({ElementType.FIELD, ElementType.PARAMETER}) @interface Order { } private int count; private byte order; private Object[] tree; public Heap(@Order byte order) { this.order = order; tree = new Object[DEFAULT_SIZE]; } public Heap(@Order byte order, int initCapacity) { this.order = order; if (initCapacity \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Illegal capacity: \u0026#34; + initCapacity); } if (initCapacity == 1) { initCapacity = 2; } tree = new Object[initCapacity]; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public boolean add(T v) { if (v == null) { return false; } if (!ensureCapacity(count + 1)) { return false; } tree[++count] = v; // add to heap tail  int k = count; while (k \u0026gt; 1) { int parent = k \u0026gt;\u0026gt; 1; // index of parent  T p = (T) tree[parent]; if (order == MAX_HEAP) { if (p.compareTo(v) \u0026gt;= 0) { // parent \u0026gt;= v, no need swap  break; } } else { if (p.compareTo(v) \u0026lt;= 0) { // parent \u0026lt;= v, no need swap  break; } } tree[parent] = v; // swap  tree[k] = p; k = parent; } return true; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public T removeRoot() { final T root = getRoot(); if (root == null) { return null; } tree[1] = tree[count]; // move tail to root  tree[count] = null; // free tail element  count--; if (count \u0026lt; 1) { return root; } int k = 1; int leftChild = 2; // index of left child  T newRoot = (T) tree[1]; while (leftChild \u0026lt;= count) { T left = (T) tree[leftChild]; // select max between left and right children  int max = leftChild; if (leftChild \u0026lt; count) { T right = (T) tree[leftChild + 1]; if ((order == MAX_HEAP \u0026amp;\u0026amp; right.compareTo(left) \u0026gt; 0) || (order == MIN_HEAP \u0026amp;\u0026amp; right.compareTo(left) \u0026lt; 0)) { max++; } } T m = (T) tree[max]; if ((order == MAX_HEAP \u0026amp;\u0026amp; m.compareTo(newRoot) \u0026lt;= 0) || (order == MIN_HEAP \u0026amp;\u0026amp; m.compareTo(newRoot) \u0026gt;= 0)) { break; } tree[k] = m; // swap  tree[max] = newRoot; k = max; leftChild = k \u0026lt;\u0026lt; 1; } return root; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public T getRoot() { if (count == 0) { return null; } return (T) tree[1]; } private boolean ensureCapacity(int target) { if (target \u0026gt; tree.length) { try { tree = Arrays.copyOf(tree, target); } catch (Exception e) { e.printStackTrace(); return false; } } return true; } public int getCount() { return count; } @Override public String toString() { StringBuilder sb = new StringBuilder(); for (int i = 1; i \u0026lt;= count; i++) { sb.append(tree[i].toString()); if (i != count) { sb.append(\u0026#34;,\u0026#34;); } } return sb.toString(); } }   测试一下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public static void main(String[] args) { Heap\u0026lt;Integer\u0026gt; maxHeap = new Heap\u0026lt;\u0026gt;(Heap.MAX_HEAP, 10); Heap\u0026lt;Integer\u0026gt; minheap = new Heap\u0026lt;\u0026gt;(Heap.MIN_HEAP, 10); System.out.println(\u0026#34;=========== max heap ===========\u0026#34;); test(maxHeap); System.out.println(\u0026#34;=========== min heap ===========\u0026#34;); test(minheap); } private static void test(Heap\u0026lt;Integer\u0026gt; heap) { heap.add(18); System.out.println(heap); heap.add(40); System.out.println(heap); heap.add(60); System.out.println(heap); heap.add(45); System.out.println(heap); heap.add(32); System.out.println(heap); heap.add(22); System.out.println(heap); heap.add(36); System.out.println(heap); heap.add(50); System.out.println(heap); heap.add(30); System.out.println(heap); System.out.println(\u0026#34;========start remove=======\u0026#34;); final int count = heap.getCount(); for (int i = 0; i \u0026lt; count; i++) { System.out.println(heap); heap.removeRoot(); } }   ","description":"理解堆的定义, 使用堆实现一个优先级队列, 查看 `java.util.Timer` 中的小根堆实现","id":40,"section":"posts","tags":["树","堆"],"title":"小根堆-大根堆","uri":"https://jiyang.site/posts/2019-10-24-%E5%B0%8F%E6%A0%B9%E5%A0%86/"},{"content":"Flutter 应用运行的本质还是原生应用的运行。那么在 Android 上, Flutter 框架是如何运行起来的呢?\n 本文基于 Flutter v1.10.5 版本源码\n 先回想下编写一个纯 Flutter 应用的场景:\n 创建项目, flutter create 命令会生成 IOS, Android, Dart 三个项目结构 在 Dart 项目目录的 lib 文件夹下编写 Dart 代码 执行 flutter run 在 IOS 或 Android 上运行应用  这套流程下了，感觉完全不用接触 IOS 和 Android 的原生开发了。但是, 我们知道 Flutter 其实只是一个 UI 框架, 它是基于 IOS 和 Android 已有的机制运行的。所以 Flutter 应用运行的本质还是原生应用的运行。那么在 Android 上, Flutter 框架是如何运行起来的呢。\nAndroid 应用的启动 首先, 简单来说. Android 应用的启动可以在 AndroidManifest 中配置, 启动使用的 Application 类(可不单独配置)和启动之后打开的第一个 Activity. 这个规则外部应该是不能干涉的. 所以, Flutter 应用首先肯定会打开一个 Activity, 可能会使用自己单独的 Application 类.\nflutter create 看下使用 flutter create 命令生成的项目中的 Android 部分:\nandroid ├── app │ ├── build.gradle │ └── src │ └── main │ ├── AndroidManifest.xml │ ├── java │ │ └── io │ │ ├── flutter │ │ │ └── plugins │ │ │ └── GeneratedPluginRegistrant.java │ │ └── github │ │ └── stefanji │ │ └── fluttergitlab │ │ └── MainActivity.java 创建了一个 Activity: MainActivity.java.\n再看下 AndroidManifest 文件:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; package=\u0026#34;io.github.stefanji.fluttergitlab\u0026#34;\u0026gt; \u0026lt;application android:name=\u0026#34;io.flutter.app.FlutterApplication\u0026#34; android:label=\u0026#34;@string/app_name\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34;\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;singleTop\u0026#34; android:theme=\u0026#34;@style/LaunchTheme\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt;   不出所料, 应用启动之后, 首先会打开 MainActivity. 而且 manifest 里还单独声明了一个 Application 类: FlutterApplication. 这就说明, 应用启动的将会是这个类.\n再看下 flutter build apk --debug 生成的 apk 文件:\n├── assets │ └── flutter_assets │ ├── AssetManifest.json │ ├── FontManifest.json │ ├── LICENSE │ ├── fonts │ ├── isolate_snapshot_data │ ├── kernel_blob.bin │ ├── packages │ └── vm_snapshot_data ├── classes.dex ├── lib │ ├── arm64-v8a │ │ └── libflutter.so │ ├── armeabi-v7a │ │ └── libflutter.so │ ├── x86 │ │ └── libflutter.so │ └── x86_64 │ └── libflutter.so 再对比下 flutter build apk --release 生成的:\n├── assets │ └── flutter_assets │ ├── AssetManifest.json │ ├── FontManifest.json │ ├── LICENSE │ ├── fonts │ └── packages ├── classes.dex ├── lib │ ├── arm64-v8a │ │ ├── libapp.so │ │ └── libflutter.so │ └── armeabi-v7a │ ├── libapp.so │ └── libflutter.so 对比 release 打包和 debug 打包能发现, bebug 模式下 assets/flutter_assets 目录里会多出 isolate_snapshot_data kernel_blob.bin vm_snapshot_data 三个文件, 而 release 模式下打包则在 lib 目录下多出一个 libapp.so 动态链接库. 这些文件的区别, 现在还没清楚, 后面可能会遇到.\n看了文件结构和打包的差异之后, 先从应用启动开始梳理.\n应用启动  io.flutter.app.FlutterApplication\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class FlutterApplication extends Application { @Override @CallSuper public void onCreate() { super.onCreate(); FlutterMain.startInitialization(this); } private Activity mCurrentActivity = null; public Activity getCurrentActivity() { return mCurrentActivity; } public void setCurrentActivity(Activity mCurrentActivity) { this.mCurrentActivity = mCurrentActivity; } }   没有特别多的代码, 但是有一行代码(FlutterMain.startInitialization), 应该和 Flutter 框架的初始化有关.\nFlutter 框架初始化  io.flutter.view.FlutterMain#startInitialization(android.content.Context, io.flutter.view.FlutterMain.Settings)\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static void startInitialization(@NonNull Context applicationContext, @NonNull Settings settings) { if (Looper.myLooper() != Looper.getMainLooper()) { throw new IllegalStateException(\u0026#34;startInitialization must be called on the main thread\u0026#34;); } // Do not run startInitialization more than once.  if (sSettings != null) { return; } sSettings = settings; long initStartTimestampMillis = SystemClock.uptimeMillis(); initConfig(applicationContext); initResources(applicationContext); // 加载 libflutter.so  System.loadLibrary(\u0026#34;flutter\u0026#34;); VsyncWaiter .getInstance((WindowManager) applicationContext.getSystemService(Context.WINDOW_SERVICE)) .init(); // We record the initialization time using SystemClock because at the start of the  // initialization we have not yet loaded the native library to call into dart_tools_api.h.  // To get Timeline timestamp of the start of initialization we simply subtract the delta  // from the Timeline timestamp at the current moment (the assumption is that the overhead  // of the JNI call is negligible).  long initTimeMillis = SystemClock.uptimeMillis() - initStartTimestampMillis; FlutterJNI.nativeRecordStartTimestamp(initTimeMillis); }    initConfig\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private static void initConfig(@NonNull Context applicationContext) { Bundle metadata = getApplicationInfo(applicationContext).metaData; if (metadata == null) { return; } // 读取一些文件名配置, 其对应的默认值就是上面打包的文件名  //libapp.so  sAotSharedLibraryName = metadata.getString(PUBLIC_AOT_SHARED_LIBRARY_NAME, DEFAULT_AOT_SHARED_LIBRARY_NAME); //flutter_assets  sFlutterAssetsDir = metadata.getString(PUBLIC_FLUTTER_ASSETS_DIR_KEY, DEFAULT_FLUTTER_ASSETS_DIR); //vm_snapshot_data  sVmSnapshotData = metadata.getString(PUBLIC_VM_SNAPSHOT_DATA_KEY, DEFAULT_VM_SNAPSHOT_DATA); //isolate_snapshot_data  sIsolateSnapshotData = metadata.getString(PUBLIC_ISOLATE_SNAPSHOT_DATA_KEY, DEFAULT_ISOLATE_SNAPSHOT_DATA); }    initResources\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private static void initResources(@NonNull Context applicationContext) { new ResourceCleaner(applicationContext).start(); // 如果是 Debug 模式则把下面的文件从 assets/flutter_assets 目录中拷到 /data/data/packageName/app_flutter 目录中  if (BuildConfig.DEBUG) { final String dataDirPath = PathUtils.getDataDirectory(applicationContext); final String packageName = applicationContext.getPackageName(); final PackageManager packageManager = applicationContext.getPackageManager(); final AssetManager assetManager = applicationContext.getResources().getAssets(); sResourceExtractor = new ResourceExtractor(dataDirPath, packageName, packageManager, assetManager); // 拷贝的刚好是 debug 模式下打包多出的 3 个文件  sResourceExtractor .addResource(fromFlutterAssets(sVmSnapshotData)) .addResource(fromFlutterAssets(sIsolateSnapshotData)) .addResource(fromFlutterAssets(DEFAULT_KERNEL_BLOB)); sResourceExtractor.start(); } }    libflutter.so 被加载时会运行的源码 shell/platform/android/library_loader.cc\n 其在 JNI_OnLoad 中做了两件事:\n 为 FlutterJNI 类注册 JNI 方法签名 把 cpp 代码要用到的 Java 方法, 在 FlutterJNI 类里找到 jmethodID, 并用 static 变量存起来  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // This is called by the VM when the shared library is first loaded. JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { // Initialize the Java VM.  fml::jni::InitJavaVM(vm); JNIEnv* env = fml::jni::AttachCurrentThread(); bool result = false; // Register FlutterMain.  result = flutter::FlutterMain::Register(env); FML_CHECK(result); // Register PlatformView  result = flutter::PlatformViewAndroid::Register(env); FML_CHECK(result); // Register VSyncWaiter.  result = flutter::VsyncWaiterAndroid::Register(env); FML_CHECK(result); return JNI_VERSION_1_4; }    FlutterMain::Register 方法\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  bool FlutterMain::Register(JNIEnv* env) { // 注册了两个方法:  // void nativeInit(Context, String, String, String, String)  // void nativeRecordStartTimestamp(long)  static const JNINativeMethod methods[] = { { .name = \u0026#34;nativeInit\u0026#34;, .signature = \u0026#34;(Landroid/content/Context;[Ljava/lang/String;Ljava/\u0026#34; \u0026#34;lang/String;Ljava/lang/String;Ljava/lang/String;)V\u0026#34;, .fnPtr = reinterpret_cast\u0026lt;void*\u0026gt;(\u0026amp;Init), }, { .name = \u0026#34;nativeRecordStartTimestamp\u0026#34;, .signature = \u0026#34;(J)V\u0026#34;, .fnPtr = reinterpret_cast\u0026lt;void*\u0026gt;(\u0026amp;RecordStartTimestamp), }, }; jclass clazz = env-\u0026gt;FindClass(\u0026#34;io/flutter/embedding/engine/FlutterJNI\u0026#34;); if (clazz == nullptr) { return false; } return env-\u0026gt;RegisterNatives(clazz, methods, fml::size(methods)) == 0; }   PlatformViewAndroid::Register 和 VsyncWaiterAndroid::Register 与上面类似.\n 回到 startInitialization 的 VsyncWaiter init\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public class VsyncWaiter { private static VsyncWaiter instance; @NonNull private final WindowManager windowManager; public void init() { // 把 this.asyncWaitForVsyncDelegate 存到 FlutterJNI 的 static 变量 asyncWaitForVsyncDelegate 中  // 当 FlutterJNI 的 asyncWaitForVsync 方法被 native 层调用时就会回调 asyncWaitForVsyncDelegate 的 asyncWaitForVsync 方法  // asyncWaitForVsync 方法执行时会 post 一个在下一个 Vsync 信号来时的回调到 Choreographer  FlutterJNI.setAsyncWaitForVsyncDelegate(this.asyncWaitForVsyncDelegate); float fps = this.windowManager.getDefaultDisplay().getRefreshRate(); FlutterJNI.setRefreshRateFPS(fps); } private final AsyncWaitForVsyncDelegate asyncWaitForVsyncDelegate = new AsyncWaitForVsyncDelegate() { public void asyncWaitForVsync(final long cookie) { Choreographer.getInstance().postFrameCallback(new FrameCallback() { // doFrame 将在下一个 Vsync 信号来时被调用  public void doFrame(long frameTimeNanos) { float fps = VsyncWaiter.this.windowManager.getDefaultDisplay().getRefreshRate(); long refreshPeriodNanos = (long)(1.0E9D / (double)fps); // 调用 shell/platform/android/vsync_waiter_android.cc#OnNativeVsync  FlutterJNI.nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie); } }); } }; @NonNull public static VsyncWaiter getInstance(@NonNull WindowManager windowManager) { if (instance == null) { instance = new VsyncWaiter(windowManager); } return instance; } private VsyncWaiter(@NonNull WindowManager windowManager) { this.windowManager = windowManager; } }   至此, FlutterApplication onCreate 执行完毕, 主要做了:\n 加载 libflutter.so 如果是 debug 模式, 一些资源文件会被写到外部 注册了 Vsync 监听.  MainActivity 启动 接着看下 MainActivity 的代码:\n1 2 3 4 5 6 7 8  public class MainActivity extends FlutterActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 一些自己创建的 plugin 的注册  GeneratedPluginRegistrant.registerWith(this); } }   没有特殊逻辑, 但是也没有 Android 开发中常见的 setContentView. 进入父类 FlutterActivity 看下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  public class FlutterActivity extends Activity implements Provider, PluginRegistry, ViewFactory { private static final String TAG = \u0026#34;FlutterActivity\u0026#34;; // 创建 FlutterActivityDelegate 对象  private final FlutterActivityDelegate delegate = new FlutterActivityDelegate(this, this); private final FlutterActivityEvents eventDelegate; private final Provider viewProvider; private final PluginRegistry pluginRegistry; public FlutterActivity() { this.eventDelegate = this.delegate; this.viewProvider = this.delegate; this.pluginRegistry = this.delegate; } public FlutterView getFlutterView() { return this.viewProvider.getFlutterView(); } public FlutterView createFlutterView(Context context) { return null; } public FlutterNativeView createFlutterNativeView() { return null; } public boolean retainFlutterNativeView() { return false; } //...  public final Registrar registrarFor(String pluginKey) { return this.pluginRegistry.registrarFor(pluginKey); } protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); this.eventDelegate.onCreate(savedInstanceState); } protected void onStart() { super.onStart(); this.eventDelegate.onStart(); } public void onBackPressed() { if (!this.eventDelegate.onBackPressed()) { super.onBackPressed(); } } protected void onPostResume() { super.onPostResume(); this.eventDelegate.onPostResume(); } //... 省略其他几个回调 }   FlutterActivity 继承了 Android 原生的 Activity, 实现了 3 个接口 Provider PluginRegistry ViewFactory.\n 将 Activity 的生命周期回调都代理给 FlutterActivityDelegate 处理 涉及 FlutterView 的, 则交给 viewProvider 处理 涉及 Plugin 的, 交给 pluginRegistry 处理  onCreate 既然 onCreate 交给了 FlutterActivityDelegate 处理, 就看下这个 onCreate 里做了什么:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  public void onCreate(Bundle savedInstanceState) { //...  String[] args = getArgsFromIntent(this.activity.getIntent()); FlutterMain.ensureInitializationComplete(this.activity.getApplicationContext(), args); // viewFactory 即是 FlutterActivity, FlutterActivity 中 createFlutterView 返回的是 null  this.flutterView = this.viewFactory.createFlutterView(this.activity); if (this.flutterView == null) { // FlutterActivity 中 createFlutterNativeView 返回的是 null  FlutterNativeView nativeView = this.viewFactory.createFlutterNativeView(); // 构造一个 FlutterView  this.flutterView = new FlutterView(this.activity, (AttributeSet)null, nativeView); // matchParent: 一个静态 LayoutParams 变量, 宽高都 MATCH_PARENT  this.flutterView.setLayoutParams(matchParent); // 熟悉的味道: 调用 FlutterActivity 的 setContentView, 将 FlutterView 添加到 Activity 的 ANDROID_CONTENT 布局里  this.activity.setContentView(this.flutterView); // 创建闪屏  this.launchView = this.createLaunchView(); if (this.launchView != null) { // 将闪屏添加到布局最上层, 闪屏结束之后, 会 remove launchView. 具体见 addLaunchView()  this.addLaunchView(); } } //... }   通过 FlutterActivityDelegate 的 onCreate, 看到了 FlutterActivity 是怎样显示出来的, 以及闪屏是怎样添加的. 但是还没有看到 Flutter 框架是怎么开始运行的.\nensureInitializationComplete 注意在 setContentView 之前, 有个调用 FlutterMain.ensureInitializationComplete, 貌似与 Flutter 的初始化有关.\n io.flutter.view.FlutterMain#ensureInitializationComplete\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public static void ensureInitializationComplete(@NonNull Context applicationContext, @Nullable String[] args) { if (!isRunningInRobolectricTest) { //...  } else if (!sInitialized) { // sInitialized 初始值是 false, 开始肯定走到这里  try { // 添加一些参数  List\u0026lt;String\u0026gt; shellArgs = new ArrayList\u0026lt;\u0026gt;(); shellArgs.add(\u0026#34;--icu-symbol-prefix=_binary_icudtl_dat\u0026#34;); ApplicationInfo applicationInfo = getApplicationInfo(applicationContext); // libflutter.so  shellArgs.add(\u0026#34;--icu-native-lib-path=\u0026#34; + applicationInfo.nativeLibraryDir + File.separator + DEFAULT_LIBRARY); if (args != null) { Collections.addAll(shellArgs, args); } String kernelPath = null; if (BuildConfig.DEBUG) { // DEBUG 下把多出的 3 个文件也添加  String snapshotAssetPath = PathUtils.getDataDirectory(applicationContext) + File.separator + sFlutterAssetsDir; kernelPath = snapshotAssetPath + File.separator + DEFAULT_KERNEL_BLOB; shellArgs.add(\u0026#34;--\u0026#34; + SNAPSHOT_ASSET_PATH_KEY + \u0026#34;=\u0026#34; + snapshotAssetPath); shellArgs.add(\u0026#34;--\u0026#34; + VM_SNAPSHOT_DATA_KEY + \u0026#34;=\u0026#34; + sVmSnapshotData); shellArgs.add(\u0026#34;--\u0026#34; + ISOLATE_SNAPSHOT_DATA_KEY + \u0026#34;=\u0026#34; + sIsolateSnapshotData); } else { // Relase 下则把 libapp.so 添加  shellArgs.add(\u0026#34;--\u0026#34; + AOT_SHARED_LIBRARY_NAME + \u0026#34;=\u0026#34; + sAotSharedLibraryName); // Most devices can load the AOT shared library based on the library name  // with no directory path. Provide a fully qualified path to the library  // as a workaround for devices where that fails.  shellArgs.add(\u0026#34;--\u0026#34; + AOT_SHARED_LIBRARY_NAME + \u0026#34;=\u0026#34; + applicationInfo.nativeLibraryDir + File.separator + sAotSharedLibraryName); } shellArgs.add(\u0026#34;--cache-dir-path=\u0026#34; + PathUtils.getCacheDirectory(applicationContext)); if (sSettings.getLogTag() != null) { shellArgs.add(\u0026#34;--log-tag=\u0026#34; + sSettings.getLogTag()); } // 调用 FlutterJNI nativeInit  FlutterJNI.nativeInit(applicationContext, (String[])shellArgs.toArray(new String[0]), kernelPath, appStoragePath, engineCachesPath); sInitialized = true; } catch (Exception var7) { Log.e(\u0026#34;FlutterMain\u0026#34;, \u0026#34;Flutter initialization failed.\u0026#34;, var7); throw new RuntimeException(var7); } } } }   FlutterJNI.nativeInit 对应的 native 方法为 FlutterMain::Init:\n shell/platform/android/flutter_main.cc\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  void FlutterMain::Init(JNIEnv* env, jclass clazz, jobject context, jobjectArray jargs, jstring kernelPath, jstring appStoragePath, jstring engineCachesPath) { std::vector\u0026lt;std::string\u0026gt; args; args.push_back(\u0026#34;flutter\u0026#34;); for (auto\u0026amp; arg : fml::jni::StringArrayToVector(env, jargs)) { args.push_back(std::move(arg)); } auto command_line = fml::CommandLineFromIterators(args.begin(), args.end()); // 根据传递的 args 创建 Settings 对象  auto settings = SettingsFromCommandLine(command_line); flutter::DartCallbackCache::SetCachePath(fml::jni::JavaStringToString(env, appStoragePath)); fml::paths::InitializeAndroidCachesPath(fml::jni::JavaStringToString(env, engineCachesPath)); flutter::DartCallbackCache::LoadCacheFromDisk(); if (!flutter::DartVM::IsRunningPrecompiledCode() \u0026amp;\u0026amp; kernelPath) { auto application_kernel_path = fml::jni::JavaStringToString(env, kernelPath); if (fml::IsFile(application_kernel_path)) { settings.application_kernel_asset = application_kernel_path; } } // 创建一个新的 FlutterMain 对象, 赋给 g_flutter_main 这个全局对象  g_flutter_main.reset(new FlutterMain(std::move(settings))); // 调用 FlutterMain 的 SetupObservatoryUriCallback 方法  g_flutter_main-\u0026gt;SetupObservatoryUriCallback(env); }    FlutterMain 的构造函数, 使用初始化列表方式\n 1 2  FlutterMain::FlutterMain(flutter::Settings settings) : settings_(std::move(settings)), observatory_uri_callback_() {}    SetupObservatoryUriCallback\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  void FlutterMain::SetupObservatoryUriCallback(JNIEnv* env) { g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef\u0026lt;jclass\u0026gt;( env, env-\u0026gt;FindClass(\u0026#34;io/flutter/embedding/engine/FlutterJNI\u0026#34;)); if (g_flutter_jni_class-\u0026gt;is_null()) { return; } jfieldID uri_field = env-\u0026gt;GetStaticFieldID( g_flutter_jni_class-\u0026gt;obj(), \u0026#34;observatoryUri\u0026#34;, \u0026#34;Ljava/lang/String;\u0026#34;); if (uri_field == nullptr) { return; } auto set_uri = [env, uri_field](std::string uri) { fml::jni::ScopedJavaLocalRef\u0026lt;jstring\u0026gt; java_uri = fml::jni::StringToJavaString(env, uri); env-\u0026gt;SetStaticObjectField(g_flutter_jni_class-\u0026gt;obj(), uri_field, java_uri.obj()); }; fml::MessageLoop::EnsureInitializedForCurrentThread(); fml::RefPtr\u0026lt;fml::TaskRunner\u0026gt; platform_runner = fml::MessageLoop::GetCurrent().GetTaskRunner(); // 为 observatory_uri_callback_ 赋值  observatory_uri_callback_ = DartServiceIsolate::AddServerStatusCallback( [platform_runner, set_uri](std::string uri) { platform_runner-\u0026gt;PostTask([uri, set_uri] { set_uri(uri); }); }); }   至此, ensureInitializationComplete 流程结束, 只是为全局指针 g_flutter_main 赋了一个 FlutterMain 对象, 还没发现与 Flutter 或 Dart 运行相关的流程. 所以, 回到 onCreate 中, 进入 FlutterView 看下.\nFlutterView 由上文可知, FlutterView 是在 FlutterActivity onCreate 时创建的, FlutterView 的构造函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  public FlutterView(Context context, AttributeSet attrs, FlutterNativeView nativeView) { super(context, attrs); Activity activity = getActivity(getContext()); if (activity == null) { throw new IllegalArgumentException(\u0026#34;Bad context\u0026#34;); } if (nativeView == null) { // FlutterActivity 默认传递的 null  mNativeView = new FlutterNativeView(activity.getApplicationContext()); } else { mNativeView = nativeView; } // 从 FlutterNativeView 中获取 DartExecutor  // 暂且把 DartExecutor 看做 Dart 的执行器 ?  dartExecutor = mNativeView.getDartExecutor(); // 创建 FlutterRenderer  flutterRenderer = new FlutterRenderer(mNativeView.getFlutterJNI()); mIsSoftwareRenderingEnabled = mNativeView.getFlutterJNI().nativeGetIsSoftwareRenderingEnabled(); mMetrics = new ViewportMetrics(); mMetrics.devicePixelRatio = context.getResources().getDisplayMetrics().density; setFocusable(true); setFocusableInTouchMode(true); mNativeView.attachViewAndActivity(this, activity); mSurfaceCallback = new SurfaceHolder.Callback() { @Override public void surfaceCreated(SurfaceHolder holder) { assertAttached(); // 调到 platform_view_anroid_jni.cc#SurfaceCreated  mNativeView.getFlutterJNI().onSurfaceCreated(holder.getSurface()); } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { assertAttached(); // 调到 platform_view_anroid_jni.cc#SurfaceChanged  mNativeView.getFlutterJNI().onSurfaceChanged(width, height); } @Override public void surfaceDestroyed(SurfaceHolder holder) { assertAttached(); // 调到 platform_view_anroid_jni.cc#SurfaceDestroyed  mNativeView.getFlutterJNI().onSurfaceDestroyed(); } }; // FlutterView 继承了 SurfaceView, 所以有 SurfaceHolder, 注册 mSurfaceCallback  getHolder().addCallback(mSurfaceCallback); mActivityLifecycleListeners = new ArrayList\u0026lt;\u0026gt;(); mFirstFrameListeners = new ArrayList\u0026lt;\u0026gt;(); // Create all platform channels  navigationChannel = new NavigationChannel(dartExecutor); keyEventChannel = new KeyEventChannel(dartExecutor); lifecycleChannel = new LifecycleChannel(dartExecutor); localizationChannel = new LocalizationChannel(dartExecutor); platformChannel = new PlatformChannel(dartExecutor); systemChannel = new SystemChannel(dartExecutor); settingsChannel = new SettingsChannel(dartExecutor); // Create and setup plugins  PlatformPlugin platformPlugin = new PlatformPlugin(activity, platformChannel); addActivityLifecycleListener(new ActivityLifecycleListener() { @Override public void onPostResume() { platformPlugin.updateSystemUiOverlays(); } }); mImm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); PlatformViewsController platformViewsController = mNativeView.getPluginRegistry().getPlatformViewsController(); // 以下几位顾名思义一下?  mTextInputPlugin = new TextInputPlugin(this, dartExecutor, platformViewsController); androidKeyProcessor = new AndroidKeyProcessor(keyEventChannel, mTextInputPlugin); androidTouchProcessor = new AndroidTouchProcessor(flutterRenderer); mNativeView.getPluginRegistry().getPlatformViewsController().attachTextInputPlugin(mTextInputPlugin); // Send initial platform information to Dart  sendLocalesToDart(getResources().getConfiguration()); sendUserPlatformSettingsToDart(); }   可见在 FlutterView 创建时进行了许多工作, 其中 FlutterNativeView 负责了许多, 而且在这里终于见到 Dart 的影子了.\nFlutterNativeView 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // Flutter UI Display 回调 private final FlutterUiDisplayListener flutterUiDisplayListener = new FlutterUiDisplayListener() { @Override public void onFlutterUiDisplayed() { if (mFlutterView == null) { return; } mFlutterView.onFirstFrame(); } @Override public void onFlutterUiNoLongerDisplayed() { // no-op  } }; public FlutterNativeView(@NonNull Context context, boolean isBackgroundView) { mContext = context; mPluginRegistry = new FlutterPluginRegistry(this, context); mFlutterJNI = new FlutterJNI(); // 将 flutterUiDisplayListener 添加到 FlutterJNI 的 flutterUiDisplayListeners 中, native 会在 Flutter 第一帧渲染时回调  mFlutterJNI.addIsDisplayingFlutterUiListener(flutterUiDisplayListener); this.dartExecutor = new DartExecutor(mFlutterJNI, context.getAssets()); // FlutterJNI 中的 EngineLifecycleListener 会被 native 在 FlutterEngine 重启时回调  mFlutterJNI.addEngineLifecycleListener(new EngineLifecycleListenerImpl()); attach(this, isBackgroundView); assertAttached(); } private void attach(FlutterNativeView view, boolean isBackgroundView) { // 调用 platform_view_anroid_jni.cc#AttachJNI  mFlutterJNI.attachToNative(isBackgroundView); // 注册 platform message handler 到 Dart 的执行上下文中  dartExecutor.onAttachedToJNI(); }   AttachJNI  platform_view_anroid_jni.cc#AttachJNI\n 1 2 3 4 5 6 7 8 9 10 11  static jlong AttachJNI(JNIEnv* env, jclass clazz, jobject flutterJNI, jboolean is_background_view) { // 为 flutterJNI 对象创建一个 WeakGlobalRef  fml::jni::JavaObjectWeakGlobalRef java_object(env, flutterJNI); // 构造一个 AndroidShellHolder 对象, 由 FlutterView.java 构造 FlutterNativeView 可知, is_background_view 为 false  auto shell_holder = std::make_unique\u0026lt;AndroidShellHolder\u0026gt;(FlutterMain::Get().GetSettings(), java_object, is_background_view); if (shell_holder-\u0026gt;IsValid()) { return reinterpret_cast\u0026lt;jlong\u0026gt;(shell_holder.release()); } else { return 0; } }    shell/platform/android/android_shell_holder.cc#AndroidShellHolder\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106  AndroidShellHolder::AndroidShellHolder( flutter::Settings settings, fml::jni::JavaObjectWeakGlobalRef java_object, bool is_background_view) : settings_(std::move(settings)), java_object_(java_object) { static size_t shell_count = 1; auto thread_label = std::to_string(shell_count++); // 调用 pthread_key_create 创建一个线程本地变量, 当线程释放是会调用 ThreadDestructCallback  // FML_CHECK 是一个工具方法, 当传递的 condition 为 false 时会打印日志  FML_CHECK(pthread_key_create(\u0026amp;thread_destruct_key_, ThreadDestructCallback) == 0); if (is_background_view) { } else { // 创建 UI,GPU,IO 线程  // thread_label.ui thread_label.gpu thread_label.io  thread_host_ = {thread_label, ThreadHost::Type::UI | ThreadHost::Type::GPU | ThreadHost::Type::IO}; } // Detach from JNI when the UI and GPU threads exit.  // 创建一个 closure, 执行时把 thread_destruct_key_ 存储的值设为 void  auto jni_exit_task([key = thread_destruct_key_]() { FML_CHECK(pthread_setspecific(key, reinterpret_cast\u0026lt;void*\u0026gt;(1)) == 0); }); thread_host_.ui_thread-\u0026gt;GetTaskRunner()-\u0026gt;PostTask(jni_exit_task); if (!is_background_view) { thread_host_.gpu_thread-\u0026gt;GetTaskRunner()-\u0026gt;PostTask(jni_exit_task); } // WeakPtr 的空构造函数相当于赋值 nullptr  fml::WeakPtr\u0026lt;PlatformViewAndroid\u0026gt; weak_platform_view; // on_create_platform_view 回调  Shell::CreateCallback\u0026lt;PlatformView\u0026gt; on_create_platform_view = [is_background_view, java_object, \u0026amp;weak_platform_view](Shell\u0026amp; shell) { std::unique_ptr\u0026lt;PlatformViewAndroid\u0026gt; platform_view_android; if (is_background_view) { } else { // 构造一个 PlatformViewAndroid  platform_view_android = std::make_unique\u0026lt;PlatformViewAndroid\u0026gt;( shell, // delegate  shell.GetTaskRunners(), // task runners  java_object, // java object handle for JNI interop  shell.GetSettings() .enable_software_rendering // use software rendering  ); } // 赋给 weak_platform_view  weak_platform_view = platform_view_android-\u0026gt;GetWeakPtr(); return platform_view_android; }; Shell::CreateCallback\u0026lt;Rasterizer\u0026gt; on_create_rasterizer = [](Shell\u0026amp; shell) { return std::make_unique\u0026lt;Rasterizer\u0026gt;(shell, shell.GetTaskRunners()); }; // The current thread will be used as the platform thread. Ensure that the message loop is initialized.  // 确保当前线程的 MessageLoop 已经创建  fml::MessageLoop::EnsureInitializedForCurrentThread(); fml::RefPtr\u0026lt;fml::TaskRunner\u0026gt; gpu_runner; fml::RefPtr\u0026lt;fml::TaskRunner\u0026gt; ui_runner; fml::RefPtr\u0026lt;fml::TaskRunner\u0026gt; io_runner; fml::RefPtr\u0026lt;fml::TaskRunner\u0026gt; platform_runner = fml::MessageLoop::GetCurrent().GetTaskRunner(); if (is_background_view) { } else { // 获取每个线程的 TaskRunner, 通过 TaskRunner 可以传递 task 到线程的 MessageLoop 中  gpu_runner = thread_host_.gpu_thread-\u0026gt;GetTaskRunner(); ui_runner = thread_host_.ui_thread-\u0026gt;GetTaskRunner(); io_runner = thread_host_.io_thread-\u0026gt;GetTaskRunner(); } flutter::TaskRunners task_runners(thread_label, // label  platform_runner, // platform  gpu_runner, // gpu  ui_runner, // ui  io_runner // io  ); // 创建 Shell  shell_ = Shell::Create(task_runners, // task runners  settings_, // settings  on_create_platform_view, // platform view create callback  on_create_rasterizer // rasterizer create callback  ); platform_view_ = weak_platform_view; FML_DCHECK(platform_view_); is_valid_ = shell_ != nullptr; if (is_valid_) { task_runners.GetGPUTaskRunner()-\u0026gt;PostTask([]() { // Android describes -8 as \u0026#34;most important display threads, for  // compositing the screen and retrieving input events\u0026#34;. Conservatively  // set the GPU thread to slightly lower priority than it.  if (::setpriority(PRIO_PROCESS, gettid(), -5) != 0) { // Defensive fallback. Depending on the OEM, it may not be possible  // to set priority to -5.  if (::setpriority(PRIO_PROCESS, gettid(), -2) != 0) { FML_LOG(ERROR) \u0026lt;\u0026lt; \u0026#34;Failed to set GPU task runner priority\u0026#34;; } } }); task_runners.GetUITaskRunner()-\u0026gt;PostTask([]() { if (::setpriority(PRIO_PROCESS, gettid(), -1) != 0) { FML_LOG(ERROR) \u0026lt;\u0026lt; \u0026#34;Failed to set UI task runner priority\u0026#34;; } }); } }    ThreadHost\n engine 使用到的所有线程的集合, 从中能看出 engine 一共使用了 4 个线程.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  struct ThreadHost { enum Type { Platform = 1 \u0026lt;\u0026lt; 0, UI = 1 \u0026lt;\u0026lt; 1, GPU = 1 \u0026lt;\u0026lt; 2, IO = 1 \u0026lt;\u0026lt; 3, }; std::unique_ptr\u0026lt;fml::Thread\u0026gt; platform_thread; std::unique_ptr\u0026lt;fml::Thread\u0026gt; ui_thread; std::unique_ptr\u0026lt;fml::Thread\u0026gt; gpu_thread; std::unique_ptr\u0026lt;fml::Thread\u0026gt; io_thread; }; // 实现 ThreadHost::ThreadHost(std::string name_prefix, uint64_t mask) { if (mask \u0026amp; ThreadHost::Type::Platform) { platform_thread = std::make_unique\u0026lt;fml::Thread\u0026gt;(name_prefix + \u0026#34;.platform\u0026#34;); } if (mask \u0026amp; ThreadHost::Type::UI) { ui_thread = std::make_unique\u0026lt;fml::Thread\u0026gt;(name_prefix + \u0026#34;.ui\u0026#34;); } if (mask \u0026amp; ThreadHost::Type::GPU) { gpu_thread = std::make_unique\u0026lt;fml::Thread\u0026gt;(name_prefix + \u0026#34;.gpu\u0026#34;); } if (mask \u0026amp; ThreadHost::Type::IO) { io_thread = std::make_unique\u0026lt;fml::Thread\u0026gt;(name_prefix + \u0026#34;.io\u0026#34;); } }    shell/common/shell.cc\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  std::unique_ptr\u0026lt;Shell\u0026gt; Shell::Create( TaskRunners task_runners, Settings settings, Shell::CreateCallback\u0026lt;PlatformView\u0026gt; on_create_platform_view, Shell::CreateCallback\u0026lt;Rasterizer\u0026gt; on_create_rasterizer) { // 创建 DartVM  auto vm = DartVMRef::Create(settings); auto vm_data = vm-\u0026gt;GetVMData(); return Shell::Create(std::move(task_runners), //  std::move(settings), //  vm_data-\u0026gt;GetIsolateSnapshot(), // isolate snapshot  DartSnapshot::Empty(), // shared snapshot  std::move(on_create_platform_view), //  std::move(on_create_rasterizer), //  std::move(vm) //  ); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  std::unique_ptr\u0026lt;Shell\u0026gt; Shell::Create( TaskRunners task_runners, Settings settings, fml::RefPtr\u0026lt;const DartSnapshot\u0026gt; isolate_snapshot, fml::RefPtr\u0026lt;const DartSnapshot\u0026gt; shared_snapshot, Shell::CreateCallback\u0026lt;PlatformView\u0026gt; on_create_platform_view, Shell::CreateCallback\u0026lt;Rasterizer\u0026gt; on_create_rasterizer, DartVMRef vm) { if (!task_runners.IsValid() || !on_create_platform_view || !on_create_rasterizer) { return nullptr; } fml::AutoResetWaitableEvent latch; std::unique_ptr\u0026lt;Shell\u0026gt; shell; // 立即运行或者将 task post 到 MessageLoop 中  fml::TaskRunner::RunNowOrPostTask( task_runners.GetPlatformTaskRunner(), { shell = CreateShellOnPlatformThread(std::move(vm), std::move(task_runners), settings, std::move(isolate_snapshot), std::move(shared_snapshot), on_create_platform_view, on_create_rasterizer); latch.Signal(); }); // 等待, 直到 CreateShellOnPlatformThread 完成  latch.Wait(); return shell; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  std::unique_ptr\u0026lt;Shell\u0026gt; Shell::CreateShellOnPlatformThread( DartVMRef vm, TaskRunners task_runners, Settings settings, fml::RefPtr\u0026lt;const DartSnapshot\u0026gt; isolate_snapshot, fml::RefPtr\u0026lt;const DartSnapshot\u0026gt; shared_snapshot, Shell::CreateCallback\u0026lt;PlatformView\u0026gt; on_create_platform_view, Shell::CreateCallback\u0026lt;Rasterizer\u0026gt; on_create_rasterizer) { if (!task_runners.IsValid()) { return nullptr; } auto shell = std::unique_ptr\u0026lt;Shell\u0026gt;(new Shell(std::move(vm), task_runners, settings)); // 在 GPU 线程创建 光栅化器 Rasterizer  std::promise\u0026lt;std::unique_ptr\u0026lt;Rasterizer\u0026gt;\u0026gt; rasterizer_promise; auto rasterizer_future = rasterizer_promise.get_future(); fml::TaskRunner::RunNowOrPostTask( task_runners.GetGPUTaskRunner(), [\u0026amp;rasterizer_promise, //  on_create_rasterizer, //  shell = shell.get() //  ]() { rasterizer_promise.set_value(on_create_rasterizer(*shell)); }); // 创建 PlatformViewAndroid 在 platform 线程(当前线程)  auto platform_view = on_create_platform_view(*shell.get()); if (!platform_view || !platform_view-\u0026gt;GetWeakPtr()) { return nullptr; } // Ask the platform view for the vsync waiter. This will be used by the engine  // to create the animator.  auto vsync_waiter = platform_view-\u0026gt;CreateVSyncWaiter(); if (!vsync_waiter) { return nullptr; } // Create the IO manager on the IO thread. The IO manager must be initialized  // first because it has state that the other subsystems depend on. It must  // first be booted and the necessary references obtained to initialize the  // other subsystems.  std::promise\u0026lt;std::unique_ptr\u0026lt;ShellIOManager\u0026gt;\u0026gt; io_manager_promise; auto io_manager_future = io_manager_promise.get_future(); std::promise\u0026lt;fml::WeakPtr\u0026lt;ShellIOManager\u0026gt;\u0026gt; weak_io_manager_promise; auto weak_io_manager_future = weak_io_manager_promise.get_future(); auto io_task_runner = shell-\u0026gt;GetTaskRunners().GetIOTaskRunner(); // TODO(gw280): The WeakPtr here asserts that we are derefing it on the  // same thread as it was created on. We are currently on the IO thread  // inside this lambda but we need to deref the PlatformView, which was  // constructed on the platform thread.  //  // https://github.com/flutter/flutter/issues/42948  fml::TaskRunner::RunNowOrPostTask( io_task_runner, [\u0026amp;io_manager_promise, //  \u0026amp;weak_io_manager_promise, //  platform_view = platform_view-\u0026gt;GetWeakPtr(), //  io_task_runner //  ]() { auto io_manager = std::make_unique\u0026lt;ShellIOManager\u0026gt;( platform_view.getUnsafe()-\u0026gt;CreateResourceContext(), io_task_runner); weak_io_manager_promise.set_value(io_manager-\u0026gt;GetWeakPtr()); io_manager_promise.set_value(std::move(io_manager)); }); // Send dispatcher_maker to the engine constructor because shell won\u0026#39;t have  // platform_view set until Shell::Setup is called later.  auto dispatcher_maker = platform_view-\u0026gt;GetDispatcherMaker(); // Create the engine on the UI thread.  std::promise\u0026lt;std::unique_ptr\u0026lt;Engine\u0026gt;\u0026gt; engine_promise; auto engine_future = engine_promise.get_future(); fml::TaskRunner::RunNowOrPostTask( shell-\u0026gt;GetTaskRunners().GetUITaskRunner(), fml::MakeCopyable([\u0026amp;engine_promise, //  shell = shell.get(), //  \u0026amp;dispatcher_maker, //  isolate_snapshot = std::move(isolate_snapshot), //  shared_snapshot = std::move(shared_snapshot), //  vsync_waiter = std::move(vsync_waiter), //  \u0026amp;weak_io_manager_future //  ]() mutable { const auto\u0026amp; task_runners = shell-\u0026gt;GetTaskRunners(); // The animator is owned by the UI thread but it gets its vsync pulses  // from the platform.  auto animator = std::make_unique\u0026lt;Animator\u0026gt;(*shell, task_runners, std::move(vsync_waiter)); // 构造 Engine 对象  engine_promise.set_value(std::make_unique\u0026lt;Engine\u0026gt;( *shell, dispatcher_maker, *shell-\u0026gt;GetDartVM(), std::move(isolate_snapshot), std::move(shared_snapshot), task_runners, shell-\u0026gt;GetSettings(), std::move(animator), weak_io_manager_future.get() )); })); if (!shell-\u0026gt;Setup(std::move(platform_view), engine_future.get(), rasterizer_future.get(), io_manager_future.get()) ) { return nullptr; } return shell; }    shell/common/engine.cc\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  runtime_controller_ = std::make_unique\u0026lt;RuntimeController\u0026gt;( *this, // runtime delegate  \u0026amp;vm, // VM  std::move(isolate_snapshot), // isolate snapshot  std::move(shared_snapshot), // shared snapshot  task_runners_, // task runners  std::move(io_manager), // io manager  image_decoder_.GetWeakPtr(), // image decoder  settings_.advisory_script_uri, // advisory script uri 在 Setting 对象默认为 main.dart  settings_.advisory_script_entrypoint, // advisory script entrypoint 在 Setting 对象默认为 main  settings_.idle_notification_callback, // idle notification callback  settings_.isolate_create_callback, // isolate create callback  settings_.isolate_shutdown_callback, // isolate shutdown callback  settings_.persistent_isolate_data // persistent isolate data  );   ","description":"Flutter 应用运行的本质还是原生应用的运行。那么在 Android 上, Flutter 框架是如何运行起来的呢?","id":41,"section":"posts","tags":null,"title":"Flutter 在 Android 上是如何运行起来的","uri":"https://jiyang.site/posts/2019-10-20-flutter-%E5%9C%A8-android-%E4%B8%8A%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E7%9A%84/"},{"content":"Android SDK 中的事件循环已经是一个老生常谈的问题了, 像 Handler Looper MessageQueue 这几个类也是被大家研究透彻了.\n但是再回头看以前自己的分析, 总感觉差点什么, 不够透彻. 心里隐隐感觉自己没有把事情完全吃透, 于是今日又回顾 Android 中的事件循环机制, 注意到\nMessageQueue 中获取下一条消息时会执行一个 native 调用 nativePollOnce, 翻看 Android 系统源码发现有内容.\n来自高手的解释  首先, 先梭哈一把 stackoverflow 上高手对这个问题(android - what is message queue native poll once in android?)的回答原文:\n Short answer:\nThe nativePollOnce method is used to \u0026ldquo;wait\u0026rdquo; till the next Message becomes available. If the time spent during this call is long, your main (UI) thread has no real work to do and waits for next events to process. There\u0026rsquo;s no need to worry about that.\nExplanation:\nBecause the \u0026ldquo;main\u0026rdquo; thread is responsible for drawing UI and handling various events, it\u0026rsquo;s Runnable has a loop which processes all these events. The loop is managed by a Looper and its job is quite straightforward: it processes all Messages in the MessageQueue.\nA Message is added to the queue for example in response to input events, as frame rendering callback or even your own Handler.post calls. Sometimes the main thread has no work to do (that is, no messages in the queue), which may happen e.g. just after finishing rendering single frame (the thread has just drawn one frame and is ready for the next one, just waits for a proper time). Two Java methods in the MessageQueue class are interesting to us: Message next() and boolean enqueueMessage(Message, long). Message next(), as its name suggest, takes and returns the next Message from the queue. If the queue is empty (and there\u0026rsquo;s nothing to return), the method calls native void nativePollOnce(long, int) which blocks until a new message is added. At this point you might ask how does nativePollOnce know when to wake up. That\u0026rsquo;s a very good question. When a Message is added to the queue, the framework calls the enqueueMessage method, which not only inserts the message into the queue, but also calls native static void nativeWake(long), if there\u0026rsquo;s need to wake up the queue. The core magic of nativePollOnce and nativeWake happens in the native (actually, C++) code. Native MessageQueue utilizes a Linux system call named epoll, which allows to monitor a file descriptor for IO events. nativePollOnce calls epoll_wait on a certain file descriptor, whereas nativeWake writes to the descriptor, which is one of the IO operations, epoll_wait waits for. The kernel then takes out the epoll-waiting thread from the waiting state and the thread proceeds with handling the new message. If you\u0026rsquo;re familiar with Java\u0026rsquo;s Object.wait() and Object.notify() methods, you can imagine that nativePollOnce is a rough equivalent for Object.wait() and nativeWake for Object.notify(), except they\u0026rsquo;re implemented completely differently: nativePollOnce uses epoll and Object.wait() uses futex Linux call. It\u0026rsquo;s worth noticing that neither nativePollOnce nor Object.wait() waste CPU cycles, as when a thread enters either method, it becomes disabled for thread scheduling purposes (quoting the javadoc for the Object class). However, some profilers may mistakenly recognize epoll-waiting (or even Object-waiting) threads as running and consuming CPU time, which is incorrect. If those methods actually wasted CPU cycles, all idle apps would use 100% of the CPU, heating and slowing down the device.\nConclusion:\nYou shouldn\u0026rsquo;t worry about nativePollOnce. It just indicates that processing of all Messages has been finished and the thread waits for the next one. Well, that simply means you don\u0026rsquo;t give too much work to your main thread ;)\ntranslate.google 一下 😬:\n简短答案:\nnativePollOnce 方法用于“等待”, 直到下一条消息可用为止. 如果在此调用期间花费的时间很长, 则您的主线程没有实际工作要做, 而是等待下一个事件处理.无需担心.\n说明:\n因为主线程负责绘制 UI 和处理各种事件, 所以主线程拥有一个处理所有这些事件的循环. 该循环由 L​​ooper 管理, 其工作非常简单: 它处理 MessageQueue 中的所有 Message.\n例如, 响应于输入事件, 将消息添加到队列, 帧渲染回调, 甚至您的 Handler.post 调用. 有时主线程无事可做（即队列中没有消息), 例如在完成渲染单帧之后(线程刚绘制了一帧, 并准备好下一帧, 等待适当的时间). MessageQueue 类中的两个 Java 方法对我们很有趣: Message next()和 boolean enqueueMessage(Message, long). 顾名思义, Message next() 从队列中获取并返回下一个消息. 如果队列为空(无返回值), 则该方法将调用 native void nativePollOnce(long, int), 该方法将一直阻塞直到添加新消息为止. 此时,您可能会问nativePollOnce 如何知道何时醒来. 这是一个很好的问题. 当将 Message 添加到队列时, 框架调用 enqueueMessage 方法, 该方法不仅将消息插入队列, 而且还会调用native static void nativeWake(long). nativePollOnce 和 nativeWake 的核心魔术发生在 native 代码中. native MessageQueue 利用名为 epoll 的 Linux 系统调用, 该系统调用可以监视文件描述符中的 IO 事件. nativePollOnce 在某个文件描述符上调用 epoll_wait, 而 nativeWake 写入一个 IO 操作到描述符, epoll_wait 等待. 然后, 内核从等待状态中取出 epoll 等待线程, 并且该线程继续处理新消息. 如果您熟悉 Java 的 Object.wait()和 Object.notify()方法,可以想象一下 nativePollOnce 大致等同于 Object.wait(), nativeWake 等同于 Object.notify(),但它们的实现完全不同: nativePollOnce 使用 epoll, 而 Object.wait 使用 futex Linux 调用. 值得注意的是, nativePollOnce 和 Object.wait 都不会浪费 CPU 周期, 因为当线程进入任一方法时, 出于线程调度的目的, 该线程将被禁用(引用Object类的javadoc). 但是, 某些事件探查器可能会错误地将等待 epoll 等待(甚至是 Object.wait)的线程识别为正在运行并消耗 CPU 时间, 这是不正确的. 如果这些方法实际上浪费了 CPU 周期, 则所有空闲的应用程序都将使用 100％ 的 CPU, 从而加热并降低设备速度.\n结论:\nnativePollOnce. 它只是表明所有消息的处理已完成, 线程正在等待下一个消息.\n我以前的理解分享 Linux 有多个 IO 模型:\n 阻塞 IO 非阻塞 IO IO 复用, 对应 select poll epoll 都属于基于 IO 复用模式的调用 信号驱动 IO 异步 IO  看下源码 Java 这边 enqueueMessage: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(\u0026#34;Message must have a target.\u0026#34;); } if (msg.isInUse()) { throw new IllegalStateException(msg + \u0026#34; This message is already in use.\u0026#34;); } synchronized (this) { msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when \u0026lt; p.when) { // New head, wake up the event queue if blocked.  msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don\u0026#39;t have to wake  // up the event queue unless there is a barrier at the head of the queue  // and the message is the earliest asynchronous message in the queue.  needWake = mBlocked \u0026amp;\u0026amp; p.target == null \u0026amp;\u0026amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when \u0026lt; p.when) { break; } if (needWake \u0026amp;\u0026amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next  prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false.  if (needWake) { // 这里唤醒 nativePollOnce 的沉睡  nativeWake(mPtr); } } return true; }   next: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  Message next() { //...  int pendingIdleHandlerCount = -1; // -1 only during first iteration  int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } // nativePollOnce 这里陷入沉睡, 等待唤醒  nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found.  final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null \u0026amp;\u0026amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue.  do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026amp;\u0026amp; !msg.isAsynchronous()); } if (msg != null) { if (now \u0026lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready.  nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message.  mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \u0026#34;Returning message: \u0026#34; + msg); msg.markInUse(); return msg; } } else { // No more messages.  nextPollTimeoutMillis = -1; } //...  } //...  } }   CPP 那边 nativeWake 1 2 3  void NativeMessageQueue::wake() { mLooper-\u0026gt;wake(); }   1 2 3 4 5 6 7 8 9 10 11  void Looper::wake() { uint64_t inc = 1; // 调用 write 向 mWakeEventFd 描述符写入一个事件  ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, \u0026amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) { if (errno != EAGAIN) { LOG_ALWAYS_FATAL(\u0026#34;Could not write wake signal to fd %d: %s\u0026#34;, mWakeEventFd, strerror(errno)); } } }   nativePollOnce: 1 2 3 4 5 6 7 8 9 10 11 12 13  void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) { mPollEnv = env; mPollObj = pollObj; mLooper-\u0026gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) { env-\u0026gt;Throw(mExceptionObj); env-\u0026gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) { int result = 0; for (;;) { while (mResponseIndex \u0026lt; mResponses.size()) { const Response\u0026amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident \u0026gt;= 0) { int fd = response.request.fd; int events = response.events; void* data = response.request.data; if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; } } if (result != 0) { if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; } result = pollInner(timeoutMillis); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134  int Looper::pollInner(int timeoutMillis) { // Adjust the timeout based on when the next message is due.  if (timeoutMillis != 0 \u0026amp;\u0026amp; mNextMessageUptime != LLONG_MAX) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime); if (messageTimeoutMillis \u0026gt;= 0 \u0026amp;\u0026amp; (timeoutMillis \u0026lt; 0 || messageTimeoutMillis \u0026lt; timeoutMillis)) { timeoutMillis = messageTimeoutMillis; } } // Poll.  int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; // We are about to idle.  mPolling = true; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 这里重点  int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // No longer idling.  mPolling = false; // Acquire lock.  mLock.lock(); // Rebuild epoll set if needed.  if (mEpollRebuildRequired) { mEpollRebuildRequired = false; rebuildEpollLocked(); goto Done; } // Check for poll error.  if (eventCount \u0026lt; 0) { if (errno == EINTR) { goto Done; } ALOGW(\u0026#34;Poll failed with an unexpected error: %s\u0026#34;, strerror(errno)); result = POLL_ERROR; goto Done; } // Check for poll timeout.  if (eventCount == 0) { result = POLL_TIMEOUT; goto Done; } // Handle all events.  for (int i = 0; i \u0026lt; eventCount; i++) { int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) { if (epollEvents \u0026amp; EPOLLIN) { awoken(); } else { ALOGW(\u0026#34;Ignoring unexpected epoll events 0x%x on wake event fd.\u0026#34;, epollEvents); } } else { ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex \u0026gt;= 0) { int events = 0; if (epollEvents \u0026amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents \u0026amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents \u0026amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents \u0026amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); } else { ALOGW(\u0026#34;Ignoring unexpected epoll events 0x%x on fd %d that is \u0026#34; \u0026#34;no longer registered.\u0026#34;, epollEvents, fd); } } } Done: ; // Invoke pending message callbacks.  mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) { nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope\u0026amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime \u0026lt;= now) { // Remove the envelope from the list.  // We keep a strong reference to the handler until the call to handleMessage  // finishes. Then we drop it so that the handler can be deleted *before*  // we reacquire our lock.  { // obtain handler  sp\u0026lt;MessageHandler\u0026gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-\u0026gt;handleMessage(message); } // release handler  mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; } else { // The last message left at the head of the queue determines the next wakeup time.  mNextMessageUptime = messageEnvelope.uptime; break; } } // Release lock.  mLock.unlock(); // Invoke all response callbacks.  for (size_t i = 0; i \u0026lt; mResponses.size(); i++) { Response\u0026amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) { int fd = response.request.fd; int events = response.events; void* data = response.request.data; // Invoke the callback. Note that the file descriptor may be closed by  // the callback (and potentially even reused) before the function returns so  // we need to be a little careful when removing the file descriptor afterwards.  int callbackResult = response.request.callback-\u0026gt;handleEvent(fd, events, data); if (callbackResult == 0) { removeFd(fd, response.request.seq); } // Clear the callback reference in the response structure promptly because we  // will not clear the response vector itself until the next poll.  response.request.callback.clear(); result = POLL_CALLBACK; } } return result; }   ","description":"","id":42,"section":"posts","tags":null,"title":"Android 中 MessageQueue 的 nativePollOnce","uri":"https://jiyang.site/posts/2019-10-19-android%E4%B8%ADmessagequeue%E7%9A%84nativepollonce/"},{"content":"最近阅读《Android移动性能实战》看到手机QQ测试团队给出的一个案列 「Object Ouput Stream 4000 多次的写操作」,\n其原因就是直接使用了 ObjectOutputStream + FileOutputStream 做对象的序列化到磁盘。印象中我们的项目中也有这样的代码\nSerializeUtil#serializeObject:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public static \u0026lt;Obj extends Serializable\u0026gt; boolean serializeObject(Obj o, String path) { ObjectOutputStream oo = null; boolean success = true; try { oo = new ObjectOutputStream(new FileOutputStream(path)); oo.writeObject(o); } catch (Exception ignore) { success = false; } finally { try { if (oo != null) { oo.close(); } } catch (Exception ignored) { success = false; } } return success; }   书中给出的优化方案为结合 ByteArrayOutputStream 或 BufferedOutputStream 做 Object 的序列化。\n复现问题 眼见为实，于是结合开源的 https://github.com/Tencent/matrix (据说可以检测到代码中调用底层IO的次数耗时等信息), 写个测试代码试试:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class TestObject : Serializable { val d = ByteArray(1024 * 30) val s = ArrayList\u0026lt;String\u0026gt;() init { repeat(10000) { s.add(\u0026#34;$it\u0026#34;) } } } fun writeObjectToFile(path: String, obj: Serializable) { val oos = ObjectOutputStream(FileOutputStream(path)) oos.writeObject(obj) oos.flush() oos.close() }   直接在主线程执行(目前 matrix 只能检测主线程上的 IO 操作), 结果有了:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  { \u0026#34;path\u0026#34;: \u0026#34;/sdcard/test.obj\u0026#34;, \u0026#34;size\u0026#34;: 99785, \u0026#34;op\u0026#34;: 10040, \u0026#34;buffer\u0026#34;: 1024, \u0026#34;cost\u0026#34;: 31, \u0026#34;opType\u0026#34;: 2, \u0026#34;opSize\u0026#34;: 99785, \u0026#34;thread\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;stack\u0026#34;: \u0026#34;writeObjectToFile(TestActivity.kt:94)\u0026#34;, \u0026#34;repeat\u0026#34;: 0, \u0026#34;tag\u0026#34;: \u0026#34;io\u0026#34;, \u0026#34;type\u0026#34;: 2, \u0026#34;time\u0026#34;: 1571364341671 }    结果说明:\n  size: 写入的数据量 op: 操作次数 type: 1:read 2: write buffer: 操作使用的 buffer size  竟然有 10040 次的写入操作(调用底层 libjavacore.so 的 write). 而且写入的 buffer 只有 1024. 但是 buffer 1024, size 99785, 写入次数不是应该为 99785/1024 = 98 次吗?\n原因分析 10040 哪来的？ 这就要看 ObjectOutputStream 的 writeObject 的骚操作了:\nwriteObject 最终会走到 ObjectOutputStream#defaultWriteFields 方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  int numObjFields = desc.getNumObjFields(); // 获取 Field 数量 if (numObjFields \u0026gt; 0) { ObjectStreamField[] fields = desc.getFields(false); Object[] objVals = new Object[numObjFields]; int numPrimFields = fields.length - objVals.length; desc.getObjFieldValues(obj, objVals); for (int i = 0; i \u0026lt; objVals.length; i++) { // 为每个 Field 执行 writeObject0  try { writeObject0(objVals[i], fields[numPrimFields + i].isUnshared()); } finally {...} } }   writeObject0 方法:\n1 2 3 4 5 6 7 8 9  if (obj instanceof String) { writeString((String) obj, unshared); } else if (cl.isArray()) { writeArray(obj, desc, unshared); } else if (obj instanceof Enum) { writeEnum((Enum\u0026lt;?\u0026gt;) obj, desc, unshared); } else if (obj instanceof Serializable) { writeOrdinaryObject(obj, desc, unshared); } else {...}   可见 ObjectOutputStream 实际会为每个字段执行具体的 write 操作, ObjectOutputStream 的 write 操作内部又是调用的构造时传入的 OutputStream, 所以就直接造成多次调用 FileOutputStream 的 write。\n修复 使用 ByteArrayOutputStream 或 BufferedOutputStream + ObjectOutputStream + FileOutputStream 的组合，能够先将 ObjectOutputStream 全部写入到位于内存的\nByteArrayOutputStream, 然后通过 ByteArrayOutputStream 一次写入到 FileOutputStream 中, 最终就只会有 1 次的底层 write 操作调用.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static \u0026lt;Obj extends Serializable\u0026gt; boolean serializeObject(Obj o, String path) { ObjectOutputStream oo = null; ByteArrayOutputStream bao; FileOutputStream fos = null; boolean success = true; try { bao = new ByteArrayOutputStream(); oo = new ObjectOutputStream(bao); oo.writeObject(o); oo.flush(); fos = new FileOutputStream(path); bao.writeTo(fos); bao.flush(); fos.flush(); } catch (Exception ignore) { success = false; } finally { try { if (oo != null) { oo.close(); } if (fos != null) { fos.close(); } } catch (Exception ignored) { success = false; } } return success; }    ObjectInputStream 同样可以这样优化\n","description":"","id":43,"section":"posts","tags":null,"title":"优化 ObjectOutputStream 的使用","uri":"https://jiyang.site/posts/2019-10-18-objectoutputstream-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96/"},{"content":" init 进程是 Android 系统中用户空间的第一个进程，进程号为 1。作为第一个进程，它被赋予了很多重要的职责，比如创建 Zygote 进程和属性服务等。\n init 进程由多个源文件共同组成，这些文件位于源码目录 system/core/init 中。\nAndroid 系统启动的前几步   当电源接通时。引导芯片代码从预定义的地方（硬编码在 ROM）开始执行。加载引导程序 BootLoader 到 （内存）RAM 中，然后执行。\n  BootLoader 是在 Android 系统开始运行前的一个小程序（它不是 Android 的一部分）。BootLoader 是制造商放置锁定和限制的地方。BootLoader 分两个阶段执行。 在第一阶段，它检测外部 RAM 并加载程序。在第二阶段，为内核启动做准备，引导加载程序设置网络，内存等\n  Android 内核的启动方式与 Linux 内核类似。随着内核的启动，开始设置缓存，受保护的内存，调度和加载驱动程序。当内核完成系统设置时，它会在系统文件中查找 init 文件。\n  init 进程启动\n   创建和挂载启动所需的文件目录 初始化和启动属性服务 解析 init.rc 脚本，并启动 Zygote 进程  init 进程的入口 在 Android 内核加载完成后，它会执行 init 进程的入口函数 main，main 函数中会解析 init.rc 配置文件到 Action Service 对象中，然后执行 Actions 中的命令。\n init.rc 是按照 Android Init Language 语法编写的脚本。\n 在 init 进程在执行 main 方法时，会解析执行 /init.rc 脚本，init.rc 脚本中会 import 与 zygote 相关的 init.${ro.zygote}.rc 脚本:\n ro.zygote 是一个编译期指定的属性值，可以为 zygote32、zygote64、zygote32_64、zygote64_32\n init.rc 内容如下:\nimport /init.environ.rc import /init.usb.rc import /init.${ro.hardware}.rc import /vendor/etc/init/hw/init.${ro.hardware}.rc import /init.usb.configfs.rc import /init.${ro.zygote}.rc init.zygote64.rc 内容如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13  service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server class main //指定服务的类名。 同一个类名中的所有服务可以一起启动或停止。 如果未通过 class 选项指定服务，则服务在类“default”中  priority -20 //调度服务进程的优先级。 该值必须在 [-20,19] 的范围内。默认优先级为 0  user root //所属用户  socket zygote stream 660 root system //创建一个名为 /dev/socket/name 的 UNIX 域 socket，并将其 fd 传递给已启动的进程  socket usap_pool_primary stream 660 root system onrestart write /sys/power/state on //onrestart 表示在重启时执行的动作  onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks //将进程id写入文件   进入 Java 世界 待配置文件解析完成之后，就会开始依次执行 Actions 里的命令，在 init.rc 中能看到有如下配置：\n init.rc\n on nonencrypted class_start main // 执行 class_start 命令，参数为 main class_start late_start 表示当 nonencrypted 事件发生时，就执行下面定义的命令 class_start main 等。\n system/core/init/builtins.cpp 中每个命令对应的解析函数关系\n 1 2 3 4 5 6 7 8 9 10 11 12  const BuiltinFunctionMap::Map\u0026amp; BuiltinFunctionMap::map() const { constexpr std::size_t kMax = std::numeric_limits\u0026lt;std::size_t\u0026gt;::max(); static const Map builtin_functions = { ... {\u0026#34;class_reset\u0026#34;, {1, 1, do_class_reset}}, {\u0026#34;class_restart\u0026#34;, {1, 1, do_class_restart}}, {\u0026#34;class_start\u0026#34;, {1, 1, do_class_start}}, ... {\u0026#34;write\u0026#34;, {2, 2, do_write}}, }; return builtin_functions; }   所以 class_start main 会执行 do_class_start 方法，并传递参数 main:\n1 2 3 4 5  static int do_class_start(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; args) { ServiceManager::GetInstance().ForEachServiceInClass(args[1], [] (Service* s) { s-\u0026gt;StartIfNotDisabled(); }); // 循环执行 class name 匹配 args[1](这里是main) 的 Service 的 StartIfNotDisabled  return 0; }   1 2 3 4 5 6 7 8  bool Service::StartIfNotDisabled() { if (!(flags_ \u0026amp; SVC_DISABLED)) { return Start(); } else { flags_ |= SVC_DISABLED_START; } return true; }   init.zygote64.rc 中配置的 zygote 服务的 class name 恰恰就是 main, 所以这里会执行在 zygote 配置的 Service 对象的 Start() 方法。\n@startuml Service -\u0026gt; Service: Start Service -\u0026gt; Service: fork note right: fork 进程，接下来的操作在子进程中 Service -\u0026gt; Service: ExpandArgsAndExecve note right: 调用 execve 执行 zygote service 的程序\\n system/bin/app_process64\\n其对应源码为app_main.cpp Service -\u0026gt; app_main.cpp: main app_main.cpp -\u0026gt; AndroidRuntime: start(\u0026quot;com.android.internal.os.ZygoteInit\u0026quot;) AndroidRuntime -\u0026gt; AndroidRuntime: startVM note right: 启动 JVM AndroidRuntime -\u0026gt; JNIEnv: CallStaticVoidMethod note right: 调用 ZygoteInit 类的静态方法: main JNIEnv -\u0026gt; ZygoteInit: main @enduml Service 的 Start() 会最终执行 zygote service 配置中的参数 system/bin/app_process64 程序, 其对应源码为app_main.cpp.\n frameworks/base/cmds/app_process/app_main.cpp\n app_main.cpp 的 main 方法接收的参数就是在 init.zygote64.rc 中配置的 --zygote --start-system-server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int main(int argc, char* const argv[]) { //...  while (i \u0026lt; argc) { const char* arg = argv[i++]; if (strcmp(arg, \u0026#34;--zygote\u0026#34;) == 0) { zygote = true; niceName = ZYGOTE_NICE_NAME; } else if (strcmp(arg, \u0026#34;--start-system-server\u0026#34;) == 0) { startSystemServer = true; } else if (strcmp(arg, \u0026#34;--application\u0026#34;) == 0) { application = true; } else if (strncmp(arg, \u0026#34;--nice-name=\u0026#34;, 12) == 0) { niceName.setTo(arg + 12); } else if (strncmp(arg, \u0026#34;--\u0026#34;, 2) != 0) { className.setTo(arg); break; } else { --i; break; } } //...  if (zygote) { runtime.start(\u0026#34;com.android.internal.os.ZygoteInit\u0026#34;, args, zygote); } else if (className) { runtime.start(\u0026#34;com.android.internal.os.RuntimeInit\u0026#34;, args, zygote); } else { fprintf(stderr, \u0026#34;Error: no class name or --zygote supplied.\\n\u0026#34;); app_usage(); LOG_ALWAYS_FATAL(\u0026#34;app_process: no class name or --zygote supplied.\u0026#34;); } }   app_main.cpp 的 main 方法中会调用 AndroidRuntime 的 start 方法, 进而 startVM 启动 JVM, 然后通过 JNIEnv 调用 ZygoteInit Java 类的静态方法 main. 至此, 就从 cpp 世界进入了 java 世界.\n frameworks/base/core/jni/AndroidRuntime.cpp\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  void AndroidRuntime::start(const char* className, const Vector\u0026lt;String8\u0026gt;\u0026amp; options, bool zygote) { // className: com.android.internal.os.ZygoteInit  //...  // 启动 JVM  JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(\u0026amp;mJavaVM, \u0026amp;env, zygote) != 0) { return; } onVmCreated(env); //...  /* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. * 创建一个 strArray 存放相关参数 */ jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-\u0026gt;FindClass(\u0026#34;java/lang/String\u0026#34;); assert(stringClass != NULL); strArray = env-\u0026gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); classNameStr = env-\u0026gt;NewStringUTF(className); assert(classNameStr != NULL); env-\u0026gt;SetObjectArrayElement(strArray, 0, classNameStr); for (size_t i = 0; i \u0026lt; options.size(); ++i) { jstring optionsStr = env-\u0026gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-\u0026gt;SetObjectArrayElement(strArray, i + 1, optionsStr); } /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ // com.android.internal.os.ZygoteInit 转变为 com/android/internal/os/ZygoteInit  char* slashClassName = toSlashClassName(className != NULL ? className : \u0026#34;\u0026#34;); jclass startClass = env-\u0026gt;FindClass(slashClassName); if (startClass == NULL) { ALOGE(\u0026#34;JavaVM unable to locate class \u0026#39;%s\u0026#39;\\n\u0026#34;, slashClassName); } else { // 获取 ZygoteInit 类的 static void main 方法  jmethodID startMeth = env-\u0026gt;GetStaticMethodID(startClass, \u0026#34;main\u0026#34;, \u0026#34;([Ljava/lang/String;)V\u0026#34;); if (startMeth == NULL) { ALOGE(\u0026#34;JavaVM unable to find main() in \u0026#39;%s\u0026#39;\\n\u0026#34;, className); } else { // 调用 main 方法  env-\u0026gt;CallStaticVoidMethod(startClass, startMeth, strArray); } } }   Zygote 进程启动 进入 Java 世界之后, 程序从 ZygoteInit 类的 main 开始运行.\n主流程 @startuml ZygoteInit -\u0026gt; ZygoteInit: main ZygoteInit -\u0026gt; ZygoteServer: registerServerSocket ZygoteInit -\u0026gt; ZygoteInit: preload group 启动 SystemServer 进程 ZygoteInit -\u0026gt; Zygote: forkSystemServer Zygote -\u0026gt; Zygote: nativeForkSystemServer Zygote --\u0026gt; ZygoteInit: pid ZygoteInit -\u0026gt; ZygoteServer: closeServerSocket ZygoteInit -\u0026gt; ZygoteInit: handleSystemServerProcess end ZygoteInit -\u0026gt; ZygoteServer: runSelectLoop ZygoteInit -\u0026gt; ZygoteServer: closeServerSocket @enduml  ZygoteInit.java#main\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); //...  final Runnable caller; try { //...  // 创建一个 LocalServerSocket, 用来接收其他服务的请求. socketName 为 zygote  zygoteServer.registerServerSocket(socketName); //...  if (startSystemServer) { // 通过 fork 一个子进程来启动 System Server  Runnable r = forkSystemServer(abiList, socketName, zygoteServer); // {@code r == null } 说明还是运行在父(zygote)进程  // {@code r != null } 说明运行在子进程(system_server)  if (r != null) { r.run(); // 这里的 return 是让子进程(system_server)不执行下面的代码, zygote 进程中代码还是继续向下运行  return; } } // 运行 Zygote 进程的循环来等待 AMS 的请求  caller = zygoteServer.runSelectLoop(abiList); } catch (Throwable ex) { throw ex; } finally { zygoteServer.closeServerSocket(); } // 如果 caller != null, 说明在 zygote 进程中. 执行 runSelectLoop 返回的 Runnable  if (caller != null) { caller.run(); } }   registerServerSocket 创建 Zygote 接受事件的 Server Socket\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  void registerServerSocket(String socketName) { if (mServerSocket == null) { int fileDesc; // 拼接 scoket name 为: ANDROID_SOCKET_zygote  final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + \u0026#34; unset or invalid\u0026#34;, ex); } try { // 创建文件描述符  FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); // 创建 LocalServerSocket  mServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException(\u0026#34;Error binding to local socket \u0026#39;\u0026#34; + fileDesc + \u0026#34;\u0026#39;\u0026#34;, ex); } } }   启动 SystemServer 通过调用 forSystemServer 启动 SystemServer 进程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) { // ...  // 一些参数设置  String args[] = { \u0026#34;--setuid=1000\u0026#34;, \u0026#34;--setgid=1000\u0026#34;, \u0026#34;--nice-name=system_server\u0026#34;, \u0026#34;com.android.server.SystemServer\u0026#34;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); // fork 当前进程  pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } if (pid == 0) { // fork 成功之后, 在子进程中运行下面的代码  if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } // 因为 SystemServer 用不到 Zygote 的 Server Socket, 所以关掉  zygoteServer.closeServerSocket(); // 在 SystemServer 进程做一些工作  return handleSystemServerProcess(parsedArgs); } // 父进程方法调用结束  return null; }   handleSystemServerProcess SystemServer 进程 fork 成功之后，在其进程做一些工作。比如：加载一些系统类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) { //...  if (parsedArgs.mInvokeWith != null) { //...  } else { // 创建 PathClassLoader 作为系统 ClassLoader  createSystemServerClassLoader(); ClassLoader cl = sCachedSystemServerClassLoader; if (cl != null) { // 注入到 ContextClassLoader 中  Thread.currentThread().setContextClassLoader(cl); } return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); } }   zygoteInit 每个从 zygote 进程 fork 而来的进程都会执行 zygoteInit 方法。\n1 2 3 4 5 6 7 8 9 10  public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) { // 将System.out和System.err重定向到Android日志。  RuntimeInit.redirectLogStreams(); // 做一些公共的操作，比如：设置系统的 User-Agent  RuntimeInit.commonInit(); ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader); }   applicationInit 1 2 3 4 5 6 7 8 9  protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) { VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges); final Arguments args = new Arguments(argv); // 找到参数中 startClass 的 static main 方法  // 这里 startClass 是: com.android.server.SystemServer  return findStaticMain(args.startClass, args.startArgs, classLoader); }   1 2 3 4 5 6 7 8 9 10 11  protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) { Class\u0026lt;?\u0026gt; cl; // 获取目标类  cl = Class.forName(className, true, classLoader); Method m; // 获取目标类的 main 方法  m = cl.getMethod(\u0026#34;main\u0026#34;, new Class[] { String[].class }); // MethodAndArgsCaller 是一个 Runnable, run 时会执行方法 m, 并传递参数 argv  return new MethodAndArgsCaller(m, argv); }   启动 SystemServer 的过程可以概述为：\n fork zygote 进程 关闭 zygote 的 server socket 在 fork 的进程中加载 com.android.server.SystemServer 类，并调用 SystemServer 类的 main 方法  runSelectLoop 在 zygote 进程, ZygoteServer 会继续执行 runSelectLoop 方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  Runnable runSelectLoop(String abiList) { ArrayList\u0026lt;FileDescriptor\u0026gt; fds = new ArrayList\u0026lt;FileDescriptor\u0026gt;(); ArrayList\u0026lt;ZygoteConnection\u0026gt; peers = new ArrayList\u0026lt;ZygoteConnection\u0026gt;(); // 获取通过 registerServerSokcet 创建的 socket 的 FileDescriptor, 添加到 fd 列表 fds 中  fds.add(mServerSocket.getFileDescriptor()); peers.add(null); // 无限循环  while (true) { // 将 fds 中的信息转移到 pollFds 中  StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i \u0026lt; pollFds.length; ++i) { pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; // 设置 StructPollfd 等待的事件为 POLLIN  // POLLIN: 表示有数据可读  } try { // Linux poll 调用: 等待一组文件描述符中的一个准备好执行 I/O, -1 表示一直等待  Os.poll(pollFds, -1); } catch (ErrnoException ex) { throw new RuntimeException(\u0026#34;poll failed\u0026#34;, ex); } // 从 pollFds 末尾开始遍历  for (int i = pollFds.length - 1; i \u0026gt;= 0; --i) { if ((pollFds[i].revents \u0026amp; POLLIN) == 0) { // revents: 实际发生的事件  // 如果实际发生的事件不为 POLLIN, 则跳过后面步骤  continue; } // i == 0: 表示是 mServerSocket 的 FileDescriptor 发生了 POLLIN 事件. 因为 mServerSocket 的 FileDescriptor 是在无限循环之前添加到 fds 中的, 其 index 一定为 0  if (i == 0) { // 从 mServerSocket accept 一个客户端的 socket 连接, 封装为 ZygoteConnection  ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); // 将客户端的 socket FileDescriptor 添加到 fds 中  fds.add(newPeer.getFileDesciptor()); } else { // 能走到这里的 fd 都是客户端的 socket 的 fd  try { ZygoteConnection connection = peers.get(i); final Runnable command = connection.processOneCommand(this); // processOneCommand 执行成功，最终返回一个 Runnable:  // ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */);  if (mIsForkChild) { // mIsForkChild 在 processOneCommand 当 fork 成功之后会设置  // We\u0026#39;re in the child. We should always have a command to run at this  // stage if processOneCommand hasn\u0026#39;t called \u0026#34;exec\u0026#34;.  if (command == null) { throw new IllegalStateException(\u0026#34;command == null\u0026#34;); } return command; //return 到 ZygoteInit#main 最下面的 caller  } else { // fork 失败或者执行 processOneCommand 期间其他参数错误  // We\u0026#39;re in the server - we should never have any commands to run.  if (command != null) { throw new IllegalStateException(\u0026#34;command != null\u0026#34;); } // We don\u0026#39;t know whether the remote side of the socket was closed or  // not until we attempt to read from it from processOneCommand. This shows up as  // a regular POLLIN event in our regular processing loop.  if (connection.isClosedByPeer()) { connection.closeSocket(); peers.remove(i); fds.remove(i); } } } catch (Exception e) { } } } }   看完整体过程，init 进程的启动过程可以概要为：\n 解析 init.rc 脚本，执行 app_process 程序 app_process 程序运行后会创建 Java VM Java VM 创建成功之后，会执行 Java 类 ZygoteInit 的 main 方法从而创建 ZygoteServerSocket、启动 SystemService  参考  https://zh.wikipedia.org/wiki/文件描述符 Linux POLL: http://man7.org/linux/man-pages/man2/poll.2.html ","description":"","id":44,"section":"posts","tags":null,"title":"Android init 进程的启动过程","uri":"https://jiyang.site/posts/2019-09-12-android-init-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"content":"LifeCycle Android 架构组件。\n其目的是: 方便开发者能从 Activity Fragment 的生命周期回调中解放，让开发者能自由的创建监听生命周期回调的组件。\n@startuml skinparam backgroundColor #EEEBDC skinparam roundcorner 20 interface LifecycleOwner{ + Lifecycle getLifecycle(); } abstract class Lifecycle { + {abstract} void addObserver(LifecycleObserver observer) + {abstract} void removeObserver(LifecycleObserver observer) + {abstract} State getCurrentState() } class LifecycleRegistry extends Lifecycle{ + void handleLifecycleEvent(Lifecycle.Event event) } enum Event { ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY } enum State { DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; } interface LifecycleObserver interface GenericLifecycleObserver extends LifecycleObserver { + void onStateChanged(LifecycleOwner source, Lifecycle.Event event); } class ReflectiveGenericLifecycleObserver implements GenericLifecycleObserver { - Object mWrapped; - CallbackInfo mInfo; } 'LifecycleOwner 依赖 Lifecycle LifecycleOwner ..\u0026gt; Lifecycle class SupportActivity implements LifecycleOwner{ - LifecycleRegistry mLifecycleRegistry } 'Lifecycle --- Event 'Lifecycle --- State Lifecycle ..o LifecycleObserver class ReportFragment{ - void dispatch(Lifecycle.Event event) } SupportActivity ..\u0026gt; ReportFragment SupportActivity ..\u0026gt; LifecycleRegistry ReportFragment ..\u0026gt; LifecycleRegistry ReportFragment --o Event LifecycleRegistry ..\u0026gt; Event LifecycleRegistry --o State @enduml Lifecycle 一个抽象类，表示具有 Android 生命周期的对象。其能够被 LifecycleObserver 所观察，当生命周期发生改变时，能通知到 LifecycleObserver。\nLifecycleOwner 一个接口，表示拥有 Lifecycle 的对象。\nLifecycleObserver 一个接口，表示生命周期的观察者，当生命周期发生改变时，将会收到通知。\n原理 首先，Lifecycle 并没有改变 Android SDK 中的原有代码，其只是在 support 包中扩展了 SupportActivity 的功能，加上了 Lifecycle。\n接下来从 Activity 和 Fragment 两个方向分析 Lifecycle 的实现原理。\nActivity 的生命周期监听 首先，因为 LifecycleOwner 是 Lifecycle 的拥有者，所以先查找 LifecycleOwner 的实现者。在 Android Studio 中 show usage of interface of LifecyclerOwner，然后过滤 scope 为 Only lib。\n可以看到 Activity 中，只有 SupportActivity 实现了这个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class SupportActivity extends Activity implements LifecycleOwner { private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); } @Override public Lifecycle getLifecycle() { return mLifecycleRegistry; } }   精简之后发现，SupportActivity 中实质只有上面的代码比较特殊。构造了一个 LifecycleRegistry 对象，其持有了该 Activity。 然后在 onCreate 的时候调用了 ReportFragment 的静态方法 injectIfNeededIn。在 getLifecycle 的方法中，返回了 LifecycleRegistry 对象。可见 LifecycleRegistry 一定继承了 Lifecycle。\nReportFragment ReportFragment 是一个没有界面的 Fragment，它的作用应该就是在各个生命周期事件回调中，进行分发。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  public class ReportFragment extends Fragment { private static final String REPORT_FRAGMENT_TAG = \u0026#34;android.arch.lifecycle\u0026#34; + \u0026#34;.LifecycleDispatcher.report_fragment_tag\u0026#34;; public static void injectIfNeededIn(Activity activity) { // 添加到 Activity 的 Fragment Stack 中  android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) { manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction.  manager.executePendingTransactions(); } } @Override public void onActivityCreated(Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); //...  dispatch(Lifecycle.Event.ON_CREATE); } @Override public void onStart() { super.onStart(); //...  dispatch(Lifecycle.Event.ON_START); } @Override public void onResume() { super.onResume(); //...  dispatch(Lifecycle.Event.ON_RESUME); } @Override public void onPause() { super.onPause(); dispatch(Lifecycle.Event.ON_PAUSE); } @Override public void onStop() { super.onStop(); dispatch(Lifecycle.Event.ON_STOP); } @Override public void onDestroy() { super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); } }   ReportFragment 的 injectIfNeededIn 创建了一个 ReportFragment 对象，然后提交到了 Acyivity 中。它在自己的各个生命周期回调中将调用 dispatch 方法，进行生命周期事件的分发。\ndispatch 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private void dispatch(Lifecycle.Event event) { // 获取当前 Activity  Activity activity = getActivity(); // 判断 Activity 实现的 LifecycleOwner 类型  // LifecycleRegistryOwner 是已经 Deprecated 的接口  if (activity instanceof LifecycleRegistryOwner) { ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; } // 现在所有 AppCompatActivity 都是继承自 SupportActivity 的，所以都实现了 LifecycleOwner 接口  // 从上面可以得知: SupportActivity 的 getLifecycler 方法返回的是一个 LifecycleRegistry 对象  if (activity instanceof LifecycleOwner) { Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) { // 调用 LifecycleRegistry 的 handleLifecycleEvent 方法，将生命周期事件的分发工作交到了 LifecycleRegistry  ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); } } }   LifecycleRegistry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  public class LifecycleRegistry extends Lifecycle { // FastSafeIterableMap 就看做能在遍历中删除元素的 Map  // Key 是 LifecycleObserver 类型  // Value 是 LifecycleRegistry 的内部类 ObserverWithState  FastSafeIterableMap\u0026lt;LifecycleObserver, ObserverWithState\u0026gt; mObserverMap = new FastSafeIterableMap\u0026lt;\u0026gt;(); int mAddingObserverCounter = 0; // 记录正在添加 Observer 的数量  boolean mHandlingEvent = false; // 记录是否正在处理事件  boolean mNewEventOccurred = false; // 记录新的事件是否发生  // we have to keep it for cases:  // void onStart() {  // mRegistry.removeObserver(this);  // mRegistry.add(newObserver);  // }  // newObserver should be brought only to CREATED state during the execution of  // this onStart method. our invariant with mObserverMap doesn\u0026#39;t help, because parent observer  // is no longer in the map.  // Google translate:  // 在执行此 onStart 方法期间，newObserver 应仅被带到 CREATED 状态。 我们对 mObserverMap 的不变性没有帮助，因为父观察者不再在 map 中。  ArrayList\u0026lt;State\u0026gt; mParentStates = new ArrayList\u0026lt;\u0026gt;(); // 存储当前的状态  private State mState; private final WeakReference\u0026lt;LifecycleOwner\u0026gt; mLifecycleOwner; public LifecycleRegistry(@NonNull LifecycleOwner provider) { mLifecycleOwner = new WeakReference\u0026lt;\u0026gt;(provider); mState = INITIALIZED; } // 该方法会在 ReportFragment dispatch 事件时调用  public void handleLifecycleEvent(@NonNull Lifecycle.Event event) { State next = getStateAfter(event); moveToState(next); } // 每个生命周期对应的状态  static State getStateAfter(Event event) { switch (event) { case ON_CREATE: case ON_STOP: return CREATED; case ON_START: case ON_PAUSE: return STARTED; case ON_RESUME: return RESUMED; case ON_DESTROY: return DESTROYED; case ON_ANY: break; } throw new IllegalArgumentException(\u0026#34;Unexpected event value \u0026#34; + event); } private void moveToState(State next) { // 如果下一个状态和当前状态一样，则忽略  if (mState == next) { return; } mState = next; // 如果正在处理事件或者正在添加 Observer，则忽略该次事件  if (mHandlingEvent || mAddingObserverCounter != 0) { mNewEventOccurred = true; // we will figure out what to do on upper level.  return; } mHandlingEvent = true; // 同步事件给观察者们  sync(); mHandlingEvent = false; } }   sync 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  private void sync() { LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) { Log.w(LOG_TAG, \u0026#34;LifecycleOwner is garbage collected, you shouldn\u0026#39;t try dispatch new events from it.\u0026#34;); return; } // 如果还没有同步，就进行  while (!isSynced()) { mNewEventOccurred = false; // no need to check eldest for nullability, because isSynced does it for us.  // State enum 的顺序是 DESTROYED,INITIALIZED,CREATED,STARTED,RESUMED  // 所以 \u0026lt;0 就说明状态是从右到左的改变  // 以下判断有些晦涩 -_-  if (mState.compareTo(mObserverMap.eldest().getValue().mState) \u0026lt; 0) { backwardPass(lifecycleOwner); } Entry\u0026lt;LifecycleObserver, ObserverWithState\u0026gt; newest = mObserverMap.newest(); if (!mNewEventOccurred \u0026amp;\u0026amp; newest != null \u0026amp;\u0026amp; mState.compareTo(newest.getValue().mState) \u0026gt; 0) { forwardPass(lifecycleOwner); } } mNewEventOccurred = false; }   事件分发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  private void forwardPass(LifecycleOwner lifecycleOwner) { Iterator\u0026lt;Entry\u0026lt;LifecycleObserver, ObserverWithState\u0026gt;\u0026gt; ascendingIterator = mObserverMap.iteratorWithAdditions(); while (ascendingIterator.hasNext() \u0026amp;\u0026amp; !mNewEventOccurred) { Entry\u0026lt;LifecycleObserver, ObserverWithState\u0026gt; entry = ascendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) \u0026lt; 0 \u0026amp;\u0026amp; !mNewEventOccurred \u0026amp;\u0026amp; mObserverMap.contains(entry.getKey()))) { pushParentState(observer.mState); // 调用 ObserverWithState 的 dispatchEvent  observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState)); popParentState(); } } } private void backwardPass(LifecycleOwner lifecycleOwner) { Iterator\u0026lt;Entry\u0026lt;LifecycleObserver, ObserverWithState\u0026gt;\u0026gt; descendingIterator = mObserverMap.descendingIterator(); while (descendingIterator.hasNext() \u0026amp;\u0026amp; !mNewEventOccurred) { Entry\u0026lt;LifecycleObserver, ObserverWithState\u0026gt; entry = descendingIterator.next(); ObserverWithState observer = entry.getValue(); while ((observer.mState.compareTo(mState) \u0026gt; 0 \u0026amp;\u0026amp; !mNewEventOccurred \u0026amp;\u0026amp; mObserverMap.contains(entry.getKey()))) { Event event = downEvent(observer.mState); pushParentState(getStateAfter(event)); // 调用 ObserverWithState 的 dispatchEvent  observer.dispatchEvent(lifecycleOwner, event); popParentState(); } } }   ObserverWithState 是对 LifecycleObserver 的一个封装，每次 addObserver 时就会将添加的 LifecycleObserver 封装。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  static class ObserverWithState { State mState; GenericLifecycleObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) { // 从 LifecycleObser 中获取 GenericLifecycleObserver  mLifecycleObserver = Lifecycling.getCallback(observer); mState = initialState; } // 事件分发时调用  void dispatchEvent(LifecycleOwner owner, Event event) { State newState = getStateAfter(event); mState = min(mState, newState); // 调用 GenericLifecycleObserver 的 onStateChanged  mLifecycleObserver.onStateChanged(owner, event); mState = newState; } }   ","description":"深入理解 Android 架构组件 LifeCycle 的原理","id":45,"section":"posts","tags":null,"title":"LifeCycle 原理","uri":"https://jiyang.site/posts/2019-07-14-lifecycle-%E5%8E%9F%E7%90%86/"},{"content":"使用装饰者模式代替单纯的继承，更好的实现功能的扩展\n使用场景 装饰模式应该算是对继承的一种补充，如果单纯的依靠继承扩展类的功能，有时会增加很多子类和继承的层级。\n类图 @startuml interface Component{ + operation() } class ConcreteComponent{ + operation() } abstract class Decoration{ - Component component } Component \u0026lt;|.. ConcreteComponent Component \u0026lt;|.. Decoration Decoration o-- Component class ConcreteDecoration extends Decoration { + operation() } @enduml @enduml   Component 抽象组件，一个接口或抽象类\n  ConcreteComponent 一个具体的组件，实现了 Component 抽象组件\n  Decoration 装饰角色，是一个抽象类，其中必定有一个私有属性引用 Component 对象\n  ConcreteDecoration 一个具体的装饰者\n  实例 Android SDK 中的 Context @startuml abstract class Context class ContextImpl extends Context class ContextWrapper extends Context{ + Context mBase; } class ContextThemeWrapper extends ContextWrapper{ } ContextImpl -o ContextWrapper class Application extends ContextWrapper class Service extends ContextWrapper class Activity extends ContextThemeWrapper @enduml 在 Android 中，Context 意为上下文，是一个应用的环境信息接口。Android 中 Activity Service Application 都间接的继承自 Context。\nContext 是一个抽象类，内部定义了很多方法和静态常量，它的实现类是 ContextImpl。\nContextImpl 和 ContextWrapper 继承自 Context，ContextWrapper 内部包含 Context 类型的 mBase 对象，mBase 具体指向 ContextImpl，ContextImpl 提供了很多功能，但是外界需要使用并扩展 ContextImpl 的功能，因此设计上使用了装饰模式，ContextWrapper 是装饰类，它对 ContextImpl 进行包装，ContextWrapper 主要起了方法传递的作用，ContextWrapper 中几乎所有方法都是通过调用 mBase 对象引用的 ContextImpl 的相应方法。\n这里使用装饰模式有以下优点：\n 使用者能更方便的使用 Context 如果 ContextImpl 发生了改变，ContextWrapper 也不用修改 ContextImpl 的实现不会暴露给使用者 通过组合而非继承的方式扩展 ContextImpl 的功能 ","description":"使用装饰者模式代替单纯的继承，更好的实现功能的扩展","id":46,"section":"posts","tags":null,"title":"装饰者模式","uri":"https://jiyang.site/posts/2019-06-29-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"content":"在工作中最近的一个业务上，每次新加一个同一类的功能时，发现会创建许多类似的类，写类似的代码。就思考能否通过模板的方式提高新建同类功能的效率，于是通过搜索发现 IDE 支持的 FreeMaker.\n遇见模板 在 Android Studio 中其实已经预置了一些常用模板，比如:\n 创建 Activity 的多文件模板: Basic Activity 模板 创建单例类的单文件模板: Singleton  单文件模板 通过打开 Android Stuidio -\u0026gt; File -\u0026gt; New -\u0026gt; Edit File Templates 窗口，就能查看预置的单文件模板，也能添加自己的单文件模板。\n例如，添加一个 Kotlin data class 模板:\n#if (${PACKAGE_NAME} \u0026amp;\u0026amp; ${PACKAGE_NAME} != \u0026quot;\u0026quot;)package ${PACKAGE_NAME} #end #parse(\u0026quot;File Header.java\u0026quot;) data class ${NAME} { } 什么是多文件模板 比如 Android Studio 的 Basic Activity 模板:\n多文件模板是可自定义的。 每个模板都公开了几个选项（称为参数），允许开发人员自定义生成的代码。使用模板的最常见工作流程如下：\n 选择一个模板。 填充模板选项（参数）。 预览然后执行项目的添加/更改。  其对应的文件结构为:\n├── globals.xml.ftl ├── recipe.xml.ftl ├── recipe_fragment.xml.ftl ├── root │ ├── res │ │ └── layout │ │ ├── activity_fragment_container.xml.ftl │ │ └── fragment_simple.xml.ftl │ └── src │ └── app_package │ ├── SimpleActivity.java.ftl │ ├── SimpleActivity.kt.ftl │ ├── SimpleActivityFragment.java.ftl │ └── SimpleActivityFragment.kt.ftl ├── template.xml ├── template_basic_activity.png └── template_basic_activity_fragment.png FreeMaker 模板使用 FreeMarker，一个 Java 模板引擎，用于启用文件中的控制流和变量替换等内容。 它类似于PHP，Django模板等。按照惯例，要由 FreeMarker 处理的模板目录结构中的任何文件都应具有 .ftl 文件扩展名。 因此，如果您的一个源文件是 MyActivity.java，并且它包含 FreeMarker 指令，则应将其命名为 MyActivity.java.ftl 。\n有关 FreeMarker 的更多文档，请参阅文档。 特别是关于字符串操作的引用。https://freemarker.apache.org/docs/index.html\n目录结构 模板是包含许多 XML 和 FreeMarker 文件的目录。 有两个必需文件是 template.xml和recipe.xml.ftl。模板源文件（PNG 文件，模板化 Java 和 XML 文件等）属于 root/ 的子目录。 下面是模板的示例目录结构：\nMyTemplate - 根目录 ├── globals.xml.ftl - 可选的全局变量 ├── recipe.xml.ftl - 说明/脚本（要复制的文件等） ├── root - 源文件（与输出项目一起处理/复制/合并） │ ├── res │ │ └── layout │ │ └── fragment_bell.xml.ftl │ └── src │ └── app_package │ ├── BellActivityAnswerData.kt.ftl │ ├── BellActivityData.kt.ftl │ ├── BellActivityScoreData.kt.ftl │ ├── BellFragment.kt.ftl │ ├── Logger.kt.ftl │ ├── PracticeProcess.kt.ftl │ ├── PresentProcess.kt.ftl │ └── ResultProcess.kt.ftl └── template.xml - 元数据（描述，参数等） template.xml 每个模板目录必须包含 template.xml 文件。 此 XML 文件包含有关模板的元数据，包括 IDE 将作为用户选项显示的名称，描述，类别和用户可见参数。 XML 文件还指示配方 XML 文件的名称（由 FreeMarker 处理），以及全局变量 XML 文件，如果除了模板参数值之外还有全局变量，应该对所有FreeMarker 处理的文件（.ftl文件都可见））。\n例如 Android Studio 提供的 Basic Activity 模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;template format=\u0026#34;5\u0026#34; revision=\u0026#34;6\u0026#34; name=\u0026#34;Basic Activity\u0026#34; minApi=\u0026#34;9\u0026#34; minBuildApi=\u0026#34;14\u0026#34; description=\u0026#34;Creates a new basic activity with an app bar.\u0026#34;\u0026gt; \u0026lt;category value=\u0026#34;Activity\u0026#34;/\u0026gt; \u0026lt;formfactor value=\u0026#34;Mobile\u0026#34;/\u0026gt; \u0026lt;parameter id=\u0026#34;activityClass\u0026#34; name=\u0026#34;Activity Name\u0026#34; type=\u0026#34;string\u0026#34; constraints=\u0026#34;class|unique|nonempty\u0026#34; suggest=\u0026#34;${layoutToActivity(layoutName)}\u0026#34; default=\u0026#34;MainActivity\u0026#34; help=\u0026#34;The name of the activity class to create\u0026#34;/\u0026gt; \u0026lt;parameter id=\u0026#34;layoutName\u0026#34; name=\u0026#34;Layout Name\u0026#34; type=\u0026#34;string\u0026#34; constraints=\u0026#34;layout|unique|nonempty\u0026#34; suggest=\u0026#34;${activityToLayout(activityClass)}\u0026#34; default=\u0026#34;activity_main\u0026#34; help=\u0026#34;The name of the layout to create for the activity\u0026#34;/\u0026gt; \u0026lt;globals file=\u0026#34;globals.xml.ftl\u0026#34;/\u0026gt; \u0026lt;execute file=\u0026#34;recipe.xml.ftl\u0026#34;/\u0026gt; \u0026lt;/template\u0026gt;   参数说明   \u0026lt;template\u0026gt;\n模板的根节点\n format 此模板遵循的模板格式版本 revision 可选的。 此模板的版本（您可以在更新模板时递增），作为整数。 name 模板的显示名称 description 模板的描述。 minApi 可选的。 此模板所需的最低API级别。 在实例化模板之前，IDE将确保目标项目的minSdkVersion不低于此值。 minBuildApi 可选的。 此模板所需的最小构建目标API级别。 在实例化模板之前，IDE将确保目标 buildVersion 是大于或等于此值的API级别。    \u0026lt;dependency\u0026gt;\n表示模板要求目标项目中存在给定库。 如果不存在，IDE将向项目添加依赖项。\n name 库的名称 revision 此模板所需的库的最低版本。    \u0026lt;category\u0026gt; 模板类型。 此元素是可选的。\n value 模板类型。可以自己定义。    \u0026lt;parameter\u0026gt;\n定义用户可自定义的模板参数。\n id 表示此变量的标识符在 FreeMarker 文件中作为全局变量提供。 如果标识符为 foo，则参数值将在 FreeMarker 文件中以 ${foo} 的形式提供。 name 模板参数的显示名称。 type 参数的数据类型。 string boolean enum separator(分隔符) constraints 可选的。 强加于参数值的约束。 可以使用 | 组合约束。 有效的约束类型是：  nonempty 该值不能为空 apilevel 该值应表示数字 API 级别 package 该值应表示有效的 Java 包名称 class 该值应表示有效的Java类名称 activity 该值应表示完全限定的 Activity 类名称 layout 该值应表示有效的 xml 布局名称 drawable 该值应表示有效的 Drawable 名称 string 该值应表示有效的字符串资源名称 id 该值应表示有效的id资源名称 unique 该值必须是唯一的; 此约束仅在指定其他约束时才有意义，例如布局，这意味着该值不能表示现有的布局资源名称 exists 该值必须已经存在; 此约束仅在指定其他约束时才有意义，例如布局，这意味着该值应该是现有的布局资源名称   suggest 可选的。 表示自动建议参数值。 default 可选的。 此参数的默认值。 help 用于为此参数显示给用户的帮助字符串。 \u0026lt;option\u0026gt; 对于 enum 类型的参数，表示可以选择的值。  id 如果选择此选项，则设置的参数值。 minApi 可选的。 选择此选项时所需的最低API级别。 在实例化模板之前，IDE 将确保目标项目的 minSdkVersion 不低于此值。 [text] option 在 IDE 下拉框的显示内容。   \u0026lt;thumb\u0026gt; 表示模板的缩略图。 \u0026lt;thumb\u0026gt; 元素应包含在 \u0026lt;thumbs\u0026gt; 元素中。 此元素的文本内容表示缩略图的路径。 如果此元素具有任何属性，则它们将被视为参数值的选择器。 例如，如果有两个缩略图：    1 2 3 4  \u0026lt;thumbs\u0026gt; \u0026lt;thumb\u0026gt;template.png\u0026lt;/thumb\u0026gt; \u0026lt;thumb navType=\u0026#34;tabs\u0026#34;\u0026gt;template_tabs.png\u0026lt;/thumb\u0026gt; \u0026lt;/thumbs\u0026gt;   如果 `navType` 模板参数的值为 `tabs` ，则模板的缩略图将显示 template_tabs.png，否则将显示template.png。  globals.xml 可选的全局变量 XML 文件包含全局变量定义。 在 globals.xml 中定义的变量，能在所有 .ftl 文件中使用。\n例如:\n1 2 3 4 5 6  \u0026lt;globals\u0026gt; \u0026lt;global id=\u0026#34;srcOut\u0026#34; value=\u0026#34;src/${slashedPackageName(packageName)}\u0026#34; /\u0026gt; \u0026lt;!-- 将 activityName 转为小写，储存在 activityNameLower --\u0026gt; \u0026lt;global id=\u0026#34;activityNameLower\u0026#34; value=\u0026#34;${activityName?lower_case}\u0026#34; /\u0026gt; \u0026lt;global id=\u0026#34;activityClass\u0026#34; value=\u0026#34;${activityName}Activity\u0026#34; /\u0026gt; \u0026lt;/globals\u0026gt;   recipe.xml.ftl 配置 XML 文件，包含从此模板生成代码时应执行的各个指令。\n例如，您可以复制某些文件或目录（copy），通过 FreeMarker 从源文件模板生成代码（instantiate），并在生成代码后打开文件(open)。\n例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  \u0026lt;recipe\u0026gt; \u0026lt;!-- runs FreeMarker, then copies from [template-directory]/root/ to [output-directory]. --\u0026gt; \u0026lt;instantiate from=\u0026#34;AndroidManifest.xml.ftl\u0026#34; /\u0026gt; \u0026lt;!-- automatically creates directories as needed --\u0026gt; \u0026lt;copy from=\u0026#34;res/drawable-hdpi\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/drawable-mdpi\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/drawable-xhdpi\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/values/dimens.xml\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/values/styles.xml\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/values-large/dimens.xml\u0026#34; /\u0026gt; \u0026lt;copy from=\u0026#34;res/menu/main.xml\u0026#34; to=\u0026#34;res/menu/${activityNameLower}.xml\u0026#34; /\u0026gt; \u0026lt;instantiate from=\u0026#34;res/values/strings.xml.ftl\u0026#34; /\u0026gt; \u0026lt;!-- Decide which layout to add --\u0026gt; \u0026lt;#if navType?contains(\u0026#34;pager\u0026#34;)\u0026gt; \u0026lt;instantiate from=\u0026#34;res/layout/activity_pager.xml.ftl\u0026#34; to=\u0026#34;res/layout/activity_${activityNameLower}.xml\u0026#34; /\u0026gt; \u0026lt;#elseif navType == \u0026#34;tabs\u0026#34; || navType == \u0026#34;dropdown\u0026#34;\u0026gt; \u0026lt;copy from=\u0026#34;res/layout/activity_fragment_container.xml\u0026#34; to=\u0026#34;res/layout/activity_${activityNameLower}.xml\u0026#34; /\u0026gt; \u0026lt;#else\u0026gt; \u0026lt;copy from=\u0026#34;res/layout/activity_simple.xml\u0026#34; to=\u0026#34;res/layout/activity_${activityNameLower}.xml\u0026#34; /\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;!-- Decide which activity code to add --\u0026gt; \u0026lt;#if navType == \u0026#34;none\u0026#34;\u0026gt; \u0026lt;instantiate from=\u0026#34;src/app_package/SimpleActivity.java.ftl\u0026#34; to=\u0026#34;${srcOut}/${activityClass}.java\u0026#34; /\u0026gt; \u0026lt;#elseif navType == \u0026#34;pager\u0026#34;\u0026gt; \u0026lt;instantiate from=\u0026#34;src/app_package/PagerActivity.java.ftl\u0026#34; to=\u0026#34;${srcOut}/${activityClass}.java\u0026#34; /\u0026gt; \u0026lt;#elseif navType == \u0026#34;tabs\u0026#34;\u0026gt; \u0026lt;instantiate from=\u0026#34;src/app_package/TabsActivity.java.ftl\u0026#34; to=\u0026#34;${srcOut}/${activityClass}.java\u0026#34; /\u0026gt; \u0026lt;#elseif navType == \u0026#34;dropdown\u0026#34;\u0026gt; \u0026lt;instantiate from=\u0026#34;src/app_package/DropdownActivity.java.ftl\u0026#34; to=\u0026#34;${srcOut}/${activityClass}.java\u0026#34; /\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;!-- open the layout file when done --\u0026gt; \u0026lt;open file=\u0026#34;res/layout/${activityNameLower}.xml\u0026#34; /\u0026gt; \u0026lt;/recipe\u0026gt;   命令说明  \u0026lt;copy\u0026gt;  唯一必需的参数是 from，它指定要在根目录下复制的源文件的位置。 如果需要，将自动创建所有必需的祖先目录。\n默认目标位置是输出目录根目录下的相同路径（即目标项目的位置）。 如果提供了可选的to参数，则指定输出目录。 请注意，如果from路径以 .ftl 结尾，它将自动被剥离。 例如 \u0026lt;instantiate from =“res / values / strings.xml.ftl”/\u0026gt; 就足够了; 这将创建一个名为 strings.xml 的文件，而不是 strings.xml.ftl。\n此参数以递归方式工作，因此如果 from 是目录，则以递归方式复制该目录。\n \u0026lt;instantiate\u0026gt;  与 \u0026lt;copy\u0026gt; 相同，但每个源文件首先会通过 FreeMarker 模板解析。\n \u0026lt;merge\u0026gt;  该指令将用于将源文件的内容合并到项目中的现有文件中。 最常见的用例是将组件添加到目标项目的 AndroidManifest.xml 文件中，或将诸如字符串之类的资源合并到现有的 strings.xml 文件中。\n \u0026lt;open\u0026gt;  在代码生成完成后，在 IDE 中打开由 file 参数指定的文件。\nroot/ 实际的模板文件（资源，Java源代码，AndroidManifest 更改）应该放在 root/ 目录中。\n一个区别是，不是将源文件放在 src/com/google/... 中，您可以使用命令约定，如 src/app_package/，表示此目录下的文件将放在目标项目的源文件包根目录中。\n额外的模板函数 除了标准的内置 FreeMarker 函数之外，FreeMarker 表达式和文件还有几个函数可用。\nstring activityToLayout(string) 将类似 Activity 类的标识符字符串（如 FooActivity ）转换为对应的资源友好标识符字符串，例如 activity_foo。\n 参数 activityClass  Activity 类名称，例如 FooActivity。\nstring camelCaseToUnderscore(string) 将驼峰大小写标识符字符串（如 FooBar）转换为其对应的下划线分隔标识符字符串，例如 foo_bar。\nstring escapeXmlAttribute(string) 转义字符串，例如 Android's，以便它可以用作XML属性值：Android\u0026amp;apos;s。 将把 ', \u0026quot;, \u0026lt; 和 \u0026amp; 转义为对应的 XML 值。\nstring escapeXmlText(string) 转义字符串，例如 A \u0026amp; B's，以便它可以用作 XML 文本。 将转义 \u0026lt; 和 \u0026gt;，但与 escapeXmlAttribute 不同，它不会转义 ' 和 '。\nstring escapeXmlString(string) 转义字符串，例如 A \u0026amp; B's，以便它适合作为 XML 文本插入到字符串资源文件，例如 A ＆amp; B\\S。 除了转义 \u0026lt;和 ＆ 之类的XML字符外，它还执行其他 Android 特定的转义，例如使用反斜杠转义撇号(' -\u0026gt; /)，等等。\nstring extractLetters(string) 从字符串中提取所有字母，删除任何标点符号和空白字符。\nstring classToResource(string) 将 Android类名称（如FooActivity或FooFragment）转换为对应的资源友好的标识符字符串（如foo），剥离 Activity 或 Fragment 后缀。 会剥离的后缀:\n Activity Fragment Provider Service  string layoutToActivity(string) 将资源友好的标识符字符串（例如activity_foo）转换为对应的Java类友好标识符字符串(例如FooActivity)。\nstring slashedPackageName(string) 将完整 Java包名称转换为其对应的目录路径。 例如，如果给定的参数是 com.example.foo，则返回值将为 com/example/foo。\nstring underscoreToCamelCase(string) 将下划线分隔的字符串（如foo_bar）转换为其对应的驼峰字符串（如FooBar)。\n参考:   https://www.i-programmer.info/professional-programmer/resources-and-tools/6845-android-adt-template-format-document.html https://freemarker.apache.org/docs/index.html  ","description":"在工作中最近的一个业务上，每次新加一个同一类的功能时，发现会创建许多类似的类，写类似的代码。就思考能否通过模板的方式提高新建同类功能的效率，于是通过搜索发现 IDE 支持的 FreeMaker.","id":47,"section":"posts","tags":null,"title":"使用Android Studio Code 模板提高编码效率","uri":"https://jiyang.site/posts/2019-06-23-%E4%BD%BF%E7%94%A8android-studio-code-%E6%A8%A1%E6%9D%BF%E6%8F%90%E9%AB%98%E7%BC%96%E7%A0%81%E6%95%88%E7%8E%87/"},{"content":"通过实际案列理解 Flutter 中 Key 在其渲染机制中起到的作用，从而达到能在合理的时间和地点使用合理的 Key\n概览 在 Flutter 中，大概大家都知道如何更新界面视图: 通过修改 Stata 去触发 Widget 重建，触发和更新的操作是 Flutter 框架做的。 但是有时即使修改了 State，Flutter 框架好像也没有触发 Widget 重建，\n其中就隐含了 Flutter 框架内部的更新机制，在某些情况下需要结合使用 Key，才能触发真正的“重建”。\n下面将从 3 个方面 (When, Where, Which) 说明如何在合理的时间和地点使用合理的 Key。\nWhen: 什么时候该使用 Key 实战例子 需求: 点击界面上一个按钮，然后交换行中的两个色块。\nStatelessWidget 实现 使用 StatelessWidget(StatelessColorfulTile) 做 child(tiles):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class PositionedTiles extends StatefulWidget { @override State\u0026lt;StatefulWidget\u0026gt; createState() =\u0026gt; PositionedTilesState(); } class PositionedTilesState extends State\u0026lt;PositionedTiles\u0026gt; { List\u0026lt;Widget\u0026gt; tiles; @override void initState() { super.initState(); tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; } @override Widget build(BuildContext context) { return Scaffold( body: SafeArea( child: Center( child: Row( mainAxisAlignment: MainAxisAlignment.center, children: tiles))), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles)); }   当点击按钮时，更新 PositionedTilesState 中储存的 tiles:\n1 2 3 4 5 6  void swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } }   1 2 3 4 5 6 7 8  class StatelessColorfulTile extends StatelessWidget { final Color color = UniqueColorGenaretor.getColor(); StatelessColorfulTile({Key key}) : super(key: key); @override Widget build(BuildContext context) =\u0026gt; buildColorfulTile(color); }   结果  成功实现需求 ^_^  StatefulWidget 实现 使用 StatefulWidget(StatefulColorfulTile) 做 child(tiles):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override State\u0026lt;StatefulWidget\u0026gt; createState() =\u0026gt; StatefulColorfulTileState(); } class StatefulColorfulTileState extends State\u0026lt;StatefulColorfulTile\u0026gt; { // 将 Color 储存在 StatefulColorfulTile 的 State StatefulColorfulTileState 中.  Color color; @override void initState() { super.initState(); color = UniqueColorGenaretor.getColor(); } @override Widget build(BuildContext context) =\u0026gt; buildColorfulTile(color); }   修改外部容器 PositionedTiles 中 tiles:\n1 2 3 4 5 6 7 8  @override void initState() { super.initState(); tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; }   结果  貌似没效果 -_-  为什么使用 StatefulWidget 就不能成功更新呢？ 需要先了解下面的内容。\nFluuter 对 Widget 的更新原理 \u0008在 Flutter 框架中，视图维持在树的结构中，我们编写的 Widget 一个嵌套一个，最终组合为一个 Tree。\nStatelessWidget 在第一种使用 StatelessWidget 的实现中，当 Flutter 渲染这些 Widgets 时，Row Widget 为它的子 Widget 提供了一组有序的插槽。对于每一个 Widget，Flutter 都会构建一个对应的 Element。构建的这个 Element Tree 相当简单，仅保存有关每个 Widget 类型的信息以及对子Widget 的引用。你可以将这个 Element Tree 当做就像你的 Flutter App 的骨架。它展示了 App 的结构，但其他信息需要通过引用原始Widget来查找。\n当我们交换行中的两个色块时，Flutter 遍历 Widget 树，看看骨架结构是否相同。它从 Row Widget 开始，然后移动到它的子 Widget，Element 树检查 Widget 是否与旧 Widget 是相同类型和 Key。 如果都相同的话，它会更新对新 widget 的引用。在我们这里，Widget 没有设置 Key，所以Flutter只是检查类型。它对第二个孩子做同样的事情。所以 Element 树将根据 Widget 树进行对应的更新。\n当 Element Tree 更新完成后，Flutter 将根据 Element Tree 构建一个 Render Object Tree，最终开始渲染流程。\nStatefulWidget 当使用 StatefulWidget 实现时，控件树的结构也是类似的，只是现在 color 信息没有存储控件自身了，而是在外部的 State 对象中。\n现在，我们点击按钮，交换控件的次序，Flutter 将遍历 Element 树，检查 Widget 树中 Row 控件并且更新 Element 树中的引用，然后第一个 Tile 控件检查它对应的控件是否是相同类型，它发现对方是相同的类型; 然后第二个 Tile 控件做相同的事情，最终就导致 Flutter 认为这两个控件都没有发生改变。Flutter 使用 Element 树和它对应的控件的 State 去确定要在设备上显示的内容, 所以 Element 树没有改变，显示的内容也就不会改变。\nStatefullWidget 结合 Key 现在，为 StatefulColorfulTile 传递一个 Key 对象:\n1 2 3 4 5 6 7 8  void initState() { super.initState(); tiles = [ // 使用 UniqueKey  StatefulColorfulTile(key: UniqueKey()), StatefulColorfulTile(key: UniqueKey()), ]; }   再次运行:\n成功 swap!\n添加了 Key 之后的结构:\n当现在执行 swap 时, Element 数中 StatafulWidget 控件除了比较类型外，还会比较 key 是否相等:\n只有类型和key 都匹配时，才算找到对应的 Widget。于是在 Widget Tree 发生交换后，Element Tree 中子控件和原始控件对应关系就被打乱了，所以 Flutter 会重建 Element Tree，直到控件们正确对应上。\n所以，现在 Element 树正确更新了，最终就会显示交换后的色块。\n使用场景 如果要修改集合中的控件的顺序或数量，Key 会很有用。\nWhere: 在哪设置 Key 正常情况下应该在当前 Widget 树的顶级 Widget 中设置。\n回到 StatefulColorfulTile 例子中，为每个色块添加一个 Padding，同时 key 还是设置在相同的地方:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  @override void initState() { super.initState(); tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; }   当点击按钮发生交换之后，可以看到两个色块的颜色会随机改变，但是我的预期是两个固定的颜色彼此交换。\n为什么产生问题 当Widget 树中两个 Padding 发生了交换，它们包裹的色块也就发生了交换:\n然后 Flutter 将进行检查，以便对 Element 树进行对应的更新: Flutter 的 Elemetn to Widget 匹配算法将一次只检查树的一个层级:\n 在第一级，Padding Widget 都正确匹配。  在第二级，Flutter 注意到 Tile 控件的 Key 不匹配，就停用该 Tile Element，删除 Widget 和 Element 之间的连接  我们这里使用的 Key 是 UniqueKey， 它是一个 LocalKey  LocalKey 的意思是: 当 Widget 与 Element 匹配时，Flutter 只在树中特定级别内查找匹配的 Key。因此 Flutter 无法在同级中找到具有该 Key 的 Tile Widget，所以它会创建一个新 Element 并初始化一个新 State。 就是这个原因，造成色块颜色发生随机改变，每次交换相当于生成了两个新的 Widget。\n解决这个问题: 将 Key 设置到上层 Widget Padding 上  当 Widget 树中两个 Padding 发生交换之后，Flutter 就能根据 Padding 上 Key 的变化，更新 Element 树中的两个 Padding，从而实现交换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @override void initState() { super.initState(); tiles = [ Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; }   Which: 该使用哪种类型的 Key Key 的目的在于为每个 Widget 指明一个唯一的身份，使用何种 Key 就要依具体的使用场景决定。\n ValueKey  例如在一个 ToDo 列表应用中，每个 Todo Item 的文本是恒定且唯一的。这种情况，适合使用 ValueKey，value 是文本。\n ObjectKey  假设，每个子 Widget 都存储了一个更复杂的数据组合，比如一个用户信息的地址簿应用。任何单个字段（如名字或生日）可能与另一个条目相同，但每个数据组合是唯一的。在这种情况下， ObjectKey 最合适。\n UniqueKey  如果集合中有多个具有相同值的 Widget，或者如果您想确保每个 Widget 与其他 Widget 不同，则可以使用 UniqueKey。 在我们的例子中就使用了 UniqueKey，因为我们没有将任何其他常量数据存储在我们的色块上，并且在构建 Widget 之前我们不知道颜色是什么。\n不要在 Key 中使用随机数，如果你那样设置，那么当每次构建 Widget 时，都会生成一个新的随机数，Element 树将不会和 Widget 树做一致的更新。\n GlobalKeys  Global Keys有两种用途。\n  它们允许 Widget 在应用中的任何位置更改父级而不会丢失 State ，或者可以使用它们在 Widget 树 的完全不同的部分中访问有关另一个 Widget 的信息。\n 比如: 要在两个不同的屏幕上显示相同的 Widget，同时保持相同的 State，则需要使用 GlobalKeys。    在第二种情况下，您可能希望验证密码，但不希望与树中的其他 Widget 共享该状态信息，可以使用 GlobalKey\u0026lt;FromState\u0026gt; 持有一个表单 Form 的 State。 Flutter.dev 上有这个例子Building a form with validation。\n  其实 GlobalKeys 看起来有点像全局变量。有也其他更好的方法达到 GlobalKeys 的作用，比如 InheritedWidget、Redux 或 Block Pattern。\n总结 如何合理适当的使用 Key:\n When: 当您想要保留 Widget 树的状态时，请使用 Key。例如: 当修改相同类型的 Widget 集合（如列表中）时 Where: 将 Key 设置在要指明唯一身份的 Widget 树的顶部 Which: 根据在该 Widget 中存储的数据类型选择使用的不同类型的Key   参考\n https://flutter.dev/docs/development/ui/widgets-intro#keys https://api.flutter.dev/flutter/foundation/Key-class.html https://www.youtube.com/watch?v=kn0EOS-ZiIc https://www.yuque.com/xytech/flutter/tge705    上文涉及的例子代码: https://github.com/stefanJi/fullter-playgroud\n","description":"通过实际案列理解 Flutter 中 Key 在其渲染机制中起到的作用，从而达到能在合理的时间和地点使用合理的 Key","id":48,"section":"posts","tags":null,"title":"理解 Flutter 中的 Key","uri":"https://jiyang.site/posts/2019-06-01-%E7%90%86%E8%A7%A3-flutter-%E4%B8%AD%E7%9A%84-key/"},{"content":"记录在 Ubuntu Server 上创建用户，并配置其通过 SSH Key File 登录的操作\n首先以 root 身份登录 创建用户 这里使用较方便的命令 adduser， 而不是 usesadd。 因为 adduser 相等来说更简单，可以 step by step 的配置\nadduser tom 输出:\nAdding user `tom' ... Adding new group `tom' (1001) ... Adding new user `tom' (1001) with group `tom' ... Creating home directory `/home/tom' ... Copying files from `/etc/skel' ... Enter new UNIX password: 配置好密码之后继续:\nRetype new UNIX password: passwd: password updated successfully Changing the user information for tom Enter the new value, or press ENTER for the default Full Name []: Room Number []: Work Phone []: Home Phone []: Other []: Is the information correct? [Y/n] y 创建成功\n赋予 sudo 权限 查看用户组:\ngroups tom // tom: tom 追加到 sodu 组:\nusermod -aG sudo tom groups tom // tom: tom sudo 配置 SSH 登录 在本地使用 ssh-copy-id 命令，通过 -i 指定 identity_file\nssh-copy-id -i .ssh/id_rsa tom@host 将会自动在 /home/tom/.ssh/authorized_keys 文件追加我们指定的 ssh key. 然后就可以直接 ssh tom@host 免输密码登录了。\n","description":"记录在 Ubuntu Server 上创建用户，并配置其通过 SSH Key File 登录的操作","id":49,"section":"posts","tags":null,"title":"Ubuntu 新建用户并配置SSH Key登录","uri":"https://jiyang.site/posts/2019-05-25-ubuntu-%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E9%85%8D%E7%BD%AEssh-key%E7%99%BB%E5%BD%95/"},{"content":"在需要生成复杂对象的地方，可以使用工厂方法模式。\n使用场景  在需要生成复杂对象的地方，可以使用工厂方法模式。定义一个创建对象的接口，让子类工厂决定创建怎样的类。\n 类图 @startuml abstract class Product{ + method():Void } class ConcreteProduct extends Product{ + method():Void } abstract class Factory{ + createProduct(): Product } class ConcreteFactory extends Factory{ + createProduct(): Product } ConcreteFactory .\u0026gt; ConcreteProduct @enduml  Product: 工厂将生产的产品的抽象 ConcreteProduct: 一种具体的产品 Factory: 工厂的抽象，定义了生产产品的方法 ConcreteFactory: 生产某种具体产品的工厂  实现方式 情景:\n使用工厂方法模式，实现一个鞋厂的程序。\n定义了鞋子和鞋子工厂的抽象，并实现了雪地鞋和运动鞋两种产品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  abstract class Shoes { abstract String name(); } public abstract class ShoesFactory { abstract Shoes createShoes(); } class SportShoes extends Shoes { @Override String name() { return \u0026#34;Sport Shoes\u0026#34;; } } class SnowShoes extends Shoes { @Override String name() { return \u0026#34;Snow Shoes\u0026#34;; } }   多个具体的工厂 针对每个产品定义一个工厂类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SportShoesFactory extends ShoesFactory { @Override SportShoes createShoes() { return new SportShoes(); } } class SnowShoesFactory extends ShoesFactory { @Override SnowShoes createShoes() { return new SnowShoes(); } }   一个工厂 定义一个工厂类，通过反射实现不同产品的创建\n修改抽象工厂:\n1 2 3  public abstract class ShoesFactory { abstract \u0026lt;T extends Shoes\u0026gt; T createShoes(Class\u0026lt;T\u0026gt; clazz); }   1 2 3 4 5 6 7 8 9 10 11 12  class ShangHaiShoesFactory extends ShoesFactory { @Override \u0026lt;T extends Shoes\u0026gt; T createShoes(Class\u0026lt;T\u0026gt; clazz) { try { return clazz.getDeclaredConstructor().newInstance(); } catch (Exception e) { e.printStackTrace(); } return null; } }   静态工厂方法  有时能确保只有一种工厂，并不需要创建一个抽象工厂时，可以创建一个普通的工厂类，提供创建对象的方法。\n","description":"在需要生成复杂对象的地方，可以使用工厂方法模式。","id":50,"section":"posts","tags":null,"title":"工厂方法模式","uri":"https://jiyang.site/posts/2019-05-19-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"content":"概览  inline: 声明在编译时，将函数的代码拷贝到调用的地方(内联) noinline: 声明 inline 函数的形参中，不希望内联的 lambda crossinline: 表明 inline 函数的形参中的 lambda 不能有 return  inline 使用 inline 声明的函数，在编译时将会拷贝到调用的地方。\ninline function 定义一个sum函数计算两个数的和。\n1 2 3 4 5 6 7  fun main(args: Array\u0026lt;String\u0026gt;) { println(sum(1, 2)) } fun sum(a: Int, b: Int): Int { return a + b }   反编译为 Java 代码:\n1 2 3 4 5 6 7 8  public static final void main(@NotNull String[] args) { int var1 = sum(1, 2); System.out.println(var1); } public static final int sum(int a, int b) { return a + b; }   正常的样子，在该调用的地方调用函数。\n然后为 sum 函数添加 inline 声明:\n1 2 3  inline fun sum(a: Int, b: Int): Int { return a + b }   再反编译为 Java 代码:\n1 2 3 4 5 6 7 8 9 10 11  public static final void main(@NotNull String[] args) { //...  byte a$iv = 1; int b$iv = 2; int var4 = a$iv + b$iv; System.out.println(var4); } public static final int sum(int a, int b) { return a + b; }   sum 函数的实现代码被直接拷贝到了调用的地方。\n上面两个使用实例并没有体现出 inline 的优势。当你的函数中有 lambda 形参时，inline 的优势才会体现。\ninline function with lambda parameters 考虑如下代码，会被编译成怎样的 Java 代码?\n1 2 3 4 5 6 7 8 9  fun sum(a: Int, b: Int, lambda: (result: Int) -\u0026gt; Unit): Int { val r = a + b lambda.invoke(r) return r } fun main(args: Array\u0026lt;String\u0026gt;) { sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) } }   反编译为 Java:\n1 2 3 4 5 6 7 8 9 10 11  public static final int sum(int a, int b, @NotNull Function1 lambda) { //...  int r = a + b; lambda.invoke(r); return r; } public static final void main(@NotNull String[] args) { //...  sum(1, 2, (Function1)null.INSTANCE); }    (Function1）null.INSTANCE，是由于反编译器工具在找不到等效的 Java 类时的显示的结果。\n 我传递的那个 lambda 被转换为 Function1 类型，它是 Kotlin 函数（kotlin.jvm.functions包）的一部分，它以 1 结尾是因为我们在 lambda 函数中传递了一个参数（result：Int)。\n再考虑如下代码:\n1 2 3 4 5  fun main(args: Array\u0026lt;String\u0026gt;) { for (i in 0..10) { sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) } } }   我在循环中调用 sum 函数，每次传递一个 lambda 打印结果。反编译为 Java:\n1 2 3  for(byte var2 = 10; var1 \u0026lt;= var2; ++var1) { sum(1, 2, (Function1)null.INSTANCE); }   可见在每次循环里都会创建一个 Function1 的实例对象。这里就是性能的优化点所在，如何避免在循环里创建新的对象？\n 在循环外部创建 lambda 对象  1 2 3 4 5  val l: (r: Int) -\u0026gt; Unit = { println(it) } for (i in 0..10) { sum(1, 2, l) }   反编译为 Java:\n1 2 3 4 5 6  Function1 l = (Function1)null.INSTANCE; int var2 = 0; for(byte var3 = 10; var2 \u0026lt;= var3; ++var2) { sum(1, 2, l); }   只会创建一个 Function 对象\n使用 inline:  1 2 3 4 5 6 7 8 9 10 11  fun main(args: Array\u0026lt;String\u0026gt;) { for (i in 0..10) { sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) } } } inline fun sum(a: Int, b: Int, lambda: (result: Int) -\u0026gt; Unit): Int { val r = a + b lambda.invoke(r) return r }   反编译为 Java:\n1 2 3 4 5 6 7 8 9 10 11 12  public static final void main(@NotNull String[] args) { //...  int var1 = 0; for(byte var2 = 10; var1 \u0026lt;= var2; ++var1) { byte a$iv = 1; int b$iv = 2; int r$iv = a$iv + b$iv; String var9 = \u0026#34;Result is: \u0026#34; + r$iv; System.out.println(var9); } }   lambda 代码在编译时被拷贝到调用的地方， 避免了创建 Function 对象。\ninline 注意事项 public inline 函数不能访问私有属性 1 2 3 4 5 6 7 8 9 10 11  class Demo(private val title: String) { inline fun test(l: () -\u0026gt; Unit) { println(\u0026#34;Title: $title\u0026#34;) // 编译错误: Public-Api inline function cannot access non-Public-Api prive final val title  } // 私有的没问题  private inline fun test(l: () -\u0026gt; Unit) { println(\u0026#34;Title: $title\u0026#34;) } }   注意程序控制流 当使用 inline 时，如果传递给 inline 函数的 lambda，有 return 语句，那么会导致闭包的调用者也返回。\n例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  inline fun sum(a: Int, b: Int, lambda: (result: Int) -\u0026gt; Unit): Int { val r = a + b lambda.invoke(r) return r } fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Start\u0026#34;) sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) return // 这个会导致 main 函数 return  } println(\u0026#34;Done\u0026#34;) }   反编译 Java:\n1 2 3 4 5 6 7 8 9  public static final void main(@NotNull String[] args) { String var1 = \u0026#34;Start\u0026#34;; System.out.println(var1); byte a$iv = 1; int b$iv = 2; int r$iv = a$iv + b$iv; String var7 = \u0026#34;Result is: \u0026#34; + r$iv; System.out.println(var7); }   反编译之后也能看到，lambda return 之后的代码不会执行。\n如何避免?\n可以使用 return@label 语法，返回到 lambda 被调用的地方。\n1 2 3 4 5 6 7 8  fun main(args: Array\u0026lt;String\u0026gt;) { println(\u0026#34;Start\u0026#34;) sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) return@sum } println(\u0026#34;Done\u0026#34;) }   noinline 当一个 inline 函数中，有多个 lambda 作为参数时，可以在不想内联的 lambda 前使用 noinline 声明.\n1 2 3 4 5 6 7 8 9 10 11 12 13  inline fun sum(a: Int, b: Int, lambda: (result: Int) -\u0026gt; Unit, noinline lambda2: (result: Int) -\u0026gt; Unit): Int { val r = a + b lambda.invoke(r) lambda2.invoke(r) return r } fun main(args: Array\u0026lt;String\u0026gt;) { sum(1, 2, { println(\u0026#34;Result is: $it\u0026#34;) }, { println(\u0026#34;Invoke lambda2: $it\u0026#34;) } ) }   反编译 Java:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static final int sum(int a, int b, @NotNull Function1 lambda, @NotNull Function1 lambda2) { int r = a + b; lambda.invoke(r); lambda2.invoke(r); return r; } public static final void main(@NotNull String[] args) { byte a$iv = 1; byte b$iv = 2; Function1 lambda2$iv = (Function1)null.INSTANCE; int r$iv = a$iv + b$iv; String var8 = \u0026#34;Result is: \u0026#34; + r$iv; System.out.println(var8); lambda2$iv.invoke(r$iv); }   第一个 lambda 内联到了调用处，而第二个使用 noinline 声明的 lambda 没有。\ncrossinline 声明一个 lambda 不能有 return 语句(可以有 return@label 语句)。这样可以避免使用 inline 时，lambda 中的 return 影响程序流程。\n1 2 3 4 5 6 7 8 9 10 11 12  inline fun sum(a: Int, b: Int, crossinline lambda: (result: Int) -\u0026gt; Unit): Int { val r = a + b lambda.invoke(r) return r } fun main(args: Array\u0026lt;String\u0026gt;) { sum(1, 2) { println(\u0026#34;Result is: $it\u0026#34;) return // 编译错误: return is not allowed here  } }   总结  PS: 使用 Kotlin 的一些特性时，最好反编译为 Java 代码看看，它帮我们做了什么，做到心中有数。\n 本文主要涉及在使用 lambda 时，合理利用 inline noinline crossinline 可以优化程序运行效率和降低业务出错率。\n  inline\n  内联一些小函数代码到调用处，减少函数调用开销\n  用于 lambda 参数的函数，内联能进一步避免为 lambda 生成 FunctionN 对象\n  noinline\n  结合 inline 时，声明不用内联的 lambda\n  crossinline\n  声明 inline 函数中的 lambda 不能使用 return 截断程序流程\n ","description":"涉及 Kotlin 中内联函数相关的问题。","id":51,"section":"posts","tags":null,"title":"Kotlin 必须要知道的 inline noinline crossinline","uri":"https://jiyang.site/posts/2019-04-30-kotlin-inline-noinline-crossinline/"},{"content":"原型模式的使用场景  在创建一个实例，较复杂的或耗时的情况下，复制一个已经存在的实例能使程序运行更高效。\n  类初始化需要耗费很多资源，通过原型拷贝避免这些耗费 通过 new 产生一个对象，需要频繁的数据准备或访问权限时 保护性拷贝，防止一个对象被调用者修改  原型模式的类图 @startuml interface Prototype { + clone() } class ConcretePrototype implements Prototype{ + clone() } class Client Client .o Prototype @enduml  Client: 客户端 Prototype: 抽象类或接口，声明具有 clone 能力 ConcretePrototype: 具体的原型类  简单实现 使用原型模式，实现一个文档拷贝的例子. WordDocument 表示一份用户的文档，这个文档中包含文字和图片。\n用户希望编辑一份已经存在的文档，但是不确定是否采用新的编辑。因此，为了安全，将原有的文档拷贝一份，在拷贝的文档上进行操作。\n原始文档就是样板实例，既原型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class WordDocument : Cloneable { var text: String = \u0026#34;\u0026#34; var images: ArrayList\u0026lt;String\u0026gt; = ArrayList() public override fun clone(): WordDocument { val doc = super.clone() as WordDocument doc.text = this.text doc.images = this.images return doc } override fun toString(): String = \u0026#34;doc: $text\\nimages: $images\u0026#34; }   修改文档文本内容 1 2 3 4 5 6 7 8 9 10 11 12 13  fun main(args: Array\u0026lt;String\u0026gt;) { val doc = WordDocument() doc.text = \u0026#34;document text\u0026#34; doc.images.add(\u0026#34;image1\u0026#34;) doc.images.add(\u0026#34;image2\u0026#34;) println(\u0026#34;doc1: $doc\u0026#34;) // 拷贝  val doc2 = doc.clone() println(\u0026#34;doc2: $doc2\u0026#34;) doc2.text = \u0026#34;update document text\u0026#34; println(\u0026#34;doc2: $doc2\u0026#34;) println(\u0026#34;doc1: $doc\u0026#34;) }   输出:\ndoc1: doc: document text images: [image1, image2] doc2: doc: document text images: [image1, image2] doc2: doc: update document text images: [image1, image2] doc1: doc: document text images: [image1, image2] 可见新的文档对象的文本内容修改不会影响原始的文本对象。\n修改文档文本和图片内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  fun main(args: Array\u0026lt;String\u0026gt;) { val doc = WordDocument() doc.text = \u0026#34;document text\u0026#34; doc.images.add(\u0026#34;image1\u0026#34;) doc.images.add(\u0026#34;image2\u0026#34;) println(\u0026#34;doc1: $doc\u0026#34;) // 拷贝  val doc2 = doc.clone() println(\u0026#34;doc2: $doc2\u0026#34;) doc2.text = \u0026#34;update document text\u0026#34; // 添加一张图片  doc2.images.add(\u0026#34;image3\u0026#34;) println(\u0026#34;doc2: $doc2\u0026#34;) println(\u0026#34;doc1: $doc\u0026#34;) }   输出:\ndoc1: doc: document text images: [image1, image2] doc2: doc: document text images: [image1, image2] doc2: doc: update document text images: [image1, image2, image3] doc1: doc: document text images: [image1, image2, image3] 在新文档对象中增加的图片同时也出现在了原始对象中，这是由于 WordDocument 中 clone 的实现是浅拷贝造成的。由于 images 是 List 类型，属于引用类型，浅拷贝传递的是对象的引用。\n深拷贝,浅拷贝 对于引用类型对象，变量持有的是对象的引用，在进行拷贝时，如果只是引用赋值，就是浅拷贝，新对象中的变量就还是引用的原型对象中的变量。既 doc2.images 与 doc1.images 都引用的同一个对象。\n修改 WordDocument 的 clone 为深拷贝:\n1 2 3 4 5 6  public override fun clone(): WordDocument { val doc = super.clone() as WordDocument doc.text = this.text doc.images = this.images.clone() as ArrayList\u0026lt;String\u0026gt; return doc }   通过深拷贝可以避免对拷贝对象的修改影响原型对象的内容。\n","description":"原型模式是一种创建型的模式，用户从一个样本对象中复制出一个内部属性一致的对象。","id":52,"section":"posts","tags":null,"title":"使程序运行更高效-原型模式","uri":"https://jiyang.site/posts/2019-04-27-%E4%BD%BF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"content":"回想学校时期，学习计算机网络时，老师都是按照课本上的概念讲解，很是抽象，大家基本都是靠死记硬背。看了这本书之后，发现 Wiershark 其实是一个很好的教学工具。毕竟实践才是检验真理唯一标准，如果当年老师能通过实战教学，大家应该能深刻很多。\n 虽然教材《计算机网络》上主打的是 OSI 7 层模型，但是实际世界中，大家更喜欢 TCP/IP 模型，因为其更直观和简单，因此 Wireshark 也是基于 TCP/IP 模型进行网络分析的。\n 抓包 利用 Wiershark 的 filter, 可以过滤只有我本机发起的请求，下面是通过浏览器访问 blog.jiyang.site 时，进行 DNS 查询的过程。\n从这个请求详情中可以看到分层情况:\n 数据链路层 网络接口层 网络层 传输层 应用层  每经过一层，每层协议都会增加自己的数据到数据包中:\n TCP/IP 模型 Wiki\n","description":"最近被 kindle 推荐了一本讲 Wireshark 的书《Wireshark网络分析就这么简单》，看评论很不错。于是看了样章，发现确实不错，作者以自己的实际工作经验，结合通俗易懂的文笔，将与网络有关的知识讲解的颇有趣味。本文是笔者看过【从 Wireshark 看网络分层】章节之后的记录，旨在巩固在学校学习的网络分层知识。","id":53,"section":"posts","tags":null,"title":"通过 Wireshark 看网络分层","uri":"https://jiyang.site/posts/2019-04-13-%E9%80%9A%E8%BF%87wireshark%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/"},{"content":"策略模式 针对同一类情况, 如果因为某个或多个因素和有不同的处理方法, 一般这种就会造成写很多的if else, 甚至嵌套. 策略模式就是针对这种情况的一种让代码遵循开闭原则的方案.\n适用场景  针对同一类型问题的多种处理方式, 仅仅是具体行为有差别时 需要安全的封装同一类型的操作时 出现同一个抽象有多个子类, 而又要使用 if else 来判断具体实现时  类图 @startuml class Context { +algorithm() +setStrategy(Strategy) } interface Strategy { +algorithm() } class StrategyA { +algorithm() } class StrategyB { +algorithm() } Context o- Strategy Strategy \u0026lt;|-- StrategyA Strategy \u0026lt;|-- StrategyB @enduml  Context: 持有策略的上下文 Strategy: 策略的抽象 StrategyA, StrategyB 具体的策略实现  优点 通过将同一类型问题的处理方式抽象, 然后由具体类实现行为. 在需要使用不同的方式处理时, 将具体实现类注入到持有策略的上下文中. 避免将不同处理方式通过 if else 实现在一个类中.\n例子 计算在民用电和工业用电下, 使用相同电, 需要缴纳的电费. 因为民用电和工业电的计算方法不一样, 所以会有分支出现.\n常规实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public class ElectricCalculator { enum Type { V220, // 民用电一般为 220V  V380 // 商用电压一般为三厢380V  } public double calculate(float deg, Type type) { if (type == Type.V220) { return calculateV220(deg); } if (type == Type.V380) { return calculateV380(deg); } return 0; } private double calculateV220(float deg) { return deg * 0.5; } private double calculateV380(float deg) { return deg * 0.86; } public static void main(String[] args) { ElectricCalculator calculator = new ElectricCalculator(); double feeV220 = calculator.calculate(100, Type.V220); // 计算民用电  double feeV380 = calculator.calculate(100, Type.V380); // 计算工业用电  } }   现在这个类里的逻辑还比较简单, 看起来没什么问题. 如果加上电费的梯度收费、分季节收费, 再加上支持租房用电费计算, 那这个类的逻辑就有点乱了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public class ElectricCalculator { enum Type { V220, // 民用电一般为 220V  V380, // 商用电压一般为三厢380V  RENT // 租房用电一般不同于民用电收费  } /** * @param deg 本月当前用电 * @param type 用电类型 * @param isSummer 是否夏季 */ public double calculate(float deg, Type type, boolean isSummer) { if (type == Type.V220) { return calculateV220(deg, isSummer); } if (type == Type.V380) { return calculateV380(deg, isSummer); } if (type == Type.RENT) { return calculateRent(deg, isSummer); } return 0; } // 模拟梯度收费和分夏季收费  private double calculateV220(float deg, boolean isSummer) { float rate = 0.5f; if (deg \u0026gt; 500) { rate = 0.6f; } if (deg \u0026gt; 800) { rate = 0.7f; } if (isSummer) { rate += 0.1f; } return deg * rate; } private double calculateV380(float deg, boolean isSummer) { return deg * 0.86; } private double calculateRent(float deg, boolean isSummer) { return deg * 1; } }   现在支持了梯度收费和分季节收费, 而且每个类型的电费计算方式又不一样, 这个类里就会包含很多的分支逻辑. 且当需要修改或添加一种电费类型时, 很容易造成错误.\n这种情况下, 就适合使用策略模式, 将电费的计算方法抽象化, ElectricCalculator 中的计算方法的具体实现由外部注入.\n重构 @startuml class ElectricCalculator { +calculate(int deg) +setCalculator(Calculator) } interface Calculator { +calculate(int deg) } class V220Calculator { +calculate(int deg) } class V220SummerCalculator { +calculate(int deg) } ElectricCalculator o- Calculator Calculator \u0026lt;|-- V220Calculator Calculator \u0026lt;|-- V220SummerCalculator @enduml 策略抽象 1 2 3  interface Calculator { double calculate(float deg); }   实现不同策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14  class V220Calculator implements Calculator { @Override public double calculate(float deg) { float rate = 0.5f; if (deg \u0026gt; 600) { rate = 0.6f; } if (deg \u0026gt; 900) { rate = 0.7f; } return deg * rate; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  // 针对夏季的 class V220SummerCalculator implements Calculator { @Override public double calculate(float deg) { float rate = 0.5f; if (deg \u0026gt; 500) { rate = 0.6f; } if (deg \u0026gt; 800) { rate = 0.7f; } return deg * rate; } }   注入策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class ElectricCalculator { private Calculator mCalculator; public void setCalculator(Calculator calculator) { mCalculator = calculator; } public double calculate(float deg) { if (mCalculator == null) { throw new IllegalStateException(\u0026#34;Calculator must not null\u0026#34;); } return mCalculator.calculate(deg); } public static void main(String[] args){ ElectricCalculator calculator = new ElectricCalculator(); calculator.setCalculator(new V220Calculator()); double fee = calculator.calculate(100); calculator.setCalculator(new V220SummerCalculator()); double feeSummer = calculator.calculate(10); } }   重构之后 可以看出, ElectricCalculator 类中的逻辑变简单了, 而且每个不同的分支由不同的策略实现类代替, 保证了增加新策略的扩展性和修改代码的封闭性(不用修改ElectricCalculator中代码).\n","description":"减少条件判断语句, 增强代码的可维护性和扩展性, 让代码遵循开闭原则, 策略模式值得拥有.","id":54,"section":"posts","tags":null,"title":"时势造英雄-策略模式","uri":"https://jiyang.site/posts/2019-04-01-%E6%97%B6%E5%8A%BF%E9%80%A0%E8%8B%B1%E9%9B%84-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"content":"单例模式的优点 单例对象的类保证只有一个实例存在。确保某个类有且仅有一个实例存在，避免产生多个对象消耗过多资源。\n关键点  构造函数私有, 不对外开放 通过静态方法, 枚举或容器返回单例类对象 确保单例类对象有且仅有一个, 尤其在多线程环境下 确保单例类对象在反序列化时不会重新创建  实现方式： 饿汉式 在类初始化时就创建单例对象. 下面有两种实现方式:\n静态对象单例 使用静态对象持有一个单例实例, 在类初始化时就创建这个单例对象.\n1 2 3 4 5 6 7 8 9  public class Singleton{ private static INSTANCE = new Singleton(); private Singleton(){} public static Singleton instance(){ return INSTANCE; } }   枚举单例 利用枚举的单一性, 又能允许存在方法和属性的特性.\n1 2 3 4 5 6 7 8 9  public enum SingletonEnum { INSTANCE; void doSomething() {} } public static void main() { SingletonEnum.INSTANCE.doSomething(); }   枚举单例相比静态对象的单例, 优点在于可以防止反序列化的时候创建新的对象.\n饿汉式优点:\n 简单 线程安全(枚举单例也是)  饿汉式缺点:\n 如果实例的构造较耗时, 会造成类的加载过程较耗时 如果这个单例对象不会用到, 它也会一直存在, 造成内存的浪费  反序列化破解单例 当类实现了 Serializable 接口时, 类的对象就能被序列化和反序列化.但是当反序列化时, 获得的对象是重新分配的内存, 单例也就不存在了.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static void main(String[] args) { Singleton singleton = Singleton.instance(); writeToFile(singleton, \u0026#34;singleton\u0026#34;); Singleton singletonCopy = (Singleton) readFromFile(\u0026#34;singleton\u0026#34;); System.out.println(singleton == singletonCopy); //false =\u0026gt; 两个不同对象 } // 序列化到文件 public static void writeToFile(Object obj, String name) { try { FileOutputStream fOut = new FileOutputStream(name); ObjectOutputStream oOut = new ObjectOutputStream(fOut); oOut.writeObject(obj); oOut.close(); } catch (IOException e) { e.printStackTrace(); } } // 从文件反序列化 public static Object readFromFile(String path) { try { FileInputStream fIn = new FileInputStream(path); ObjectInputStream oIn = new ObjectInputStream(fIn); return oIn.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } return null; }   上面的例子就通过反序列化创建了一个新的对象, 绕过了单例的限制. 但是也有防止单例对象被反序列化的方法, 就是通过实现 readResolve 方法, 让该方法返回已有的单例对象.\n1 2 3  public Object readResolve(){ return INSTANCE; }   可以看到 readResolve 在从外部流创建对象时会被调用, 能有效防止通过反序列化手段创建单例之外的对象.\n懒汉式 针对饿汉式需要在类初始化时就创建对象, 出现了懒汉式的加载方法, 在需要时才进行单例对象的初始化. 主要有以下几种:\n 同步锁实现 双重锁检测实现 DoubleCheckLock 静态内部类单例实现  同步锁实现 1 2 3 4 5 6 7 8 9 10 11 12  public class SingletonLazy { private SingletonLazy() { } private static SingletonLazy _instance; public static synchronized SingletonLazy getInstance() { if (_instance == null) { _instance = new SingletonLazy(); } return _instance; } }   只有在第一次调用 SingletonLazy.getInstance() 时才创建单例对象, 之后再调用都不会创建新的.\n这种懒汉式模式能正常的运行, 也符合了单例的条件, 全局唯一, 多线程安全.\n但是存在性能上的问题, 因为直接对 getInstance 方法加锁, 会导致即使单例对象已经创建了, 每次获取单例对象都会进行同步锁获取和释放, 造成资源浪费.\n双重锁检测 DoubleCheckLock 为了解决上面同步锁造成的性能问题, 于是出现了 DoubleCheckLock(DSL)机制, 只在对象没有被创建的情况下,对创建过程加同步锁:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class SingletonLazy { private SingletonLazy() { } // volatile: 在 JDK 5 之前防止指令重排序  private static volatile SingletonLazy _instance; public static SingletonLazy getInstance() { if (_instance == null) { synchronized (SingletonLazy.class) { if (_instance == null) { _instance = new SingletonLazy(); } } } return _instance; } }   这里对单例对象进行了两次判空:\n 第一层判断是为了避免不必要的同步, 只在对象没有创建时才走到下面的同步代码块 第二层判断是为了只在 null 的情况下才创建对象. 在多线程情况下，如果两个以上线程都已经运行至同步锁处，也就是都已经判断变量为空，如锁内不再次判断，会导致实例重复创建  静态内部类单例 DCL 单例模式, 虽然能满足要求, 但是不是最优雅的实现, 静态内部类单例则能利用 JVM 的类加载机制做到单例实现.\n1 2 3 4 5 6 7 8 9 10 11  public class SingletonByInner { private SingletonByInner() { } private static class SingletonHolder { private final static SingletonByInner singleton = new SingletonByInner(); } public static SingletonByInner getInstance() { return SingletonHolder.singleton; } }   为什么静态内部类能实现线程安全的单例模式呢?\n因为 JVM 的类加载机制规定, 只有以下 5 种情况才会进行立即对类进行初始化(加载, 验证, 准备需要在此之前完成) :\n 遇到 new getstatic putstatic invokestatic 4 条字节码指令时, 如果类没有进行初始化, 则需要先触发初始化  4 个字节码指令对应的 Java 场景是:  使用 new 创建对象 读取或设置一个类的静态字段 调用一个类的静态方法时     通过反射获取类时, 如果类没有初始化, 则需要触发初始化 当初始化一个类, 发现其父类还未初始化时, 需要先初始化其父类 当虚拟机启动时, 用户需要指定一个包含了 main 方法的主类, 虚拟机会先初始化主类 使用 JDK 1.7 之后的动态支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果是 REF_getStatic REF_putStatic REF_invokeStatic 的方法句柄, 并且这个方法句柄对应的类没有进行初始化, 则需要先进行初始化  外部类 SingletonByInner 的字节码:\n{ private io.github.stefanji.singleton.SingletonByInner(); descriptor: ()V flags: ACC_PRIVATE Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #2 // Method java/lang/Object.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:()V 4: return LineNumberTable: line 4: 0 public io.github.stefanji.singleton.SingletonByInner getInstance(); descriptor: ()Lio/github/stefanji/singleton/SingletonByInner; flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: invokestatic #3 // Method io/github/stefanji/singleton/SingletonByInner$SingletonHolder.access$100:()Lio/github/stefanji/singleton/SingletonByInner; 3: areturn LineNumberTable: line 11: 0 可以看到第 18 行执行了 invokestatic 指令, 是当调用 getInstance 方法时才会走到这里. 也就说明只有当调用 getInstance 时, 才会触发内部类的初始化操作, 而且 JVM 只会初始化一个类一次, 所以就保证了内部类的静态实例在 JVM 中只有一个.\n使用容器实现单例模式 使用容器实现单例模式, 其实不是单例模式的具体实现, 而是一种组织多个单例对象的方式. 每个单例对象具体的实现方式可以是上面几种.\n容器对应 Java 中的 Map List 等结构, 有时需要在全局维护多个单例时, 使用容器能方便管理.\n比如 Android 中经常使用 Context 获取系统的一些服务, 其实这些服务在 Context 中都是以单例的方式存在的:\nContext.getSystemService 方法:\n1 2 3 4 5  @Override public Object getSystemService(String name) { // 调用 SystemServiceRegistry  return SystemServiceRegistry.getSystemService(this, name); }   在加载 SystemServiceRegistry 时会将常用服务创建, 并储存到单例容器 SYSTEM_SERVICE_FETCHERS 中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  final class SystemServiceRegistry { private static final String TAG = \u0026#34;SystemServiceRegistry\u0026#34;; private static final HashMap\u0026lt;String, ServiceFetcher\u0026lt;?\u0026gt;\u0026gt; SYSTEM_SERVICE_FETCHERS = new HashMap\u0026lt;String, ServiceFetcher\u0026lt;?\u0026gt;\u0026gt;(); // Not instantiable.  private SystemServiceRegistry() { } static { // 比如注册 LAYOUT_INFLATER_SERVICE  registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher\u0026lt;LayoutInflater\u0026gt;() { @Override public LayoutInflater createService(ContextImpl ctx) { return new PhoneLayoutInflater(ctx.getOuterContext()); }}); } public static Object getSystemService(ContextImpl ctx, String name) { // 从单例容器中获取单例对象  ServiceFetcher\u0026lt;?\u0026gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } }   ","description":"单例模式是应用最广的设计模式, 本文记录了常见的实现方式, 他们的优缺点, 如何规避反序列化绕过单例等. 涉及 JVM 的类加载, 虚拟机字节码指令,","id":55,"section":"posts","tags":null,"title":"应用最广的模式-单例模式","uri":"https://jiyang.site/posts/2019-03-22-%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF%E7%9A%84%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"content":"在 Flutter 中自定义 View 有两种方式:\n 组合已有控件 自定义绘制  如何自定义绘制 有两个类做这件事情:\n CustomPaint :会在绘制阶段提供一个 Canvas 画布 CustomPainter : 具体的画笔, 可配置画笔的颜色,路径等  1 2 3 4 5 6 7 8 9 10 11 12 13  CustomPaint( painter: Sky(), child: Center( child: Text( \u0026#39;Once upon a time...\u0026#39;, style: const TextStyle( fontSize: 40.0, fontWeight: FontWeight.w900, color: Color(0xFFFFFFFF), ), ), ), )   当在绘制阶段时, CustomPaint 首先会调用 painter 在画布上进行绘制, 然后再绘制它的 child 控件, child 绘制完成之后会调用 foregroundPainter 进行绘制. 画布的坐标系和 CustomPaint 的坐标系匹配. CustomPaint 有个 Size 属性标识将绘制多大的区域, 绘制时这个 Size 属性将会传递到 CustomPainter 的 paint 方法中, 具体的绘制就在paint 方法中进行,  void paint(Canvas canvas, Size size); 的方法签名中的两个参数:\n canvas: 用于绘制的画布, 注意: 该画布是应用所有控件都在使用的, 所以通过这个画布其实是可以绘制充满屏幕的内容的 size: 表示应该绘制的区域大小, 每次绘制都应该限制在这个区域内, 否则可能会覆盖了其他控件的绘制结果  实例一 绘制一个矩形和圆角:\n ![](https://image.youcute.cn/005EDc3Bgy1g14ok70rkyj30b40jy75i.jpg)  1 2 3 4 5 6  Widget build(BuildContext context) { return CustomPaint( painter: ColorPainter(), size: Size(300, 200), ); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class ColorPainter extends CustomPainter { final red = Color.fromRGBO(255, 0, 0, 1); final blue = Color.fromRGBO(0, 0, 255, 1); @override void paint(Canvas canvas, Size size) { final paint = Paint(); final rect = Rect.fromLTRB(0.0, 0.0, size.width, size.height); // 注意这一句  canvas.clipRect(rect); paint.color = blue; canvas.drawRect(rect, paint); paint.color = red; canvas.drawCircle(Offset.zero, size.height, paint); } @override bool shouldRepaint(CustomPainter oldDelegate) { return false; } }    定义了绘制区域大小, 为 CustomPaint 中的 size 属性  1  final rect = Rect.fromLTRB(0.0, 0.0, size.width, size.height);    绘制矩形区域  1  canvas.drawRect(rect, paint);    绘制圆形  圆心偏移量为: 0, 也就是 CustomPaint 的原点 半径为区域的高度    1  canvas.drawCircle(Offset.zero, size.height, paint);   最需要注意的地方我觉得是 canvas.clipRect(rect); 这句. 这句表示只绘制给定的区域中的内容. 如果不写这句, 效果就是这样:\n ![](https://image.youcute.cn/005EDc3Bgy1g14okkt75nj30b40jyabf.jpg)   为什么会这样呢 ?\n 其实这就是 Size 这个参数的重要性, 因为 Canvas 是被所有控件公有的, 如果我们绘制时不指定区域大小, 那在进行一些形状的绘制时就会出现超出区域的问题.\n实例二: 绘制一个带波纹的 CardView  支持颜色配置 支持组合外部控件\n源码: wave_card.dart\n![flutter wave card](https://raw.githubusercontent.com/stefanJi/fullter-playgroud/master/art/wave_card.png#pic_center =x500) ","description":"使用 Flutter 自定义绘制控件","id":56,"section":"posts","tags":null,"title":"Flutter 自定义绘制控件","uri":"https://jiyang.site/posts/2019-03-16-flutter-custom-paint/"},{"content":"Isolate Dart 中的线程概念是 Isolate, 一个在操作系统 Thread 只上的封装, 默认 Dart 程序会在一个 Isolate 中顺序执行代码.\n  Isolate 中的代码是按顺序执行 任何 Dart 程序的并发都是运行多个 Isolate 的结果 因为 Isolate 之间不会共享内存，没有竞争的可能性所以不需要锁，也就不用担心死锁的问题 Isolate 之间不能直接通信, 可以通过 DartVM 提供的 SendPort 通道通信  DartVM 运行模式  单线程执行: 一个 Isolate 拥有一个事件循环 一个事件循环和两个队列            事件循环只由单个线程执行 =\u0026gt; 没有同步和锁的问题microtask queue 优先级高于 event queue队列里的方法被执行时会阻塞整个程序创建一个 Future 就是向 event queue 提交一个事件 通过 Future.microtask 或scheduleMicrotask 向 microtask queue 提交一个事件    Question 1 2 3 4 5 6 7 8 9 10 11 12 13 14  import \u0026#39;dart:async\u0026#39;; void main() { print(\u0026#39;#1\u0026#39;); scheduleMicrotask(() =\u0026gt; print(\u0026#39;#2\u0026#39;)); Future.delayed(Duration(seconds: 1), () =\u0026gt; print(\u0026#39;#3\u0026#39;)); // 延迟1秒再回调  Future(() =\u0026gt; print(\u0026#39;#4\u0026#39;)); Future(() =\u0026gt; print(\u0026#39;#5\u0026#39;)); scheduleMicrotask(() =\u0026gt; print(\u0026#39;#6\u0026#39;)); print(\u0026#39;#7\u0026#39;); }   结果是? (运行试试吧)\n","description":"","id":57,"section":"posts","tags":null,"title":"Dart中的异步编程","uri":"https://jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"content":"Mixin 实例 1  现在我们有类似上图的继承关系, 有 3 种能力(walk, swim, fly), 能够组合到不同的动物上. 如果我们想让 Cat 和 Duck 都拥有 walk 能力, 怎么做 ?\n 经典方法: 抽象一个 Walk 接口, 然后都去实现这个接口 使用mixin: 创建一个 walk mixin 类, Cat 和 Duck 都直接复用 Walk 的代码  1 2 3 4 5 6 7 8  mixin Walker { walk() =\u0026gt; print(\u0026#34;walk\u0026#34;); } // 或者: 没有构造函数的类也支持 mixin class Walker { walk() =\u0026gt; print(\u0026#34;walk\u0026#34;); }    使用接口实现  1 2 3 4 5 6 7  class Duck extends Mammal implements Walker { @override walk() { // 需要自己再实现  } }   使用 mixin  1 2 3 4 5  class Duck extends Mammal with Flyer, Walker {} // 使用时, 直接就能复用 Walker 的代码 final duck = Duck(); duck.walk();   不同点  使用 mixin 可以向类A 添加 类B 的代码, 且 A 不用继承自 B, 也不用单独实现 B 的方法 和extends不同: 继承只能继承一个类, 而 mixin 可以复用多个类 和implements不同: 实现需要单独实现接口的功能, 而 mixin 可以直接使用 mixin 多个类时, 如果存在相同的方法和属性, 会使用最后 with 的类的方法和属性  Minxin: 实例 2  不修改源代码的情况下, 为方法添加日志\n 1 2 3  abstract class Mammal extends Animal { eat() =\u0026gt; print(\u0026#34;eat\u0026#34;); }   1 2 3 4 5 6 7 8 9 10  // 定义一个 mixin, 声明作用于 Mammal 上 mixin EatLog on Mammal { @override eat() { // 在原方法前后添加日志  print(\u0026#34;start eat\u0026#34;); super.eat(); print(\u0026#34;end eat\u0026#34;); } }   1 2 3 4 5 6 7 8 9  class Cat extends Mammal with Walker, EatLog {} main() { final cat = Cat(); cat.eat(); // start eat  // eat  // end eat }   使用 Mixin 实现这个功能就很合适了, 不用修改原来的方法实现, 就能实现类似在原来的代码前后插入代码一样效果.\n","description":"","id":58,"section":"posts","tags":null,"title":"Dart中的Mixin","uri":"https://jiyang.site/posts/2019-03-15-dart%E4%B8%AD%E7%9A%84mixin/"},{"content":"特别点  任何能作为变量使用的都是对象, 每一个对象都是一个类的实例. 甚至 数组, 函数, null 都是对象,所有对象都继承自 Object class. Dart 是强类型的语言,但是也支持类型推导, 比如 final a = 1 会推导出 a 是 int. 还可以使用 dynamic表示类型在运行时才确定 Dart 支持泛型,例如 List\u0026lt;int\u0026gt;(一个 int 集合), List\u0026lt;dynamic\u0026gt;(任何类型的对象的集合). Dart 支持 top-level函数, 类实例函数, 类静态函数, 嵌套函数, 局部函数. Dart 支持 top-level变量, 类实例变量, 类静态变量. Dart 只有 library 私有 和 library 公有 两种可见性, 以 _ 开头的标识符就代表 library 私有. 比如int _privateNum = 0; Dart 支持条件表达式, condition ? expr1 : expr2.  特别的关键字  以下是和 Java 比较起来, Dart 中一些特别用途的关键字.\n   dynamic\n 声明一个类型是任意类型的, 表示变量类型在运行时才确定    library 相关   show\n  当只导入一个 library 的一部分时使用\n  1 2  // Import only foo. import \u0026#39;package:lib1/lib1.dart\u0026#39; show foo;       hide\n  当导入一个 library 中所有内容, 但排除某个时使用\n  1 2  // Import all names EXCEPT foo. import \u0026#39;package:lib2/lib2.dart\u0026#39; hide foo;       as\n  给导入的 library 指定别名\n  1 2 3 4  import \u0026#39;package:lib2/lib2.dart\u0026#39; as lib2; // Uses Element from lib2. lib2.Element element2 = lib2.Element();       deferred\n  延期导入 library. 当需要使用时再导入, 使用场景:\n 减少应用的启动时间 A/B Test 加载很少会用的的方法      1 2 3 4 5 6 7 8  // 必须使用 deferred as import \u0026#39;package:greetings/hello.dart\u0026#39; deferred as hello; // 执行 loadLibrary 真正导入 Future greet() async { await hello.loadLibrary(); hello.printGreeting(); }     loadLibrary 即使多次调用, library 也只会导入一次\n  注意\n 延期导入的 library 中的常量, 直到 library 被真正导入后才可用 不能使用延期导入的 library 中的类型, 比如 class 等. 最好将包含类型声明的 library 移到一个 libraryA , 然后让 延期导入的 library 和导包的文件都导入这个 libraryA. loadLibrary 函数返回的是一个 Future, 需要注意异步使用.    export\n 在一个 dart 文件中批量 export 多个 library, 这样就只用 import 这一个文件  1 2 3 4 5 6 7 8 9 10 11 12 13  // 在 shelf.dart 中声明如下: export \u0026#39;src/cascade.dart\u0026#39;; export \u0026#39;src/handler.dart\u0026#39;; export \u0026#39;src/handlers/logger.dart\u0026#39;; export \u0026#39;src/hijack_exception.dart\u0026#39;; export \u0026#39;src/middleware.dart\u0026#39;; export \u0026#39;src/pipeline.dart\u0026#39;; export \u0026#39;src/request.dart\u0026#39;; export \u0026#39;src/response.dart\u0026#39;; export \u0026#39;src/server.dart\u0026#39;; export \u0026#39;src/server_handler.dart\u0026#39;; // 最后只用 import shelf.dart 一个包, 就能导入上面所有包     part (不推荐使用)\n 拆分一个 library 到多个文件    异步编程支持   async\n 结合 await 使用    await\n 在使用 async 标记了的方法中, 等待一个 Future 执行完毕  1 2 3 4 5 6  Future\u0026lt;String\u0026gt; lookUpVersion() =\u0026gt; Future.delayed(Duration(seconds: 2), () =\u0026gt; \u0026#34;1.0\u0026#34;); void checkVersion() async { var version = await lookUpVersion(); print(version); // 1.0 }     Generators 中使用  sync yield  函数相关  external  声明一个函数的具体实现在其他地方, 目前仅用于 DartVM 在不同平台实现同一个函数.  1 2 3 4 5 6 7 8 9  // 声明 class Foo { external int bar(int x); } // dart2js 中实现 @patch class Foo { @patch int bar(int x) =\u0026gt; somethingMagical(x); }    typedef  定义一个函数类型. 当一个函数分配给一个变量时, typedef 能够保留函数的类型信息  1 2 3 4 5 6 7 8 9 10 11 12 13 14  typedef Compare = int Function(Object a, Object b); int sort(Object a, Object b) =\u0026gt; 0; class SortedCollection { Compare compare; SortedCollection(this.compare); } void main() { SortedCollection coll = SortedCollection(sort); assert(coll.compare is Function); // True  assert(coll.compare is Compare); // True }    Function  声明一个变量是函数类型    类相关   factory\n 声明一个构造函数并不总是创建一个新的实例, 也可能返回一个缓存对象, 一个子类对象 factory 构造函数不能访问 this  1 2 3 4 5 6 7 8 9  factory Logger(String name) { if (_cache.containsKey(name)) { return _cache[name]; } else { final logger = Logger._internal(name); _cache[name] = logger; return logger; } }     mixin\n 减少继承造成的复杂结构和多重继承下的问题\n  在多个类中复用一个类的代码, 而不用继承类(类似: 继承人们的资产, 且不用是他们的孩子) 当 继承 或 mixin 的类中有相同的方法时, 优先使用最后 with 的类中的方法  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Teacher { void teaching() =\u0026gt; print(\u0026#34;Something\u0026#34;); } mixin MathTeacher { void teaching() =\u0026gt; print(\u0026#34;Math\u0026#34;); } mixin EnglishTeacher { void teaching() =\u0026gt; print(\u0026#34;English\u0026#34;); } class SeniorSchoolTeacher with MathTeacher, EnglishTeacher {} void main() { SeniorSchoolTeacher teacher = SeniorSchoolTeacher(); teacher.teaching(); // English }     with\n 声明使用 mixin 的类    convariant\n 允许用子类覆盖重写参数的类型  1 2 3 4 5 6 7 8 9 10  class Animal { void chase(Animal x) { ... } } class Mouse extends Animal { ... } class Cat extends Animal { // 正常情况下,是不允许覆盖参数类型的,会报 Invalid override. 使用 covariant 表明我们知道自己在做什么, 将忽略报错  void chase(covariant Mouse x) { ... } }     get set\n 为一个类添加额外的 getter setter 属性  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Rectangle { int left, top, width, height; int get right =\u0026gt; left + width; set right(int value) =\u0026gt; left = value - width; int get bottom =\u0026gt; top + height; set bottom(int value) =\u0026gt; top = value - height; } void main(){ final rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 0; assert(rect.left == -20); }     异常  rethrow  catch 一个异常之后,再次抛出  1 2 3 4 5 6 7 8 9  void misbehave() { try { dynamic foo = true; print(foo++); // Runtime error  } catch (e) { print(\u0026#39;misbehave() partially handled ${e.runtimeType}.\u0026#39;); rethrow; // Allow callers to see the exception.  } }       其他  operator  操作符重载. 可以重载常见的操作符.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Point { int x, y; Point(this.x, this.y); Point operator +(Point p) =\u0026gt; Point(x + p.x, y + p.y); Point operator -(Point p) =\u0026gt; Point(x - p.x, y - p.y); } void main() { final p1 = Point(1, 2); final p2 = Point(2, 1); assert((p1 + p2).x == 3); assert((p1 - p2).x == -1); assert((p2 - p1).x == 1); }     变量  Dart 中的变量也是存储的对象的引用, 当在函数中传递时,与 Java 类似是 值传递. 没有初始化的变量默认为 null, 没有初始化的数字类型也是 null. final 声明不可变的变量. 类中的 final 属性, 必须在构造函数的 body 执行前被赋值. const 声明编译期常量. static 声明类变量和类方法, Dart 中的类变量和类方法不能通过类的实例调用  Built-in Type   numbers\n int 不超过 64 位的整数, 在 DartVM 是 -2^63 to 2^63 - 1, 在编译为 JS 后是 -2^53 to 2^53 - 1 double 64 位的双精度浮点    strings\n 对应类 String 和 Java 类似, 也是不可变的 UTF-16 编码 使用单引号或双引号创建, 使用三个单引号可以写到多行 使用 $ 将变量嵌入字符串 使用 r'' 创建原始字符串 == 操作符, 比较两个字符串的内容是否相等 const 声明的字符串字面量是编译期常量    booleans\n 关键字 bool    lists (also known as arrays)\n 对应类 List, 类似 Java 中的 ArrayList 快速创建 var l = [1, 2, 3, 4, 5]; 常量list var constantList = const [1, 2, 3]; 常量 list 不能再 add 或 修改内部元素    sets\n 对应类 Set 快速创建 var s = {\u0026quot;dog\u0026quot;, \u0026quot;pic\u0026quot;, \u0026quot;fish\u0026quot;};    maps\n 对应类 Map 快速创建  1 2 3 4 5 6  var gifts = { // Key: Value  \u0026#39;first\u0026#39;: \u0026#39;partridge\u0026#39;, \u0026#39;second\u0026#39;: \u0026#39;turtledoves\u0026#39;, \u0026#39;fifth\u0026#39;: \u0026#39;golden rings\u0026#39; };     runes (for expressing Unicode characters in a string)\n 对应类 Runes UTF-32 编码的字符串 超过4个数的 uniCode 需要包裹在 {} 里  1 2 3 4 5 6 7 8 9  main() { var clapping = \u0026#39;\\u{1f44f}\u0026#39;; print(clapping); // 👏  print(clapping.codeUnits); print(clapping.runes.toList()); Runes input = new Runes(\u0026#39;\\u2665\\u{1f605}\\u{1f60e}\\u{1f47b}\\u{1f596}\\u{1f44d}\u0026#39;); print(new String.fromCharCodes(input)); }     symbols\n Dart中的 symbol 是不透明的动态字符串名称，用于反映库中的元数据。 简而言之，symbol 是一种存储人类可读字符串与优化供计算机使用的字符串之间关系的方法。Reflection 是一种在运行时获取类型元数据的机制，如类中的方法数，它具有的构造函数数或函数中的参数数。 您甚至可以调用在运行时加载的类型的方法。在 Dart 反射中，dart:mirrors 包中提供了特定的类。 此库适用于 Web 应用程序和命令行应用程序。\n  对应类 Symbol 感觉主要用在 Dart 的反射上  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // foo.dart library foo_lib; class Foo { m1() =\u0026gt; print(\u0026#34;Inside m1\u0026#34;); m2() =\u0026gt; print(\u0026#34;Inside m3\u0026#34;); } // main.dart import \u0026#39;dart:mirrors\u0026#39;; import \u0026#39;foo.dart\u0026#39;; main() { final libName = Symbol(\u0026#34;foo_lib\u0026#34;); final className = Symbol(\u0026#34;Foo\u0026#34;); MirrorSystem mirror = currentMirrorSystem(); LibraryMirror libraryMirror = mirror.findLibrary(libName); if (libraryMirror.declarations.containsKey(className)) { ClassMirror classMirror = libraryMirror.declarations[className]; classMirror.instanceMembers .forEach((symbol, methodMirror) =\u0026gt; print(symbol)); } }     Functions  在 Dart 里, 函数也是对象, 对应类为 Function. 简短写法 bool isOdd(int number) =\u0026gt; number%2 != 0; 在函数的参数声明里可简写为: T f(T e)  1 2 3 4 5 6 7 8 9 10 11 12  // 模拟一个 map 方法 List\u0026lt;T\u0026gt; map\u0026lt;T, E\u0026gt;(Iterable\u0026lt;E\u0026gt; list, T f(E e)) { final result = List\u0026lt;T\u0026gt;(); list.forEach((item) =\u0026gt; {result.add(f(item))}); return result; } main() { final ints = const [1, 2, 3, 4]; final ints2 = map(ints, (i) =\u0026gt; i * i); print(ints2); // 1, 4, 9, 16 }   参数  支持两种类型参数, 必传参数和可选参数, 第一个参数为必传,第二个可以为可选参数 可选命名参数  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // a 必传. b,c 可选 void f(int a, {int b, int c}) {} f(1, b: 2); f(1, c: 3); f(1, b: 2, c: 3); // a,b 都可选 void f({int a, int b}) {} f(); f(a: 1); f(b: 2); f(a: 1, b: 2); // b 默认值为 100 void f(int a, {int b = 100}) f(1); f(1, b: 2);    可选位置参数  1 2 3 4 5 6 7 8 9 10  // c 可选 void f(int a, int b, [int c]){} f(1, 2); f(1, 2, 3); // c,d 为可选, d 默认值为 100 void f(int a, int b, [int c, int d = 100]){} f(1, 2); f(1, 2, 3); f(1, 2, 3, 4);   main 函数  程序的入口 参数 List\u0026lt;String\u0026gt; 可选  函数作为参数 1 2 3 4 5 6 7 8  void printElement(int element) { print(element); } var list = [1, 2, 3]; // printElement 作为参数. list.forEach(printElement);   变量存储函数引用\n1 2  var loudify = (msg) =\u0026gt; \u0026#39;!!! ${msg.toUpperCase()}!!!\u0026#39;; assert(loudify(\u0026#39;hello\u0026#39;) == \u0026#39;!!! HELLO !!!\u0026#39;);   匿名函数 1 2 3  ([[Type] param1[, …]]) { codeBlock; };   1 2 3 4  var list = [\u0026#39;apples\u0026#39;, \u0026#39;bananas\u0026#39;, \u0026#39;oranges\u0026#39;]; list.forEach((item) { print(\u0026#39;${list.indexOf(item)}: $item\u0026#39;); });   如果函数只包含一行,可以使用剪头符号:\n1  list.forEach((item) =\u0026gt; print(\u0026#39;${list.indexOf(item)}: $item\u0026#39;));   Operators   乘除运算符\n ~/ 取模: 201 ~/ 100 == 2 / 商: double 结果 1 / 100 == 0.01, 100 / 1 == 100.0 % 取余: 3 % 5 == 3    类型测试符\n as 类型转换 is 如果对象拥有指明的类型, true is! 如果对象拥有指明的类型, false  1 2 3  1 is int //true 1 is! int //false 1 is! String //true     赋值运算符\n ??= 如果被赋值的变量是 null, 则将右值赋给它; 否则不进行赋值  1 2 3 4 5  int d = null; d ??= 1; print(d); // 1 d ??= 2; print(d); // 1     条件表达式\n 三目运算: condition ? expr1 : expr2 条件赋值: expr1 ?? expr2, 如果 expr1 不为 null, 就返回 expr1 的值; 否则返回 expr2 的值  1 2 3  print(null ?? 100); // 100 print(null ?? null); // null print(100 ?? null); // 100     null 安全访问符: ?.\n  1 2 3 4 5 6  int a = null; print(a.abs()); // NoSuchMethodError: The method \u0026#39;abs\u0026#39; was called on null.  print(a?.abs()); // null a = -100; print(a?.abs()); // 100    链式调用符: .. 链式调用对象的多个方法或属性, 最终会返回对象本身  1 2 3 4 5 6 7 8 9 10 11 12 13  class Book { String name; double price; String getSequence() =\u0026gt; \u0026#34;$name-$price\u0026#34;; } final book = Book() ..name = \u0026#34;Dartlang\u0026#34; ..price = 100.0 ..getSequence(); print(book); //Instance of \u0026#39;Book\u0026#39;   Class 构造函数 1 2 3 4  class Book { String name; double price; }    默认构造函数, 没有任何参数 带参数构造函数  1 2 3 4 5 6  Book(this.name, this.price); // 等价于 Book(String name, double price) { this.name = name; this.price = price; }    命名构造函数  1 2 3 4  Book.fromJson(Map\u0026lt;String, dynamic\u0026gt; json) { this.name = json[\u0026#39;name\u0026#39;]; this.price = json[\u0026#39;price\u0026#39;]; }    初始化列表  1 2 3  Book.fromJson(Map\u0026lt;String, dynamic\u0026gt; json) : name = json[\u0026#39;name\u0026#39;], price = json[\u0026#39;price\u0026#39;]{}    重定向构造函数: 调用其他构造函数  1  Book.fromJson(Map\u0026lt;String, dynamic\u0026gt; json) :this(json[\u0026#39;name\u0026#39;], json[\u0026#39;price\u0026#39;]);    常量构造函数: 返回一个编译期常量对象, 这种情况下属性必须是final的, 构造函数必须是 const 的  1 2 3 4 5 6 7 8  class Book { final String name; final double price; const Book(this.name, this.price); static final Book origin = const Book(\u0026#34;dart\u0026#34;, 100.0); }    工厂构造函数: 可用于不一定返回新对象的情况, 比如:  从缓存返回 返回一个子类对象 单例模式    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // 单例模式例子 class SingleClass { static SingleClass _instance; SingleClass._inner(); factory SingleClass() { if (_instance == null) { _instance = SingleClass._inner(); } return _instance; } } // 调用 final a = SingleClass(); final b = SingleClass(); print(a == b); // true   方法 实例方法 与 Java 类似, 对象都会拥有实例方法\ngeter seter  会隐式的为类的属性提供 getter 和 setter 方法. 可通过 get set 关键字提供额外的 getter 和 setter(参照上面关键字部分)  抽象方法 abstract method 抽象方法只能存在抽象类中, 且子类(如果子类不是抽象类)必须实现抽象方法\n抽象类 与 Java 类似\n隐式接口 Dart 为每个类隐式定义了一个接口, 接口包含了类的所有属性和实例方法. 如果你想提供和一个类相同的能力, 而又不想继承它, 那可以直接使用 implements 实现它即可.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Person { // 会包含在隐式接口中, 因为 name 是 final, 所以只会隐式生成 getter, 则实现接口的类也应该提供一个 name 的 getter 方法  final String name; // 会包含在隐式接口中, 因为 age 不是 final, 所以会隐式生成 getter 和 setter, 则实现接口的类也应该提供 age 的 getter 和 setter 方法  int age; // 不会包含在隐式接口中  Person(this.name); // 会包含在隐式接口中  String greet(String who) =\u0026gt; \u0026#34;Hi $who, I\u0026#39;m $name\u0026#34;; } // 继承自 Person, 用于 Person 类的所有 class Man extends Person { Man(String name) : super(name); } // 实现了 Person 类的隐式接口, 需要实现包含在接口中的方法 class Women implements Person { String nickName; @override String get name =\u0026gt; nickName; @override String greet(String who) =\u0026gt; \u0026#34;Hi $who. Do you know who I am\u0026#34;; @override int get age =\u0026gt; 0; @override void set age(int _age) { this.age = _age; } }   使用 mixin 请移步 \u0026ldquo;Dart 中的Mixin\u0026rdquo;\n类变量和方法  使用 static 声明类变量, 与Java 不同, 类变量只能通过类调用, 不能通过实例调用 使用 static 声明类方法, 与Java 不同, 类方法只能通过类调用, 不能通过实例调用  泛型 基本使用与 Java 类似, 但有一个最大不同, Dart 的泛型在运行时不会被擦除, 在运行时可以知道泛型的类型.\nDart:\n1 2 3 4 5 6 7 8 9 10 11  class Wrap\u0026lt;T\u0026gt; { final T data; Wrap(this.data); } void main() { final data = Wrap\u0026lt;String\u0026gt;(\u0026#34;ABC\u0026#34;); print(data is Wrap\u0026lt;String\u0026gt;); // true  print(data.runtimeType); // Wrap\u0026lt;String\u0026gt; }   Java:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Wrap\u0026lt;T\u0026gt; { T data; public Wrap(T data) { this.data = data; } } public static void main(String[] args) { Wrap\u0026lt;String\u0026gt; data = new Wrap\u0026lt;\u0026gt;(\u0026#34;ABC\u0026#34;); System.out.println(data instanceof Wrap\u0026lt;String\u0026gt;); // 不支持的操作  System.out.println(data.getClass().getName()); // Wrap }   异步 创建异步方法 返回 Future 或 Stream 的方法就是异步方法, 不需要等待这些方法中进行的耗时操作就可以返回.\n1 2 3 4 5 6 7 8 9  void main() { print(\u0026#34;start\u0026#34;); asyncGetNum(); print(\u0026#34;end\u0026#34;); } Future\u0026lt;void\u0026gt; asyncGetNum() { return Future.delayed(Duration(seconds: 1), () =\u0026gt; print(\u0026#34;async\u0026#34;)); }   输出:\nstart end async 等待 Future 的结果  在 async 方法中使用 await 等待一个 Future 执行结束  1 2 3 4  void printNun() async { final num = await asyncGetNum(); print(num); }    使用 Future 的 then 接口  1 2 3 4  void printNun(){ final Future\u0026lt;int\u0026gt; numFuture = asyncGetNum(); numFuture.then((num) =\u0026gt; print(num)); }   捕获异常 抛出异常:\n1 2 3 4 5 6  Future\u0026lt;int\u0026gt; asyncGetNum() { return Future.delayed(Duration(seconds: 1), () { throw Exception(\u0026#34;exception\u0026#34;); return 100; }); }    使用 try catch 捕获  1 2 3 4 5 6  try { final num = await asyncGetNum(); print(num); } catch (e) { print(e); }    使用 Future 的 catchError 捕获  1 2  final Future\u0026lt;int\u0026gt; numFuture = asyncGetNum(); numFuture.then((num) =\u0026gt; print(num)).catchError((error) =\u0026gt; print(error));   等待 Stream 的结果 使用 Stream:\n1 2 3  Stream\u0026lt;int\u0026gt; streamNum() { return Stream.fromIterable([1, 2, 3, 4, 5]); }    在 async 方法中使用 await for 等待一个循环  1 2 3 4 5  void printNun() async { await for (int i in streamNum()) { print(i); } }    使用 Stream 的 listen 接口  1 2 3  void printNun() { streamNum().listen((i) =\u0026gt; print(i)); }   Generators 生成器 当需要延迟产生序列值时(不会在内存储存整个序列, 只有当需要下一个值时才计算一下个值), 可以使用 generator 方法, Dart 支持两种 generator 方法:\n 同步的生成器: 返回 Iterable 对象 异步的生成器: 返回 Stream 对象  实现同步生成器:\n 方法返回 Interable 方法使用 sync* 标记 使用 yield 抛出值  1 2 3 4 5 6 7  Iterable\u0026lt;int\u0026gt; naturalsTo(int n) sync* { int k = 0; while (k \u0026lt; n) { print(\u0026#34;produce\u0026#34;); yield k++; } }   实现异步生成器:\n 方法返回 Stream 方法使用 async* 标记 使用 yield 抛出值  1 2 3 4 5 6 7  Stream\u0026lt;int\u0026gt; asyncNaturalsTo(int n) async* { int k = 0; while (k \u0026lt; n) { print(\u0026#34;async produce\u0026#34;); yield k++; } }   如果逻辑是递归的, 可以使用 yield* 优化性能:\n1 2 3 4 5 6  Iterable\u0026lt;int\u0026gt; naturalsDownFrom(int n) sync* { if (n \u0026gt; 0) { yield n; yield* naturalsDownFrom(n - 1); } }   Callable class 为一个类实现 call 方法, 该类就能像一个方法一样被调用.\n1 2 3 4 5 6  class Dog { void call() =\u0026gt; print(\u0026#34;wang wang\u0026#34;); } final dog = Dog(); dog(); // wang wang   Isolates 在 Dart 中, 程序运行在自己的 Isolate 中, 类似 Java 里的 Thread, 但是 Isolate 彼此独立, 内存不能互相访问, 每个 Isolate 有自己的内存堆.\n请移步 \u0026ldquo;Dart 中的异步\u0026rdquo;\nTypedefs 类型定义 为方法定义一个类型, 当方法被一个变量引用时, 这个类型信息也会能被使用. 比如:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class SortedCollection { Function compare; SortedCollection(int f(Object a, Object b)) { compare = f; } } int sort(Object a, Object b) =\u0026gt; 0; void main() { SortedCollection coll = SortedCollection(sort); // 只能知道 compare 是一个方法, 但是不能知道它具体是什么方法  assert(coll.compare is Function); }   使用 typedef:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  typedef Compare = int Function(Object a, Object b); class SortedCollection { Compare compare; SortedCollection(this.compare); } int sort(Object a, Object b) =\u0026gt; 0; void main() { SortedCollection coll = SortedCollection(sort); // 可以知道 compare 是一个方法, 也能知道它具体是什么类型的方法  assert(coll.compare is Function); assert(coll.compare is Compare); }   原数据 Metadata 类似 Java 中的注解. 可以在运行时通过反射拿到 Metadata.\n定义自己的注解:\n1 2 3 4 5 6 7 8  library todo; class Todo { final String who; final String what; const Todo(this.who, this.what); }   1 2  @Todo(\u0026#34;me\u0026#34;, \u0026#34;fix something\u0026#34;) void doSomething() {}   ","description":"Dart 语言基础和一些特点(相比 Java)","id":59,"section":"posts","tags":null,"title":"Dartlang","uri":"https://jiyang.site/posts/2019-03-01-dartlang/"},{"content":"六大原则简单描述  单一职责原则：一个类中应该是相关性很强的一类函数。 开闭原则：对扩展开放，对修改封闭。实现扩展的方法是使用抽象和依赖注入。将可扩展的功能抽象，然后通过外部注入具体实现。 里氏替换原则：所有父类都能被子类替换，并且不影响程序的正确运行。核心是建立抽象，结合开闭原则，对扩展开放，对修改关闭。 依赖倒置原则：面向抽象编程。高层模块是调用方，底层模块是实现方。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。核心要点：  高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节：接口或抽象类，不用在意具体的实现 细节应该依赖抽象：由实现类去具体实现抽象   接口隔离原则：客户端依赖的接口应尽可能的小。比如：实现一个工具类来关闭所有支持 Closeable 的对象，该工具类就应该只依赖 Closeable 这个抽象的接口，而不是 OutputStream 等具体的实现或与 Stream 相关的其他接口 迪米特原则：一个对象应该对其他对象有最少的了解，只与直接的朋友通信。尽量保持类的依赖关系是一条没有交叉，没有环的线。  模拟一个图片加载的库 ImageLoader ,做应用示例. 下面是类图:\n@startuml interface ImageCache{ + Bitmap get(String url) + void put(String url, Bitmap b) } interface Loader{ + Bitmap load(String url) } ImageCache \u0026lt;|-- MemoryCache ImageCache \u0026lt;|-- DiskCache Loader \u0026lt;|-- SyncLoader Loader \u0026lt;|-- AsyncLoader class ImageLoader{ - ImageCache imageCache - Loader loader + void display(String url, ImageView iv) + void setImageCache(ImageCache cache) + void setLoader(Loader loader) } ImageLoader --o ImageCache ImageLoader --o Loader @enduml 单一职责原则  一个类中应该是相关性很强的一类函数.\n 比如 ImageLoader 提供了图片加载和缓存的功能,但是我们不能将加载和缓存的功能全写到 ImageLoader 类里, 于是提出两个功能类 ImageCache 和 Loader 分别负责缓存和加载功能.\n开闭原则  对扩展开放，对修改封闭。实现扩展的方法是使用抽象和依赖注入。将可扩展的功能抽象，然后通过外部注入具体实现.\n 负责缓存的 ImageCache 和加载的 Loader, 都是可以扩展的功能, 应该让他们开放. ImageLoader 本身的业务一般都不会改变, 应该让它封闭.\n所以将缓存和加载功能抽象出来, 形成两个接口, 然后在外边注入具体的实现. 要扩展他们的功能, 就实现他们的抽象接口即可, 然后注入到 ImageLoader 中. 比如缓存可以分内存缓存 MemoryCache 和硬盘缓存 DiskCache.\n@startuml interface ImageCache{ + Bitmap get(String url) + void put(String url, Bitmap b) } interface Loader{ + Bitmap load(String url) } ImageCache \u0026lt;|-- MemoryCache ImageCache \u0026lt;|-- DiskCache Loader \u0026lt;|-- SyncLoader Loader \u0026lt;|-- AsyncLoader @enduml 里氏替换原则  所有父类都能被子类替换，并且不影响程序的正确运行。核心是建立抽象，结合开闭原则，对扩展开放，对修改关闭.\n @startuml interface ImageCache{ + Bitmap get(String url) + void put(String url, Bitmap b) } ImageCache \u0026lt;|-- MemoryCache ImageCache \u0026lt;|-- DiskCache class ImageLoader{ - ImageCache imageCache + void setImageCache(ImageCache cache) + void setLoader(Loader loader) } ImageLoader -o ImageCache @enduml MemoryCache DiskCache 都能替换 ImageCache 的工作, 并且能够保证行为的正确性, ImageCache 建立了获取缓存图片, 储存缓存图片的接口规范, MemoryCache 等根据规范实现了相应的功能, 用户只需在使用时指定具体的缓存对象, 就可以动态替换 ImageLoader 中的缓存策略.\n比如 Android SDK 里的 Window 和 View 也是这个原则, Window 中的 setContentView的参数 view 可以被任何一个实现了 View 接口的对象替换.\n@startuml abstract class Window { + void setContentView(View view) } abstract class View { + {abstract} void draw() + {abstract} void measure(int int) } Window - View class Button { + void draw() + void measure(int int) } class TextView { + void draw() + void measure(int int) } View \u0026lt;|-- Button View \u0026lt;|-- TextView @enduml 依赖倒置原则  高层模块是调用方，底层模块是实现方。高层模块不依赖底层模块的实现细节, 依赖模块被颠倒. 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的.\n  高层模块不应该依赖底层模块，两者都应该依赖其抽象 抽象不应该依赖细节：接口或抽象类，不用在意具体的实现 细节应该依赖抽象：由实现类去具体实现抽象  例子中的高层模块就是 ImageLoader, 底层模块就是 ImageCache 和 Loader, ImageLoader 依赖的都是 ImageCache 和 Loader 的抽象, 并没有直接依赖某个具体实现.\n如果 ImageLoader 直接依赖了 ImageCache 的某一个具体实现(比如 MemoryCache), 当 MemoryCache 不能满足 ImageLoader 而需要被其他缓存实现替换时, 就必须修改 ImageLoader 的代码. 反之, 如果 ImageLoader 依赖的是 ImageCache 抽象, 要替换其他缓存实现时, 只需要外部注入其他实现即可, 不需要修改 ImageLoader的代码.\n接口隔离原则  依赖的抽象接口应尽可能的小。比如：实现一个工具类来关闭所有支持 Closeable 的对象，该工具类就应该只依赖 Closeable 这个抽象的接口，而不是 FileOutputStream 等具体的实现.\n @startuml class CloseUtil{ + void closeQuietly(Closeable closeable) } interface Closeable{ + void close() } abstract class OutputStream class FileOutputStream CloseUtil -- Closeable OutputStream -|\u0026gt; Closeable FileOutputStream -|\u0026gt; OutputStream @enduml 迪米特原则  一个对象应该对其他对象有最少的了解，只与直接的朋友通信。尽量保持类的依赖关系是一条没有交叉，没有环的线.\n ","description":"面向对象的六大原则是运用设计模式的基础。只有基于六大原则进行开发，才能在需要的时候方便的应用各种设计模式。","id":60,"section":"posts","tags":null,"title":"面向对象六大原则","uri":"https://jiyang.site/posts/2019-02-21-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"},{"content":" 来自: https://techbeacon.com/how-become-better-android-developer-30-bite-sized-pro-tips\n 成为一名 Android 开发人员很容易，但成为一名成功的Android开发人员并从中脱颖而出并非如此。要想在这份工作中取得成就，需要付出很多努力，热情，奉献精神和坚持不懈的精神。\n 我无法向您展示任何捷径，但如果您愿意付出努力，您一定会获得您应得的所有成功。\n为了帮助您成为更好的Android开发人员，我根据自己的经验编写了一些专业提示。因此，无论您是刚刚决定加入Android开发还是已经在Android开发人员工作了一段时间，这些技巧都将与您相关。\n  更熟悉Android框架内部\n我不是在谈论文档而是实际的框架代码。我见过许多开发人员，他们害怕潜入Android框架内部。不要成为其中之一。当你看到事物的实际运作方式以及不同的部分如何恰当地融合在一起时，你能发现多少令人惊奇。\n如果您需要启动 Android 游戏，请不要回避 Android SDK 的内部工作，并开始与之建立友好关系。\n  克服你对失踪的恐惧（FOMO: Fear Of Missing Out）\nAndroid 很大，很大。你不能在一个月或三个月内完全学习它。你学的越多，你就越能理解你不知道多少。作为一个初学者，通过尝试在仍处于极度无知状态的情况下尝试构建重要信息而错过学习关键信息是完全正常的，但试图克服它。\n了解您开始使用当前正在使用的应用程序所需的内容，然后慢慢拓展视野。\n  开始阅读更多代码\n大多数开发人员不花时间阅读其他开发人员正在编写的内容。他们大部分时间都在写他们已经知道的东西。\n但这不会帮助您成长为完整的 Android 开发人员。真正成为更好的开发人员的唯一方法是阅读更有经验的开发人员的优秀代码。您应该开始查看其他开源应用程序和库，在那里您将发现许多您以前不知道的编码技术和功能实现。\n  考虑学习更多语言\n显然，我并没有告诉你学习西班牙语或中文。我说你应该学习新的编程语言。您需要随时了解行业中发生的事情，而不是将您的思维局限于Android领域。\n这将打开您的视角，激发新想法，并帮助您显着提高您的Android开发技能。决定每年学习一种新的编程语言。\n提示：如果您还不知道，JavaScript是一个很好的起点。\n  是时候学习Java设计模式了\n我不能强调这对你的 Android 开发职业生涯有多重要。无论何时你都试图解决一个关键的编程问题，设计模式可以成为救星。\n您还需要与其他开发人员在同一页面上，这样当他们谈论使用 Factory，Decorator 或 Facade 模式时，您立即就会知道它们的含义。\n每周都要向自己承诺学习一种新的设计模式，直到你了解它们中的大多数。\n   https://github.com/iluwatar/java-design-patterns\n  开始为开源做贡献\n如果您已经开发了库，插件或其他有用的代码，并且您在自己的应用程序中使用它，请考虑开源。在为开源项目做贡献或维护自己的项目过程中需要学习很多东西。这是开源开发中一个优秀的速成课程，它将以指数方式提高您作为开发人员的价值。\n如果您没有任何开源资源，请考虑查看您感兴趣的其他开源项目，并修复一些错误，改进文档或在那里编写一些测试。\n即使是最小的贡献（例如修复文档中的一些语法错误）也会有助于项目维护者保持项目的运行。\n  让IDE为您服务\n开始花更多时间了解您正在使用的IDE：Android Studio。它可以做的比你想象的要多得多。 IDE中隐藏了许多很酷的功能和快捷方式，大多数开发人员甚至都没有尝试发现这些功能和快捷方式。\n养成习惯，找到让您的工具更有效的新方法，从而改善您的工作流程和工作效率。\n提示：这是一篇很棒的文章，可以帮助您掌握Android Studio。\n   https://www.intellectsoft.net/blog/use-android-studio-like-a-pro/\n 是时候正确构建您的应用程序了\n大多数情况下，我们最终将所有代码都倾倒在 Activity 或 Fragment 中，将它们变成了巨大的上帝对象，这些对象几乎无法维护和测试。\n为您的应用程序采用良好的体系结构非常重要，例如 MVP 或 MVVM。将应用的业务逻辑，视图交互和数据交互分成不同的层，以便于管理和测试。\n提示：查看Google提供的这些有用蓝图，以便通过Android应用程序架构设计让您的生活更轻松。   https://github.com/googlesamples/android-architecture\n 了解Android的清晰编码指南\n您也不能忽视这一点，因为在与不编写干净代码的开发人员合作时，很难维护Android开发的标准编码指南。   https://github.com/ribot/android-guidelines/blob/master/project_and_code_guidelines.md\n 花一些时间学习Android最佳实践\n为了让自己比其他开发人员更具优势，并构建看起来很好且运行良好的应用程序，您需要开始学习 Android 开发的一些最佳实践。\n了解有助于您成为更好的开发人员的做法和注意事项，并帮助您的应用程序脱颖而出。   https://github.com/futurice/android-best-practices\n 通过收听播客有效利用您的空闲时间\n尽量有效地利用你的时间。当你上下班，在健身房锻炼，开车或做饭时，你的天才大脑并没有做太多。\n通过收听一些Android播客，您可以在这种时候进行多任务处理。   https://fragmentedpodcast.com/\nhttp://androidbackstage.blogspot.com/\n  不要过度设计事物。现实点。\n我已经看到这不仅发生在我身上，也发生在一些开发人员身上。在开始研究它之前考虑一些事情是好的（非常好，实际上），但过度思考和过度分析导致不必要的混乱，延迟和焦虑。\n做一下现在对项目有益的事情，你可以随时根据需要适应不断变化的情况。\n  尝试学习设计\n我可以理解，作为开发人员，您主要关注的是学习编写更好的代码。但是，如果您想成为一名完整的开发人员，您应该开始花时间学习和理解用户界面（UI）和用户体验（UX）设计。\n这将改变您查看已编码的应用程序的方式。尝试与团队中的UI和UX设计人员进行更多交流和互动，以更好地了解应用程序设计。\n   http://www.nixdell.com/classes/HCI-and-Design-Spring-2017/The-Design-of-Everyday-Things-Revised-and-Expanded-Edition.pdf\n  开始成为一个完美主义者\n“完美”是一个主观术语，但根据经验，尝试始终实现您需要提供的最佳产品版本。\n永远不要满足于此。不要为了它而做某事。对你正在做的工作充满热情，并且比最好的工作做得更好。从长远来看，这将帮助您不断成长并成为更成功的开发人员。\n  一致性是成功的关键\n如果您想成为开发人员（或生活中的任何其他人），您需要保持一致。\n做几天或几周然后戒烟不会带你到任何地方。不要变幻无常。尝试在未来几年内可视化您希望成为 Android 开发人员的位置，并坚持您的目标，无论遇到什么样的挑战。\n很容易开始做一些事情，但很长时间以同样的热情和奉献精神继续做这件事很难。\n  从小处开始。慢慢扩张。\n作为开发人员，您应该始终尝试将您正在处理的任何复杂问题或功能分解为可以轻松快速地理解和解决的小型，简单且独立的组件。\n不要对项目的初始大小或复杂性感到不知所措。一旦你走在正确的轨道上，一切都可以解决。从小处开始，采取婴儿步骤，然后缓慢扩展。\n  总是手头有一个游乐场项目\n正在进行游乐场项目可以彻底改变您学习的方式。如果您在某个地方遇到 Android 新功能，请养成在您的游乐场项目中立即尝试的习惯。\n假设您在某个地方遇到了一个有趣的 Android 库。您应该在游乐场项目中测试它，而不是仅仅浏览文档和API。这将使您更好，更深入地了解库。\n   https://github.com/stefanJi/android-playground\n  开始编写更多测试\n我不能强调这是多么重要。在为其编写详尽的测试用例之前，您不能认为某个功能是完整的。测试将帮助您在代码中建立信心。\n不要忽视测试或将其视为可选的错误，并在以后的回归错误中让您的生活更加痛苦。\n  考虑采用TDD\n在开发应用程序时，请考虑选择以强大而有效的方式构建应用程序，以便它能够经受住时间的考验。\n考虑遵循测试驱动开发（TDD）的“红 - 绿 - 重构”循环。首先，编写将失败的测试用例（红色），然后编写实际代码以使测试通过（绿色），最后，清理并优化它（重构）。\n“测试驱动开发是一种在编程过程中管理恐惧的方法。恐惧让你试探性。恐惧让你想减少沟通。恐惧让你回避反馈。恐惧让你脾气暴躁。 “ - TDD示例\n   http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html\n 建立适当的自动发布机制(持续集成 CI)\n作为开发人员，尽量花费尽可能少的时间来处理应该自动化的事情，例如应用质量检查和发布。\n您应该使用CheckStyle，PMD，Lint和FindBugs等工具自动化质量检查机制。在合并任何重大变更之前运行所有单元和仪器测试也是必须的。\n当所有这些检查通过后，您将获得绿色信号，将APK发布到Play商店或以您想要的任何其他方式分发。   https://mp.weixin.qq.com/s/6ae3i5Zuo8svX0wMGQoggw\n  采用响应式编程方法(RxJava)\n如果您想提升Android开发人员的技能，那么您一定要考虑采用响应式方法。这将迫使您在构建应用程序时以完全不同的方式进行思考。\n采用响应式肯定会帮助您更快地编写交互式应用程序，让您的开发生活更轻松，更有趣。\n  学习使用 Kotlin 进行 Android 开发\n自谷歌在Google I / O 2017上宣布对Kotlin编程语言提供一流支持以来，对该语言的兴趣一路飙升。这种随和的语言为Android开发世界带来了一股清新的空气。\n对于那些厌倦了相同的旧的，冗长的，容易出错的Java应用程序的Android开发人员来说，这是个好消息。试一试，看看它是否点燃了你的新灵感。\n   https://kotlinlang.org/docs/reference/\n  参加聚会，与其他开发者进行更多社交活动\n我们的开发人员往往非常内向，喜欢和我们的计算机坐在一个角落里，在我们自己的世界里。\n尝试离开您的舒适区并与其他开发人员进行更多互动。当你参加开发者聚会和社交聚会时，或者只是与其他与你的兴趣相似的开发者交谈时，有很多东西需要学习。\n提示：访问 meetup.com 查找您感兴趣的聚会。\n  熟悉键盘快捷键\n您可以在Android Studio中执行几乎所有操作的键盘快捷键。学习这些快捷方式将大大缩短您的开发时间并改善您的工作流程。记住键盘快捷键可能需要一些时间，但从长远来看，它将帮助您迈向真正无鼠标的工作流程。\n  尝试每周在Android中至少学习一件新东西\n在广阔的Android世界中，有许多东西需要学习和理解，足以让你在最初进入它时不堪重负。但是，如果你承诺每周在Android上学习一件新东西，事情会变得更容易。\n列出你不知道的所有事情，为他们分配优先级，并每周一个接一个地开始。几个月后，您将发现自己远远领先于您的起点。\n  自动化任何吃你时间的东西\n我们的工程师在出生时很懒惰，总是试图找到一个简单的方法来做一个无聊的工作。\n因此，如果您需要每天多次重复和无聊，请考虑自动化它。它会累积每周为您节省大量时间，您可以花费在其他更高效，更有用的事情上。\n提示：看看 Zapier ，这是一款非常棒的工具，可以帮助您连接和自动化几乎每天使用的几种工具。\n  考虑运行两个版本的 Android Studio\n始终保持稳定版本的 Android Studio，以完成您每天需要做的所有重要事情。但也要考虑安装最新 Android Studio 的 canary 或 beta 版本。\n有时会有许多新的令人兴奋的功能，这些功能可以帮助您尽早尝试这些早期版本。\n  偶尔审核所有第三方库\n我们都喜欢使用库，当我们需要它们时它们就完全没问题了，但是在审核你添加的所有第三方库并删除那些你不再需要的库的过程中养成一种习惯。\n如果您只使用特定库的一小部分，请考虑提取该部分而不是保留整个库。偶尔的审核也可以帮助您更新急需的库。\n  了解重构遗留代码库的更好方法\n不要错误地一次重构一个巨大的遗留代码库。这样做会让你陷入无法逃脱的陷阱。\n相反，请考虑重构您需要立即处理的代码库部分，然后在必要时慢慢扩展到其他部分。另外，在触摸您怀疑可能破坏现有功能的任何代码之前，请考虑为要重构的部分编写测试用例。\n《Working Effectively with Legacy Code》\n   https://github.com/crafts-dev/software-development-ebooks-1\n  始终在低端设备上开发和测试\n如果你想像专业人士一样开发应用程序，永远不要错误地在高端设备上开发和测试应用程序。通常，我们开发人员拥有高端旗舰并使用它们来开发应用程序。但这是你应该完全避免的事情。\n尝试使用市场上最便宜，最低端的设备，并养成仅在这些设备上开发应用程序的习惯。您将开始在应用程序中看到许多您以前不知道的瑕疵。通过这种方式，您可以为世界上没有最佳Android设备的人群准备应用程序。\n  购买你能买得起的最好的工作机器\n不要错误地购买低端工作机器，并且每天都要破坏你的开发过程。\n考虑使用 Mac 进行开发。你会爱上它的简单性和稳定性而不是其他任何东西。\n如果您购买的是 MacBook，请考虑购买具有最佳规格的 MacBook。你将永远感谢自己做出这个决定。\n ","description":"","id":61,"section":"posts","tags":null,"title":"How to be a better android developer","uri":"https://jiyang.site/posts/2019-01-14-how-to-be-a-better-android-developer/"},{"content":"整体流程:\n Step 1: 通电，系统启动 当接通电源时，Boot ROM 代码从预先定义的位置开始执行，该位置在 ROM 中硬编码。 它将 Bootloader 加载到 RAM 中并开始执行。\nStep 2: Bootloader Bootloader (引导加载程序)是一个在 Android 之前运行的小程序。 它不是 Android 系统的一部分。 引导加载程序是制造商放置锁定和限制的地方。引导程序分两个阶段执行。 在第一阶段，它检测外部 RAM 并加载程序。在第二阶段，为内核启动做准备，引导加载程序设置网络，内存等。\nBootloader 位置:\n/bootable/bootloader/legacy/usbloader\nStep 3: Kernel Android内核的启动方式与 Linux 内核类似。随着内核的启动，开始设置缓存，受保护的内存，调度和加载驱动程序。当内核完成系统设置时，它会在系统文件中查找 init 文件。\nLinux 和 Android 内核有什么区别？下面是 Android Project 对 Linux 内核所做的更改/插件列表：\n Binder：它是一个Android特定的进程间通信机制和远程方法调用系统。 ashmem：“Android共享内存”。它是一个新的共享内存分配器，类似于POSIX SHM，但具有不同的行为，并且具有更简单的基于文件的API。 pmem：“进程内存分配器”：它用于管理用户空间和内核驱动程序之间共享的大型（1-16 + MB）物理上连续的内存区域。 logger：这是logcat命令的内核支持。 wakelocks 唤醒锁：它用于电源管理文件。它使机器在每个事件的基础上保持清醒，直到释放唤醒锁。 oom handling：当可用内存变低时，它会终止进程。 alarm manager：它允许用户空间告诉内核何时唤醒。 RAM_CONSOLE：允许将内核printk消息保存到RAM中的缓冲区，以便在内核崩溃后可以在下一次内核调用中查看它们。 支持 ADB 的 USB 驱动程序 Android 最初使用 YAFFS2 作为文件系统. 2.3 之后, 改用 ext4.  Step 4: init process Init 是第一个进程，可以说它是一个根进程，或者是所有进程的祖父。 init 进程有两个职责。\n 安装 /sys，/dev 或 /proc 等目录 运行 init.rc 脚本   init进程可以在：/system/core/+/master/init/ 找到 Init.rc文件可以在：/system/core/+/master/rootdir/ 找到  Android 具有 init.rc 文件的特定格式和规则。init.rc中的内容及其用途。\nStep 5: Zygote and Dalvik/ART 在 Java 中，我们知道单独的虚拟机实例将在内存中被每个应用程序单独使用，但在 Android 的情况下，VM 应尽可能快地运行应用程序。但是，如果多个应用程序启动 Dalvik（VM）的多个实例会发生什么？它将消耗大量内存。\n为了解决这个问题，Android OS 有一个名为 Zygote 的系统。 Zygote 支持跨进程共享 Dalvik VM 的代码，实现更低的内存占用和最短的启动时间。 Zygote 是一个从系统启动开始就启动的虚拟机进程。 Zygote 会预加载并初始化核心库类。\nZygote装载过程：\n 加载 Zygote Init 类：\n\u0026lt;android source\u0026gt;/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java registerZygoteSocket（）: 它为zygote命令连接注册服务器套接字。 preloadClasses（）: 是一个简单的文本文件，包含需要预加载的类列表，可以在 \u0026lt;android source\u0026gt;/framework/base 找到该文件 preloadResources（）: android.R 文件中包含的所有内容都将使用此方法（主题和布局）加载。  这时，您可以看到启动动画。\nStep 6: System service 完成上述步骤后，Zygote 将启动系统服务。 Zygote fork 了一个新的进程来启动系统服务。\n核心服务:\n Starting power manager Creating the Activity Manager Starting telephony registry Starting package manager Set activity manager service as system process Starting context manager Starting system contact providers Starting battery service Starting alarm manager Starting sensor service Starting window manager Starting Bluetooth service Starting mount service  其他服务:\n Starting status bar service Starting hardware service Starting NetStat service Starting connectivity service Starting Notification Manager Starting DeviceStorageMonitor service Starting Location Manager Starting Search Service Starting Clipboard Service Starting checkin service Starting Wallpaper service Starting Audio Service Starting HeadsetObserver Starting AdbSettingsObserver ","description":"","id":62,"section":"posts","tags":null,"title":"Android系统启动简介","uri":"https://jiyang.site/posts/2019-01-01-android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%AE%80%E4%BB%8B/"},{"content":"工作   业务上主动推进，做最主动的那个人  将会执行两周一个版本的迭代方式, 每个小需求都会有一个 owner. 尽量自己争取做这个 owner. 提出的某些点子，最好推行下去，可以创建在自己的 Phabricator Task 里，避免后面忘记   尽量承担更多业务之外的事情  SharedPreferences 由于文件读取同步锁的问题, 造成使用 commit 时, 主线程被阻塞, 造成了线上较多的 ANR, 计划使用 MMKV 替换 SharedPreferences 做 K-V 存储. Dart 分享 Tinker 热修复分享, (进行了一次, 但是准备不是太充分, 还没有讲到核心的 Dex 热修复, 资源热修复, 组件热修复)    个人成长 项目中用到的库源码学习，输出文章  RxJava2 → 响应式编程，操作符、原理  RxJava被观察者的创建和订阅过程分析(不带线程切换版) RxJava线程切换过程分析   OkHttp → HTTP 网络请求 Retrofit → 定义 HTTP 请求接口  Retrofit 请求过程   OkDownloader → 下载相关 SoLoader(Fackbook) → So 的动态加载 Tinker → 热修复 LogX → 日志采集、加密解密、上传  个人计划安排  搭建了自己的任务管理 Phabricator. 后续考虑使用 GitHub 的 Project，节省自己的服务器  增量更新 2019-11-13  1/4 人生\n  Apk Dispatcher 内测发包平台完成了 2 版 热修复相关看书了解了一些, 但是还有一些疑问 🤔️  Tinker 的热修复将新的 dex 包加载到了内存中的 DexPathList 里的 elements 的首部, 那在应用重启之后, 每次都要执行这个步骤吗? 既然 dex 文件已经被补丁替换了, 那为什么还要修改内存中的信息? 下次应用重启不就加载新的 dex 了吗?   OkHttp 了解了它内部的调用链的过程, 但是每个 interceptor 的作用和原理还有待细看 通过看《Android移动性能实战》了解到一些IO的优化措施, 在项目上应用 看一些博客了解到 systrace 的使用方法, 用来检测项目中的绘制上可优化的点 通过 Android Studio Profiler 的 Method Trace, 梳理 Android SDK 一些内部的调用逻辑 结合 adb shell am dumpheap、hprof-conv 和 MAT 工具分析应用内存占用, 优化应用在后台时的静态内存占用 ","description":"","id":63,"section":"posts","tags":["计划"],"title":"2019年度计划","uri":"https://jiyang.site/posts/2018-12-31-2019%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"},{"content":"以我 youcute.cn 为例，首先安装 acme 脚本 https://github.com/Neilpang/acme.sh。然后生成证书，将证书拷贝到相应的目录。\n 因为我的 nginx 的配置只有 root 有权限，所以为图方便，acme.sh 也是安装在 root 的用户目录下 nginx \u0008是从\u0008一个普通用户目录里读取 ssl 证书文件  生成多个证书 1  acme.sh --issue -d youcute.cn -d liulidun.youcute.cn -d blog.youcute.cn -d jenkins.youcute.cn --nginx   将证书拷到对应目录 1  acme.sh --installcert -d youcute.cn --key-file /home/jy/ssl/youcute.cn.key --fullchain-file /home/jy/ssl/fullchain.cer --reloadcmd \u0026#34;service nginx force-reload\u0026#34;   Nginx 配置 http { log_format main '$remote_addr - $remote_user [$time_local] \u0026quot;$request\u0026quot; ' '$status $body_bytes_sent \u0026quot;$http_referer\u0026quot; ' '\u0026quot;$http_user_agent\u0026quot; \u0026quot;$http_x_forwarded_for\u0026quot;'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; gzip on; include /etc/nginx/mime.types; default_type application/octet-stream; # 导入其他反向代理域名 server 配置 include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name youcute.cn www.youcute.cn; root /home/jy/static_web/index/; rewrite ^(.*) https://$server_name$1 permanent; # 导入配置，例如 ssl.conf include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } server { listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name youcute.cn www.youcute.cn; root /home/jy/static_web/index/; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } SSL 配置放在了 default.d/ssl.conf里 ssl_certificate \u0026quot;/home/jy/ssl/fullchain.cer\u0026quot;; ssl_certificate_key \u0026quot;/home/jy/ssl/youcute.cn.key\u0026quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; 每个子域名的配置 例如 blog.youcute.cn。\n每个子域名也会去读取上面的 ssl 配置\nserver { listen 80; listen [::]:80; server_name blog.youcute.cn; root /home/jy/static_web/blog/; #rewrite ^(.*) https://$server_name$1 permanent; location / { } } server { listen 443; listen [::]:443; server_name blog.youcute.cn; root /home/jy/static_web/blog/; include /etc/nginx/default.d/*.conf; } ","description":"","id":64,"section":"posts","tags":["Nginx"],"title":"为服务器配置自动更新SSL证书","uri":"https://jiyang.site/posts/2018-12-27-%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0ssl%E8%AF%81%E4%B9%A6/"},{"content":"图像的数字化过程 图像的数字化主要分两个过程，采样和量化。\n采样  用多少点来描述一张图像\n 例如一张 600x400 尺寸的图, 会采样 240000 个点, 又叫 24 万像素\n量化  把采样点上对应的亮度连续变化区间转化为单个特定数值的过程\n  每个像素点都有一个色值, 代表一种颜色 色值在不同的颜色模型下会用不同的分量表示  图像的颜色模型  RGB: 任何一种颜色都可用三种基本颜色(红、绿、蓝)按不同的比例混合得到。在 RGB 模型中，一个像素值往往用 RGB 三个分量表示。当 RGB 的每个分量数值不同，混合得到的颜色就不同。 CMY: 任何一种颜色都可以用三种基本颜料(青色(Cyan)、品红(Magenta)和黄色(Yellow)按一定比例混合得到。CMY 模型常用于打印。 YUV: 多用于描述模拟信号。每一个颜色有一个亮度信号 Y，和两个色度信号 U 和 V。YUV 使用 RGB 的信息，但它从全彩色图像中产生一个黑白图像，然后提取出三个主要的颜色变成两个额外的信号来描述颜色。产生的目的是当年黑白电视和彩色电视的过渡，可以减少图像传输的数据量，因为 RGB 的颜色太多，每个像素占带宽太多，YUV 中就可以通过减少对色度信号的抽样，减少带宽占用，而且YUV可以单独传输，容易兼容黑白电视，黑白电视只用亮度信号就可以。根据信号抽样的频率不同，YUV 又可以细分。 YCrCb: 描述数字信号的 YUV 模型。 HSL: RGB 模型的另外一种描述，在HSL模型中，H 定义颜色的波长，称为色调; S 定义颜色的强度(intensity)，表示颜色的深浅程度，称为饱和度; L 定义掺入的白光量，称为亮度。  RGB 模型 在 RGB 模型下，每个像素色值用 RGB 3 个分量表示, 每个分量可以通过占用不同的 bit 数来达到不同的色彩效果。\n RGB 每个分量用 1 bit 表示\n 如果每个像素的每个颜色分量只用二进制的 1 位来表示，那每个颜色的分量只有 “1” 和 “0” 这两个值，也就是说，每种颜色的强度要么是 100%，要么就是 0%. RGB 每个分量有2种可能(0和1), 3 个分量就有 8($2^3$) 种组合, 能表示 8 种颜色。 图像大小就为 width * height * 3(1个像素3个分量) * 1(每个分量占1位) * / 8(bits 转 bytes) =\u0026gt; W x H x 3 / 8 个字节\n RGB888 每个分量用 8 bit 表示\n 如果每个像素的每个颜色分量用 8 位二进制来表示, 则 RGB 每个分量有 256($2^8$) 种值, 3 个分量就有 16777216 ($2^24$) 种组合, 能表示 1600 万种颜色(也就是我们常说的1600万色)。 图像大小就为 width * height * 3(1个像素3个分量) * 8(每个分量占8位) * / 8(bits 转 bytes) =\u0026gt; W x H x 24 / 8 个字节\nRGB 的排列 抽象排列是指我们在思维上认为图片应该是以行列分布的, 实际在内存中, 图像其实更常见是以一维数组做存储, 以 RGB RGB RGB 的顺序存储. 待需要做一些矩阵运算时再转换为二维数组形式.\nAndroid 上的 RGB 模型 在 Android 上的 Bitmap 有几种图像模型, 其区别就在于: 用不同的位数来存储各个分量和是否带 Alpha 通道, 我们可以在解析 Bitmap 时通过 Bitmap.Config 指定期望的模型，但是最终系统使用什么模型还要根据解析的图片的颜色模型来决定. 比如: 即使我们设置使用 RGB_565 去解析一张带 Alpha 通道的图片, 但最终系统还是会使用 ARGB_8888 模型来解析. 如果我们想减少内存占用则可以使用 ARGB_4444 来解析, 但是质量会降低许多; 或者可以去掉原图的 Alpha 通道, 然后使用 RGB_565 解析.\n   格式 描述     RGB_565 只有 RGB 通道，R 和 B 用 5位表示，G 用 6位表示，一个像素 (5+6+5) = 16 bits 占 2 byte   ARGB_8888 包含 Alpha 通道的 RGB 图像。每个通道用8位表示，每个通道可取值 0~255，一个像素 4*8 = 32 bits 占 4 byte。每个通道色值丰富，图像质量高   ARGB_4444 包含 Alpha 通道的 RGB 图像。每个通道用4位表示，每个通道可取值 0~15，一个像素 4*4 = 16 bits 占 2 byte   ALPHA_8 只有 Alpha 通道, Alpha 通道用 8 位表示, 一个像素占 1 byte. 该格式可用来加载只有 Alpha 通道的蒙版类图像   RGBA_F16 按 RGBA 排列的图像, 每个通道 8 位表示, 一个像素占 8 bytes. 该格式应该是解析质量最高, 内存占用最大的模式     其他几种颜色模型也有类似 RGB 这种的机制，每个分量可以用不同的位数表示。在合适的地方用合适的分量位数。\n YUV 模型  YUV 是 Android 相机开发中输出图像的默认模型\n 现代, YUV 一般是从 RGB 图像中进行采样, 先产生一个使用 Y 通道表示的黑白图像, 然后提取出图像中三个主要的颜色变成两个额外的信号(U 和 V)来描述颜色. YUV 根据不同的采样比和 YUV 分量的排列方式有很多细分的格式.\n   格式 采样过程 YUV分量采样比 垂直采样比 水平采样比 每像素位数 排列方式 格式别名     YUV444 从 RGB 图像里每个像素里提取 YUV 分量，然后按照 VUY 排列 4:4:4 1:1 1:1 32 bits $V_{1}$$U_{1}$$Y_{1}$$A_{1}$ $V_{2}$$U_{2}$$Y_{2}$$A_{2}$ 每个像素的4个分量(多个一个 Alpha 分量)按顺序排列 YUV444   YUV422 从 RGB 图像里每个像素提取 Y 分量, 每隔一个像素提取一对 UV 分量 4:2:2 2:1 1:1 16 bits $Y_{1}$$U_{1}$$Y_{2}$$V_{1}$ $Y_{2}$$U_{2}$$Y_{3}$$V_{2}$ 两个Y 一个U或V YUY2 UYVY   YUV420 从 RGB 图像里每个像素提取 Y 分量, 每隔两个像素提取一对 UV 分量 4:2:0 2:1 2:1 16 or 12 bits 先排所有的 Y, 然后所有的 V, 然后所有的 U IMC1 IMC2 IMC3 IMC4 YV12 NV12 NV21 YUV420P    Android 相机图像处理 Android Camera 接口 Android 的 Camera 默认的预览格式是 NV21（YUV的一种，又称 YUV420P), 也支持通过 setPreviewFormat 设置其他编码，但是其他编码不一定在每台设备上支持。所以为了安全和方便，使用最通用的 NV21。\n拿取 Camera 的实时数据也有几种方式, 这里使用的是给 Camera 设置 previewCallBack, 在 onPreviewCallBack 中拿取.\nonPreviewCallBack 这个方法需要注意: 它是相机每帧都会回调的, 基本是 33 帧每秒, 每 33ms 左右系统就会回调该方法, 如果在 onPreviewCallBack 内发生了超过 33ms 的阻塞, 就会出现丢帧现象。\nNV21 转 RGBA 由于算法需要的图像数据是 RGB 模型下的, 所以需要进行 NV21 到 RGB 的转换.\n这里我尝试了3种方式:\n 使用 Android 提供的 YuvImage （简单方便、但耗时太多; 如果图片不进行压缩, 耗时陡增） 使用 libyuv (耗时相对较少，但是需要自己写 JNI; 如果图片不进行压缩, 耗时也会增大） 使用 RenderScript（耗时最少, 需要理解 RenderScript 的机制; 如果图片不进行压缩, 耗时也较稳定）  压缩旋转 针对上面的3种方式, 尝试了 3 种方法:\n YuvImage 写入到 Bitmap, 通过对 Bitmap 做 Matrix 和边界压缩, 构造新的 Bitmap, 然后从 Bitmap 中获取像素数据 从格式转换到压缩、旋转、镜像都由 libyuv 做 从格式转换到压缩、旋转、镜像都由 RenderScript 做  相比之下, 也是 RenderScript 耗时最少.\n获取单通道 灰度图就是只有一个颜色通道的图片，算法要求是只要有 RGB 任意一个通道就行, 所以我的做法是遍历所有像素, 取出一个通道的. 3 种方式做法都类似。\n 从 Bitmap 的像素中拿  从 Bitmap 中拿到的像素数据，每一个值都是 RGBA 的一个复合值, 需要通过 Color.xxx 拿到对应的实际值。然后从连续的 RGBA 数组中拿一个通道, 就通过遍历做.\n1 2 3 4 5 6 7 8  val pixels = IntArray(bitmap.width * bitmap.height) bitmap.getPixels(pixels, 0, bitmap.width, 0, 0, bitmap.width, bitmap.height) val grayBytes = ByteArray(pixels.size) for (i in 0.until(grayBytes.size)) { // 获取单个通道存入  val red = Color.red(pixels[i]) grayBytes[i] = red.toByte() }    从通过 RenderScript 处理的 RGBA 的像素中拿  val singleChannel = ByteArray(pixels.size/4) val range = IntProgression.fromClosedRange(0, pixels.size - 1, 4) for (i in range) { // 每4个像素的第一个像素是红色 R singleChannel[i / 4] = triple.first[i] } RGBA -\u0026gt; BGR 遍历 RGBA 数据, 进行变换:\n1 2 3 4 5 6 7 8 9 10 11 12  val bgrPixel = ByteArray(rgbaPixels.size / 4 * 3) val bgrRange = IntProgression.fromClosedRange(0, bgrPixel.size - 1, 3) var i = 0 for (j in bgrRange) { val r = rgbaPixels[i] val g = rgbaPixels[i+1] val b = rgbaPixels[i+2] bgrPixel[j] = b bgrPixel[j + 1] = g bgrPixel[j + 2] = r i += 4 }   参考  YUV 编码: https://zh.wikipedia.org/wiki/YUV https://docs.microsoft.com/en-us/previous-versions/aa904813(v=vs.80)  ","description":"本文源于我在公司内部的小分享, 会简单涉及图像的数字化过程, 不同颜色模型(YUV, RGB, NV21)的定义, 内存占用, 采样规则等概念.","id":65,"section":"posts","tags":null,"title":"图像处理基础","uri":"https://jiyang.site/posts/2018-12-14-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"},{"content":"Android 上的多进程情景 Android 中每个应用的进程都 fork 自 Zygote 进程， Zygote 进程在启动时自己会创建一个虚拟机，从而也就让每个应用拥有了自己的虚拟机。\n当应用涉及多进程时，想当于启动了多个虚拟机，在单进程情况下的一些情景将会失效:\n 静态变量: 由于静态变量是位于虚拟机内存的方法区，每个虚拟机彼此独立，多个进程访问的也就不会是同一个变量 单利模式：单利也是基于一个虚拟机的，多个虚拟机将失效 线程同步机制：同步锁基于同一进程 SharedPerfrence 不再可靠: SP 内部是以读写 xml 文件的方式，且只有线程锁。多进程环境下，文件同时读写将不可靠。 Application 类的 onCreate 会在每个进程启动时被调用: 在含有多进程的应用里，需要在 Application 类的 onCreate 里区分当前的进程，避免多个进程都执行了重复的代码。  如何开启多进程 在 AndroidManifest 中，给四大组件设置单独的 android:process 属性。\n这种方式，有两种情况:\n 当前应用私有的进程，声明 process 属性带 : 号，其他应用的组件不能运行在该进程中。  1  \u0026lt;activity android:name=\u0026#34;.AbcActivity\u0026#34; android:process=\u0026#34;:remote\u0026#34;/\u0026gt;   不带 : 号的全局进程。其他应用可以通过 SharedUID 方式跑在该进程中。  1  \u0026lt;activity android:name=\u0026#34;.AbcActivity\u0026#34; android:process=\u0026#34;remote\u0026#34;/\u0026gt;   序列化和反序列化 Java Serializable 接口 让对象支持序列化，只需实现 Serializable接口，并声明一个serialVersionUID。serialVersionUID不是必需的，但是如果不声明会对反序列化过程产生影响。序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同时，才能被正常地反序列化。\n 静态属性属于类，不会被序列化 transitent 声明的属性不会被序列化  Android Parcelable 接口 Android 提供的序列化接口，相比 Serializable 性能更好，因为它主要用于在内存上序列化和反序列化。实现方式就是类实现 Parcelable 接口，并实现 createFromParcel 和 writeToParcel 等方法。\nBinder  从 IPC 角度，Binder 是 Android 的一种跨进程通信方式 从 Android Framework 角度，Binder 是 ServiceManager 连接各种 Manager 和相应 ManagerService 的桥梁 从 Android 应用层，Binder 是客户端和服务端进行通信的媒介，当 bindService 时，服务端会返回一个包含了服务端业务调用的 Binder 对象，通过这个 Binder 对象，客户端就可以像调用客户端本地方法一样调用服务端的方法。 普通 Service 中的 Binder 不涉及进程间通信 多进程的应用会较多涉及 Binder，Binder 也主要用在 Service 上  Android 提供了 AIDL 描述语言来方便开发者创建 Binder 类，也可以自己手写实现 Binder 类。\n模拟一个数据类 User，并实现 Parcelable 接口，使用跨进程的方式，从远程 Service 中获取 User。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class User implements Parcelable { String name; int age; protected User(Parcel in) { name = in.readString(); age = in.readInt(); } public static final Creator\u0026lt;User\u0026gt; CREATOR = new Creator\u0026lt;User\u0026gt;() { @Override public User createFromParcel(Parcel in) { // 从 Parcel 中构造 User 对象  return new User(in); } @Override public User[] newArray(int size) { return new User[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { // 将属性写入 Parcel 对象中  dest.writeString(name); dest.writeInt(age); } }   使用 AIDL，自动生成 Binder 类  创建 User.aidl  // User.aidl package com.jy.app2; parcelable User; 创建 IUserManagerInterface.aidl  // IUserManagerInterface.aidl package com.jy.app2; import com.jy.app2.User; interface IUserManagerInterface { User getUser(); void setUser(in User user); } 需要注意，User.aidl 的文件名和内部声明的 pracelable 都要和 Java 类 User一致，且 User.aidl 的包路径也要和 Java User类一致。\n编译生成的 IUserManagerInterface Java 接口  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149  package com.jy.app2; // 所有可以在 Binder 中传输的接口，都需要继承 IInterface public interface IUserManagerInterface extends android.os.IInterface { // 一个 Binder 类，当客户端和服务端在同一个进程时不会走 onTransact 过程  // 当客户端和服务端不在同一个进程时，会走 onTransact 过程，并且逻辑有内部类 Proxy 完成  public static abstract class Stub extends android.os.Binder implements com.jy.app2.IUserManagerInterface { // Binder 的唯一标识  private static final java.lang.String DESCRIPTOR = \u0026#34;com.jy.app2.IUserManagerInterface\u0026#34;; public Stub() { this.attachInterface(this, DESCRIPTOR); } /* * 用于将服务端的 Binder 对象，转换成客户端所需的 IInterface 接口对象(使用 AIDL 生成的)。 * 这个过程是区分进程的：如果客户端和服务端在同一个进程，此方法返回服务端的 Stub 对象本身；否则 * 就返回 Stub 的内部类 Proxy 对象 */ public static com.jy.app2.IUserManagerInterface asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) \u0026amp;\u0026amp; (iin instanceof com.jy.app2.IUserManagerInterface))) { return ((com.jy.app2.IUserManagerInterface) iin); } return new com.jy.app2.IUserManagerInterface.Stub.Proxy(obj); } // 此方法返回当前的 Binder 对象  @Override public android.os.IBinder asBinder() { return this; } // 此方法运行在服务端的 Binder 线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装之后，交给该方法执行  // 该方法中会服务端根据 code 参数确定应该执行的目标方法，接着从 data 中取出目标方法需要的参数(如果目标参数需要传入参数)，目标方法执行完成后，将结果写入 reply 中(如果目标方法有返回值)。  // 如果该方法返回 false，代表客户端请求失败。所以可以在这里面加自己的业务，比如权限验证，当不通过时直接返回 false  @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { java.lang.String descriptor = DESCRIPTOR; switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(descriptor); return true; } case TRANSACTION_getUser: { data.enforceInterface(descriptor); com.jy.app2.User _result = this.getUser(); reply.writeNoException(); if ((_result != null)) { reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true; } case TRANSACTION_setUser: { data.enforceInterface(descriptor); com.jy.app2.User _arg0; if ((0 != data.readInt())) { _arg0 = com.jy.app2.User.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.setUser(_arg0); reply.writeNoException(); return true; } default: { return super.onTransact(code, data, reply, flags); } } } private static class Proxy implements com.jy.app2.IUserManagerInterface { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } // 此方法运行在客户端，当客户端远程调用此方法时，先创建输入和输出 Parcel _data 和 _reply  // 然后调用 transact 发起 RPC 远程调用，同时线程挂起；然后服务端的 onTransact 被调用，直到  // RPC 结果返回，客户端线程继续运行，并从 _reply 中取出 RPC 的返回结果，最后返回结果  @Override public com.jy.app2.User getUser() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.jy.app2.User _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) { _result = com.jy.app2.User.CREATOR.createFromParcel(_reply); } else { _result = null; } } finally { _reply.recycle(); _data.recycle(); } return _result; } // 此方法同上面，只是多了将参数写入到 _data ，由于该方法没有返回值，所以不会从 _reply 中取结果  @Override public void setUser(com.jy.app2.User user) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((user != null)) { _data.writeInt(1); user.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_setUser, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } //两个整形，用于标识客户端请求的方法  static final int TRANSACTION_getUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_setUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); } // 服务端 Binder 需要实现的方法  public com.jy.app2.User getUser() throws android.os.RemoteException; public void setUser(com.jy.app2.User user) throws android.os.RemoteException; }   手写实现 Binder 类 先定义一个继承了IInterface的接口 1 2 3 4 5 6 7 8 9 10 11  public interface IUserManagerInterface extends IInterface { public String DESCRIPTION = \u0026#34;com.jy.app2.IUserManagerInterface\u0026#34;; public void setUser(String token, User user) throws RemoteException; public User getUser(String token) throws RemoteException; public int Method_setUser = IBinder.FIRST_CALL_TRANSACTION; public int Method_getUser = IBinder.FIRST_CALL_TRANSACTION + 1; }   实现接口，并继承Binder类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127  package com.jy.app2; import android.os.*; import android.support.annotation.NonNull; import android.support.annotation.Nullable; import android.text.TextUtils; abstract class IUserManagerInterfaceImpl extends Binder implements IUserManagerInterface { IUserManagerInterfaceImpl() { attachInterface(this, DESCRIPTION); } @Override public IBinder asBinder() { return this; } // 当不是跨进程时，直接返回服务端本身的 Binder  // 当是跨进程时，返回代理对象  public static IUserManagerInterface asInterface(IBinder object) { if (object == null) { return null; } IInterface iin = object.queryLocalInterface(DESCRIPTION); if ((iin != null) \u0026amp;\u0026amp; (iin instanceof IUserManagerInterface)) { return (IUserManagerInterface) iin; } return new Proxy(object); } @Override protected boolean onTransact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { switch (code) { case Method_getUser: if (!auth(data)) { return false; } User user = this.getUser(data.readString()); reply.writeNoException(); if (user != null) { reply.writeInt(1); user.writeToParcel(reply, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { reply.writeInt(0); } return true; case Method_setUser: if (!auth(data)) { return false; } String token = data.readString(); User arg1 = null; if ((0 != data.readInt())) { arg1 = User.CREATOR.createFromParcel(data); } this.setUser(token, arg1); reply.writeNoException(); return true; } return super.onTransact(code, data, reply, flags); } private boolean auth(Parcel data) { data.enforceInterface(DESCRIPTION); // 模拟权限验证  String token = data.readString(); return !TextUtils.equals(token, \u0026#34;123\u0026#34;); } static class Proxy implements IUserManagerInterface { IBinder remote; Proxy(IBinder remote) { this.remote = remote; } @Override public User getUser(String token) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); User result = null; try { data.writeInterfaceToken(DESCRIPTION); data.writeString(token); boolean success = remote.transact(IUserManagerInterface.Method_getUser, data, reply, 0); reply.readException(); if ((0 != reply.readInt())) { result = User.CREATOR.createFromParcel(reply); } } finally { data.recycle(); reply.recycle(); } return result; } @Override public void setUser(String token, User user) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); try { data.writeInterfaceToken(DESCRIPTION); data.writeString(token); if (user != null) { data.writeInt(1); user.writeToParcel(data, 0); } else { data.writeInt(0); } boolean success = remote.transact(IUserManagerInterface.Method_getUser, data, reply, 0); reply.readException(); } finally { data.recycle(); reply.recycle(); } } @Override public IBinder asBinder() { return remote; } } }   分析 Binder 的调用过程 创建一个 Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class UserService extends Service { User mUser; public UserService() { mUser = new User(); mUser.name = \u0026#34;Stefan\u0026#34;; mUser.age = 13; } @Nullable @Override public IBinder onBind(Intent intent) { return new IUserManagerInterfaceImpl() { @Override public void setUser(String token, User user) throws RemoteException { mUser = user; } @Override public User getUser(String token) throws RemoteException { return mUser; } }; } }   然后bindService\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  IUserManagerInterface userManagerInterface; ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { userManagerInterface = IUserManagerInterfaceImpl.asInterface(service); onServiceConnect(); } @Override public void onServiceDisconnected(ComponentName name) {} }; bindService(new Intent(this, UserService.class), connection, BIND_AUTO_CREATE); } private void onServiceConnect() { try { User user = userManagerInterface.getUser(\u0026#34;token_1234\u0026#34;); } catch (RemoteException e) { e.printStackTrace(); } }   当 bindService成功之后，会首先调用asInterface方法获得Binder对象，所以在 asInterface方法处断点看下\n不跨进程分析  Service 不单独声明 process属性\n 可以看到，调用直接返回了 queryLocalInterface返回的IInterface对象，该对象其实就是在上面 Service 的onBind方法中创建的 IUserManagerInterfaceImpl匿名内部类。客户端调用的直接是那个onBind返回的对象的方法。\n跨进程分析  Service 单独声明 process属性\n 这时候就返回了代理对象，然后接着就是调用getUser方法。\n走到了 Proxy 的 getUser，这是还没有发生跨进程的调用，下一行remote.transact就会发起跨进程请求，将我们请求的方法编号、输入数据、输出数据作为参数传入，接下来的调用就会走到另一个进程里，同时客户端这边线程会被挂起等待。Debug 也需要 attach 到另一个进程上。onTransact将执行在服务端进程上：\nonTransact里根据方法编号调用对应的方法，这里的this是在 Service 的 onBind中返回的对象。在这里会将结果写到 replay中，然后结束，程序执行切换会客户端进程。\nProxy 继续执行，从 reply中取出结果，最后返回。\n总结  Proxy 中的逻辑是运行在客户端进程的，且默认在主线程，需要注意阻塞问题，所以bindService成功之后，可以通过单开线程来做 IPC 调用 onTransact 运行在服务端进程中，且运行在 Binder 线程池中，Binder 中的逻辑无论耗时都应该使用同步实现 ","description":"","id":66,"section":"posts","tags":null,"title":"Android IPC 相关","uri":"https://jiyang.site/posts/2018-12-04-android-ipc-%E7%9B%B8%E5%85%B3/"},{"content":" 参考 Java Garbage Collection Basics 和 《周志明. 深入理解Java虚拟机》\n Jvm 内存运行时区域的各个部分中：程序计数器、 虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。\nHotSpot 虚拟机内存分区 内存分配和回收的整个过程  首先，任何新的对象会被分配到 eden 空间，两个 survivor 空间\u0008开始保持空白  当 eden 空间分配满，就会执行 minor GC  被引用的对象会被移动到第一个 survivor 空间；当 eden 空间清除时，未被引用的对象会被删除  当发生下一次 minor GC 时，eden 空间发生上面一样的事情。未被引用的对象被删除，被引用的对象被移动到 survivor 空间。\u0008但是现在，被引用的对象会被移动到第二个 survivor 空间。而且，上一次 minor GC 的幸存者也会从 S0 移动 S1 空间。当所有对象都移到 S1 之后， eden 和 S0 空间就被清空，幸存的对象年龄增加。  在下一个 minor GC中，重复相同的过程。 然而这次 survivor 空间会进行切换。被引用的对象被移动到S0。幸存的对象年龄增加。 eden 和 S1 会被清除。  在 minor GC 之后，当对象的年龄达到一定的年龄阈值时，它们从 young generation 晋升到 old generation。  随着 minor GC 继续发生，对象将继续被晋升到 old generation。  最终，将进行 major GC 对 old generation 清理和压缩。  垃圾回收的步骤  标记  正常删除  伴随着内存整理的删除   除了删除没有被引用的对象外，还会把存活的对象移动到一端，可以让新的内存分配更快\n 标记的算法 引用计数 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n存在的问题： 无法解决循环引用问题\n可达性分析 通过一系列的称为\u0026quot;GCRoots\u0026quot;的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到 GCRoots 没有任何引用链相连时，则证明此对象是不可用的。\n在Java语言中，可作为 GCRoots 的对象包括下面几种：\n 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI 引用的对象。  Java 中的引用  强引用 直接引用对象  只有对象存在强引用，并\u0008到 GCRoots 可达，垃圾收集器不会回收对象\n 软引用 SoftReference 包裹  对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。\n 弱引用 WeakReference 包裹  当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。\n 虚引用 PhantomReference 包裹  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。\n删除的算法 标记清除 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是上面的可达性分析。它是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n复制 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。\n 新生代和老年代是后面的分代收集算法提出的概率\n IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照 1:1 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（HandlePromotion）。\n\u0008因此从内存回收的角度， 常用的\u0008JVM 的堆的新生代可以细分为3个区域:\n Eden Survivor Survivor  Eden 和第一个 Survivor 区负责存放新生的对象，第二个 Survivor 负责存放经历了一次内存回收之后\u0008依然存活的对象。\n标记整理 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n分代收集 当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清除”或者“标记—整理”算法来进行回收。\n垃圾收集器 7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。\n","description":"","id":67,"section":"posts","tags":null,"title":"Jvm垃圾收集和内存分配","uri":"https://jiyang.site/posts/2018-11-17-jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"},{"content":"  线程公有\n Methoud Area Heap    线程私有\n Java Threads Program Counter Registers Native Internal Threads    1. 程序计数器 由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。\n2. 虚拟机栈 Java 虚拟机栈是线程私有的，生命周期与线程相同，内部数据结构就是一个先进\u0008后出的栈。虚拟机栈描述了 Java 方法执行的内存模型：每个方法执行时都会创建一个栈帧(Stack Frame) 来储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈和出栈的过程。\n 局部变量表：储存了编译期可知的各种基本数据类型 (boolean、byte、char、short、int、float、long、double)、对象引用（reference 类型）和 returnAddress 类型（类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间就完成分配，运行时不会改变。  如果线程请求的最大栈深度大于了虚拟机所允许的深度，就会出现 StackOverflowError异常；如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存时，就会出现OutOfMemoryError异常。\n3. 本地方法栈 本地方法栈与虚拟机栈类似，只是本地方法栈是为 Native 方法服务。\n4. Java 堆 Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。Java 虚拟机中描述的是：所有对象实例和数组都要在堆上分配内存。\n  从内存回收角度来看: 由于现在的垃圾收集器都采用分代收集算法，所以 Java 堆可以细分为新生代和年老代。在细致点就有：\n Eden 空间 From Survivor 空间 To Survivor 空间    从内存分配角度来看：线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区（ Thread Local Allocation Buffer, TLAB）。\n  Java 堆可以处在物理上不连续,但逻辑上要连续的内存空间上。在实现时可以固定大小，也可以不固定大小。通过 -Xmx和-Xms 可以控制堆大小。如果堆中没有内存完成分配，并且堆也无法扩展时，就会出现 OutOfMemoryError 异常。\n5. 方法区 方法区（ Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n根据 Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。\n运行时常量池 运行时常量池（ Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外， 还有一项信息是常量池（ Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。\n运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只有编译期才能产生，也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。\n6. 直接内存 直接内存（ Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。\n在 JDK 1.4 中新加入了 NIO（ New Input/ Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用 进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。本机直接分配内存不受 Java 堆的限制，但是如果系统本身内存不足以分配时，也会抛出OutOfMemoryError异常。\n总结  线程私有的区域: 程序计数器、虚拟机栈、本地方法栈 线程共有的区域：堆、方法区 抛出StackOverflowError的区域: 虚拟机栈、本地方法栈 抛出OutOfMemoryError的区域: 虚拟机栈、本地方法栈、堆、方法区、直接内存区域 ","description":"","id":68,"section":"posts","tags":null,"title":"Jvm运行时数据区","uri":"https://jiyang.site/posts/2018-10-20-jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"},{"content":" 基于 mmap 的高性能通用 key-value 组件, 底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。 https://github.com/Tencent/MMKV\n 官方对比：    IOS 循环写入随机的int 1w 次 Android 循环写入随机的int 1k 次          运行过程  通过 mmap 系统调用，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失 在内存中维护一份 k,v 字典数据 写入操作：将 value protobuf 序列化更新到字典，然后将字典再 protobuf 序列化追加到文件中(每个 Key 的更新都是直接追加到文件末尾，不是覆盖，只有当文件大小不足时才会进行 key 去重操作，所以文件大小会比通过常规方式(SharedPreferences)储存的 xml 文件大) 读取操作：将文件中的数据反序列化到内存的字典中，之后的每次 get 操作直接从内存中获取，获取到 value 之后再反序列化  原理 获取 MMKV 实例 1  private native static long getMMKVWithID(String mmapID, int mode, String cryptKey);   对应的 Native 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  extern \u0026#34;C\u0026#34; JNIEXPORT JNICALL jlong Java_com_tencent_mmkv_MMKV_getMMKVWithID( JNIEnv *env, jobject obj, jstring mmapID, jint mode, jstring cryptKey) { MMKV *kv = nullptr; if (!mmapID) { return (jlong) kv; } string str = jstring2string(env, mmapID); if (cryptKey != nullptr) { string crypt = jstring2string(env, cryptKey); if (crypt.length() \u0026gt; 0) { kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, \u0026amp;crypt); } } if (!kv) { kv = MMKV::mmkvWithID(str, DEFAULT_MMAP_SIZE, (MMKVMode) mode, nullptr); } return (jlong) kv; }   进一步调用 MMKV 类的静态方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 声明 static MMKV *mmkvWithID(const std::string \u0026amp;mmapID, int size = DEFAULT_MMAP_SIZE, MMKVMode mode = MMKV_SINGLE_PROCESS, std::string *cryptKey = nullptr); // 实现 MMKV *MMKV::mmkvWithID(const std::string \u0026amp;mmapID, int size, MMKVMode mode, string *cryptKey) { if (mmapID.empty()) { return nullptr; } // 线程同步锁，使用区域锁模式  SCOPEDLOCK(g_instanceLock); // static unordered_map\u0026lt;std::string, MMKV *\u0026gt; *g_instanceDic;  // 从全局的缓存对象中获取一个对象，如果缓存中没有，就创建一个新的对象，并加到全局缓存中  auto itr = g_instanceDic-\u0026gt;find(mmapID); if (itr != g_instanceDic-\u0026gt;end()) { MMKV *kv = itr-\u0026gt;second; return kv; } auto kv = new MMKV(mmapID, size, mode, cryptKey); (*g_instanceDic)[mmapID] = kv; return kv; }   题外话，MMKV 中的锁 MMKV 中封装了2个与锁相关的类:\n ThreadLock ScopedLock  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class ThreadLock { private: pthread_mutex_t m_lock; public: ThreadLock(); ~ThreadLock(); void lock(); bool try_lock(); void unlock(); }; ThreadLock::ThreadLock() { // 创建一个互斥锁属性  pthread_mutexattr_t attr; pthread_mutexattr_init(\u0026amp;attr); // 锁的类型: PTHREAD_MUTEX_RECURSIVE: 如果线程在不首先解除锁定互斥锁的情况下尝试重新锁定该互斥锁，则可成功锁定该互斥锁  pthread_mutexattr_settype(\u0026amp;attr, PTHREAD_MUTEX_RECURSIVE); // 通过属性创建初始化锁  pthread_mutex_init(\u0026amp;m_lock, \u0026amp;attr); // 销毁属性  pthread_mutexattr_destroy(\u0026amp;attr); } ThreadLock::~ThreadLock() { // 析构时销毁互斥锁  pthread_mutex_destroy(\u0026amp;m_lock); }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  template \u0026lt;typename T\u0026gt; class ScopedLock { T *m_lock; // just forbid it for possibly misuse  ScopedLock(const ScopedLock\u0026lt;T\u0026gt; \u0026amp;other) = delete; ScopedLock \u0026amp;operator=(const ScopedLock\u0026lt;T\u0026gt; \u0026amp;other) = delete; public: ScopedLock(T *oLock) : m_lock(oLock) { assert(m_lock); lock(); } ~ScopedLock() { unlock(); m_lock = nullptr; } void lock() { if (m_lock) { m_lock-\u0026gt;lock(); } } bool try_lock() { if (m_lock) { return m_lock-\u0026gt;try_lock(); } return false; } void unlock() { if (m_lock) { m_lock-\u0026gt;unlock(); } } }; #define SCOPEDLOCK(lock) _SCOPEDLOCK(lock, __COUNTER__) #define _SCOPEDLOCK(lock, counter) __SCOPEDLOCK(lock, counter) #define __SCOPEDLOCK(lock, counter) ScopedLock\u0026lt;decltype(lock)\u0026gt; __scopedLock##counter(\u0026amp;lock)   TODO ⬇️ 内存准备 通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。\n 默认文件大小：系统内存分页大小,大小一般是 4096 byte, 4KB 文件存不够时，先对 key 去重，之后空间还是不够就增大文件，以内存分页大小的整数倍增加  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  void MMKV::loadFromFile() { //获取文件句柄  m_fd = open(m_path.c_str(), O_RDWR | O_CREAT, S_IRWXU); if (m_fd \u0026lt; 0) { MMKVError(\u0026#34;fail to open:%s, %s\u0026#34;, m_path.c_str(), strerror(errno)); } else { m_size = 0; // 获取文件大小  struct stat st = {0}; if (fstat(m_fd, \u0026amp;st) != -1) { m_size = static_cast\u0026lt;size_t\u0026gt;(st.st_size); } // round up to (n * pagesize)  // 如果 size 小于系统内存分页大小 或 不是整数倍,就增加到整数倍  if (m_size \u0026lt; DEFAULT_MMAP_SIZE || (m_size % DEFAULT_MMAP_SIZE != 0)) { size_t oldSize = m_size; m_size = ((m_size / DEFAULT_MMAP_SIZE) + 1) * DEFAULT_MMAP_SIZE; //改变文件大小到新的 size  if (ftruncate(m_fd, m_size) != 0) { m_size = static_cast\u0026lt;size_t\u0026gt;(st.st_size); } //用 0 把新增的空间填满  zeroFillFile(m_fd, oldSize, m_size - oldSize); } //建立内存映射  m_ptr = (char *) mmap(nullptr, m_size, PROT_READ | PROT_WRITE, MAP_SHARED, m_fd, 0); if (m_ptr == MAP_FAILED) { MMKVError(\u0026#34;fail to mmap [%s], %s\u0026#34;, m_mmapID.c_str(), strerror(errno)); } else { memcpy(\u0026amp;m_actualSize, m_ptr, Fixed32Size); bool loaded = false; if (m_actualSize \u0026gt; 0) { if (m_actualSize \u0026lt; m_size \u0026amp;\u0026amp; m_actualSize + Fixed32Size \u0026lt;= m_size) { if (checkFileCRCValid()) { // 将文件解码为字典，存到内存中  m_dic = MiniPBCoder::decodeMap(inputBuffer); // 将原始内存映射指针位移到已经填充之后的位置，构造成一个负责输出数据到文件的对象，供后面写数据使用  m_output = new CodedOutputData(m_ptr + Fixed32Size + m_actualSize, m_size - Fixed32Size - m_actualSize); loaded = true; } } } } } m_needLoadFromFile = false; }   数据组织 数据序列化方面选用 protobuf 协议\n写入优化 考虑到主要使用场景是频繁地进行写入更新，将 kv 对象序列化后，append 到内存末尾。\n 比如写入一个字符串\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  bool MMKV::setStringForKey(const std::string \u0026amp;value, const std::string \u0026amp;key) { if (key.empty()) { return false; } // 序列化 value  auto data = MiniPBCoder::encodeDataWithObject(value); return setDataForKey(std::move(data), key); } bool MMKV::setDataForKey(MMBuffer \u0026amp;\u0026amp;data, const std::string \u0026amp;key) { if (data.length() == 0 || key.empty()) { return false; } // check 文件是否已经加载到内存，没有就加载一次  checkLoadData(); // m_dic[key] = std::move(data);  // 从内存中的字典拿  auto itr = m_dic.find(key); if (itr == m_dic.end()) { // 没有就插入  itr = m_dic.emplace(key, std::move(data)).first; } else { // 有就更新  itr-\u0026gt;second = std::move(data); } // 至此内存中操作结束  // 然后进行将数据写到内存映射  return appendDataWithKey(itr-\u0026gt;second, key); }   空间增长 使用 append 实现增量更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  bool MMKV::appendDataWithKey(const MMBuffer \u0026amp;data, const std::string \u0026amp;key) { // 扩容  bool hasEnoughSize = ensureMemorySize(size); if (!hasEnoughSize || !isFileValid()) { return false; } // 如果实际大小为0，表示第一次写入数据  if (m_actualSize == 0) { // 直接将内存中的字典全部写入  auto allData = MiniPBCoder::encodeDataWithObject(m_dic); if (allData.length() \u0026gt; 0) { writeAcutalSize(allData.length()); m_output-\u0026gt;writeRawData(allData); return true; } return false; } else { // 向末尾追加数据  writeAcutalSize(m_actualSize + size); m_output-\u0026gt;writeString(key); m_output-\u0026gt;writeData(data); auto ptr = (uint8_t *) m_ptr + Fixed32Size + m_actualSize - size; if (m_crypter) { m_crypter-\u0026gt;encrypt(ptr, ptr, size); } updateCRCDigest(ptr, size, KeepSequence); return true; } }   总结  适应于频繁写入读取的地方 文件大小会比常规方式大一些 内部的一些实现比较高效  函数传参采用右值引用，外部通过 move调用将函数中局部变量的内容直接通过移动内存指向形参中，避免直接传参的内存拷贝   ","description":"","id":69,"section":"posts","tags":null,"title":"MMKV分析","uri":"https://jiyang.site/posts/2018-10-19-mmkv%E5%88%86%E6%9E%90/"},{"content":"问题 线上一直会报一个 Crash，通过日志发现用户的操作路径：\n 将一个展示结果的 Activity 退到了后台 然后当回到这个 Activity 时，发生了 NPE 错误导致 Crash  一开始，我预测是 Activity 被系统回收了，再次进入时数据未恢复\u0008造成了 Crash。于是我在开发者工具中将\u0008「保留Activity活动」设置为不保留。这样一旦应用被切到后台，系统立刻就会销毁这个 Activity ，但是这样之后，当用户再次进入时每次都相当于重启了 App，一直不能复现这个问题。\n模拟复现 后来，经由同事提醒，我安装了一个可以一直向系统怼内存的 App。通过它我模拟了系统在内存不足情况下的表现。\n 首先将应用切到后台 然后打开怼内存的应用，一直向系统怼内存，直到怼不动为止。一般到内存占用 97% 左右，这个应用就怼不动了。 然后再切回应用，果然问题重现了  查看日志发现，是这个 Activity 引用了一个全局的对象，在系统内存不足时，Activity 被回收了，此时 Activity 上显示的 View 的状态都被系统保存，在 Activity 重新进入时被恢复；但是 Activity 中其他未被 View 引用的局部变量数据是不会被系统\u0008自动保存和恢复的，需要\u0008自己手动在 onSavaInstanceState 和 onRestoreInstanceState 中进行保存和恢复，否则在 Activity 被恢复之后，如果使用这些局部变量就会出现 NPE，导致崩溃。\n局部变量的恢复问题解决了，但是还有一个全局对象的问题，全局对象作为单例存在整个应用中，而且\u0008它包含的数据对象较多，\u0008\u0008就不能通过简单的 saveInstanceState \u0008保存。我们现在的方案是在这个全局对象构造时就会将它序列化写入到 SharedPreferences 中，但遇到有用到的 Activity 时，会在 Activity onCreate 之前从 SharedPreferences 中恢复。\n 阅读官方文档\n 如果一个后台 Activity 是由于系统的限制（比如配置发生改变，内存不足）被系统销毁了，尽管这个 Activity 实例已经不存在了，但是系统会记住这个 Activity，如果用户试图再次回到这个 Activity，\n系统就会重新创建一个 Activity，并会使用一组在销毁 Activity 时保存的数据去恢复 UI 界面。这一组用来恢复的数据以 Bundle 的形式存储。默认情况下，系统会使用 Bundle 去储存 Activity 布局中的每个 View 对象的数据。因此如果你的 Activity 被销毁然后重建，布局的状态会恢复到之前的状态，不需要单独写代码。\n但是如果想存储一些其他成员变量数据，需要自己单独写代码。\n 储存简单的、轻量的数据可以使用 onSavaInstanceState onSavaInstanceState 中的 Bundle 不适合储存大量数据，因为他会在 main Thread 进行序列化操作，并且消耗系统进程的内存。大量数据应该使用持久化存储做。  总结:   onSavaInstanceState 和 onRestoreInstanceState 可以在 Activity 被系统回收之后, 在重新创建时，恢复在 onSavaInstanceState 中储存的数据。\u0008\n  已经设置在 View 上的数据，系统会自动进行保存和恢复。\n  尽量不用全局数据，用了就要考虑到内存被回收之后，数据恢复的问题。\n  ","description":"记一次由于内存不足导致 App Crash 的复现和解决过程","id":70,"section":"posts","tags":null,"title":"模拟系统内存不足时应用崩溃问题","uri":"https://jiyang.site/posts/2018-10-07-%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%97%B6%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class Test { data class Man(val name: String, val argOne: String = \u0026#34;456\u0026#34;) private val argOne = \u0026#34;123\u0026#34; fun print() { Man(\u0026#34;stefan\u0026#34;).let { println(it.name) // it 代表 let 的调用方: Man  println(this.argOne) //123 this 代表 print 方法的属主: class Test  println(argOne) //456 隐式调用 this 同上一行  println(it.argOne) //456  } Man(\u0026#34;stefanJ\u0026#34;).run { println(this.name) // this 代表 run 的调用方: Man  println(this.argOne) //456  println(argOne) //456 隐式调用 this，所以是 Man 中的 argOne  } Man(\u0026#34;stefanJi\u0026#34;).apply { println(this.name) // this 代表 apply 的调用方: Man  println(this.argOne) //456  println(argOne) //456 隐式调用 this  } with(Man(\u0026#34;stefanJiJ\u0026#34;)) { println(this.name) // this 代表 with 接收的对象  println(this.argOne) //456  println(argOne) //456  } } }   从上面的例子可以看出，let run apply 他们的本质区别是代码块里的能拿到的执行对象不一样：\n let是通过it拿到当前执行对象 run通过this apply通过this  但是 run 和 apply 貌似没有差别，既然名字不一样，肯定还是有差别的，看看他们的签名：\n run  1 2 3 4  public inline fun \u0026lt;T, R\u0026gt; T.run(block: T.() -\u0026gt; R): R { //... 忽略中间部分  return block() }   run 的返回值是代码块的返回值\n apply  1 2 3 4 5  public inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { //... 忽略中间部分  block() return this }   apply 的返回值是当前对象\n let  1 2 3 4  public inline fun \u0026lt;T, R\u0026gt; T.let(block: (T) -\u0026gt; R): R { //... 忽略中间部分  return block(this) }   let 的返回值也是代码块的返回值，且会把当前对象作为参数传入，这个参数默认名字叫 it,也可以自己取名字\n1 2 3 4 5 6  Man(\u0026#34;stefan\u0026#34;).let { man -\u0026gt; println(man.name) // man 代表 let 的调用方: Man  println(this.argOne) //123 this 代表 print 方法的属主: class Test  println(argOne) //456 隐式调用 this 同上一行  println(man.argOne) //456 }    with  1 2 3 4  public inline fun \u0026lt;T, R\u0026gt; with(receiver: T, block: T.() -\u0026gt; R): R { //... 忽略中间部分  return receiver.block() }   而且 let run apply 都是 T.xx 的方式定义，说明他们是作为任意对象的一个扩展函数使用，而with则是作为普通的顶层函数使用。\n","description":"对 Kotlin 提供的几个方便的扩展方法，进行使用差别的分析。","id":71,"section":"posts","tags":null,"title":"Kotlin let run apply with 方法","uri":"https://jiyang.site/posts/2018-09-19-kotlin-let-run-apply-with%E6%96%B9%E6%B3%95/"},{"content":"Retrofit  官话: A type-safe HTTP client for Android and Java\n 我的理解: 它提供了一种方便的 HTTP 请求编写方式. 它通过解析接口方法的注解, 构造出对应的 HTTP 请求方法, 并且支持添加自己的 CallAdapter 和 Converter 定制化请求的创建和结果的解析.\n定义 HTTP 接口方法 1 2 3 4  public interface GitHubService { @GET(\u0026#34;users/{user}/repos\u0026#34;) Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; listRepos(@Path(\u0026#34;user\u0026#34;) String user); }   创建 Retrofit 实例和请求方法 1 2 3 4 5  Retrofit retrofit = new Retrofit.Builder() .baseUrl(\u0026#34;https://api.github.com/\u0026#34;) .build(); GitHubService service = retrofit.create(GitHubService.class);   发出请求并获取结果 1  Call\u0026lt;List\u0026lt;Repo\u0026gt;\u0026gt; repos = service.listRepos(\u0026#34;octocat\u0026#34;);   下图是以 Rxjava2CallAdapter 为 CallAdapter 时, 在 create 之后, 调用\u0008方法的大致流程:\nRetrofit 的构造  在多处使用了建造者模式, \u0008工厂模式 在接口的实现处使用了动态代理  Retrofit.Builder 一些配置参数：\n   属性 类型 说明     platform Platform 代码运行的平台, Retrofit 提供两个默认的 Andorid 和 Java   callFactory okhttp3.Call.Factory 请求的构造器   baseUrl HttpUrl 所有请求的BaseUrl   converterFactories List\u0026lt;Converter.Factory\u0026gt; 结果的转化器集   callAdapterFactories List\u0026lt;CallAdapter.Factory\u0026gt; 请求的适配器转化集   callbackExecutor Executor Java的Executor，结果回调执行的线程池   validateEagerly boolean 是否提前验证的标志    通过 Builder 构造 Retrofit 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public Retrofit build() { // 请求构造器，默认为 OkHttpClient  okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { callFactory = new OkHttpClient(); } // 回调执行的线程池，默认为平台默认的，在 Android 上为 MainExecutor  Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) { callbackExecutor = platform.defaultCallbackExecutor(); } // 添加默认的 callAdapterFactor  List\u0026lt;CallAdapter.Factory\u0026gt; callAdapterFactories = new ArrayList\u0026lt;\u0026gt;(this.callAdapterFactories); callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters.  List\u0026lt;Converter.Factory\u0026gt; converterFactories = new ArrayList\u0026lt;\u0026gt;(1 + this.converterFactories.size()); // 添加自带的转换器，确保能转化所有类型  converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); // 构造 Retrofit 实例  return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); }   创建 Retrofit 实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { // 验证传入的参数是否是一个没有继承其他接口的接口  Utils.validateServiceInterface(service); // 如果设置了提前验证,会在 create 时就构造 serviceMethod，加入缓存.,  if (validateEagerly) { eagerlyValidateMethods(service); } // 返回一个代理对象  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class\u0026lt;?\u0026gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // If the method is a method from Object then defer to normal invocation.  // 比如 toString, hashCode, equal 等方法会直接反射调用  if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } // 如果是平台自有的方法，则通过平台调用  if (platform.isDefaultMethod(method)) { return platform.invokeDefaultMethod(method, service, proxy, args); } // 构造一个 serviceMethod 来执行真正的操作  return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); } } ); }   可以看出创建过程就是为我们定义的接口创建代理对象,当调用方法时通过代理对象\u0008去执行真正的操作.\nServiceMethod 在调用 Retrofit 的 create 最后,会调用 loadServiceMethod 返回 ServiceMethod 实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  ServiceMethod\u0026lt;?\u0026gt; loadServiceMethod(Method method) { ServiceMethod\u0026lt;?\u0026gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { // 通过 parseAnnotations 静态方法获得实例  result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); } } return result; }   parseAnnotations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  static \u0026lt;T\u0026gt; ServiceMethod\u0026lt;T\u0026gt; parseAnnotations(Retrofit retrofit, Method method) { // RequestFactory 里储存了请求相关的参数, HTTP Method, headers, contentType 等  RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); Type returnType = method.getGenericReturnType(); // 检查返回值类型  if (Utils.hasUnresolvableType(returnType)) { throw methodError(method, \u0026#34;Method return type must not include a type variable or wildcard: %s\u0026#34;, returnType); } // 返回值不能\u0008是 void,如需要可以使用 void 的包装类 Void  if (returnType == void.class) { throw methodError(method, \u0026#34;Service methods cannot return void.\u0026#34;); } // 返回 HtppServiceMethod  return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); }   HttpServiceMethod 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  static \u0026lt;ResponseT, ReturnT\u0026gt; HttpServiceMethod\u0026lt;ResponseT, ReturnT\u0026gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) { // 创建 CallAdapter  CallAdapter\u0026lt;ResponseT, ReturnT\u0026gt; callAdapter = createCallAdapter(retrofit, method); Type responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) { throw methodError(method, \u0026#34;\u0026#39;\u0026#34; + Utils.getRawType(responseType).getName() + \u0026#34;\u0026#39; is not a valid response body type. Did you mean ResponseBody?\u0026#34;); } // HEAD 请求的返回值必须是 Void 类型  if (requestFactory.httpMethod.equals(\u0026#34;HEAD\u0026#34;) \u0026amp;\u0026amp; !Void.class.equals(responseType)) { throw methodError(method, \u0026#34;HEAD method must use Void as response type.\u0026#34;); } // 创建 ResponseConverter  Converter\u0026lt;ResponseBody, ResponseT\u0026gt; responseConverter = createResponseConverter(retrofit, method, responseType); okhttp3.Call.Factory callFactory = retrofit.callFactory; return new HttpServiceMethod\u0026lt;\u0026gt;(requestFactory, callFactory, callAdapter, responseConverter); }   最终执行请求时,会走到 serviceMethod 的 invoke 处:\n1 2 3 4 5 6  @Override ReturnT invoke(Object[] args) { // 这里的 callAdapter 是从 Retrofit 的 callAdapterFactories 中找到匹配请求方法返回值的 callAdapter  // 不单独 addCallAdapterFactory 话,默认就是 platform 提供的  return callAdapter.adapt( new OkHttpCall\u0026lt;\u0026gt;(requestFactory, args, callFactory, responseConverter)); }   至此, Retrofit 就将\u0008 interface 定义的接口方法\u0008\u0008通过动态代理,转换成\u0008了匹配 interface 方法返回值的 CallAdapter.\nRxJava2CallAdapterFactory 常用的 RxJava2CallAdapterFactory, 会匹配返回值是 Observable, Single, Flowable Maybe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public CallAdapter\u0026lt;?, ?\u0026gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { Class\u0026lt;?\u0026gt; rawType = getRawType(returnType); if (rawType == Completable.class) { return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false, false, true); } boolean isFlowable = rawType == Flowable.class; boolean isSingle = rawType == Single.class; boolean isMaybe = rawType == Maybe.class; if (rawType != Observable.class \u0026amp;\u0026amp; !isFlowable \u0026amp;\u0026amp; !isSingle \u0026amp;\u0026amp; !isMaybe) { return null; } boolean isResult = false; boolean isBody = false; Type responseType; ... Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType); Class\u0026lt;?\u0026gt; rawObservableType = getRawType(observableType); if (rawObservableType == Response.class) { ... responseType = getParameterUpperBound(0, (ParameterizedType) observableType); } else if (rawObservableType == Result.class) { ... responseType = getParameterUpperBound(0, (ParameterizedType) observableType); isResult = true; } else { responseType = observableType; isBody = true; } return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, false); }   接口的 Proxy invoke 时会调到 adapt 方法,返回声明的返回值. RxJava2Adapter 这里可以返\u0008回几种\u0008 Observeable. 当对这些 Observable 进行 subscribe时, 会走到 CallExecuteObservable 或 CallEnqueueObservable 的 onSubscribeActual 方法.\n CallEnqueueObservable 里会调用 OkHttpCall 的 enqueue 异步发起请求 CallExecuteObservable 里会调用 OkHttpCall 的 execute 同步发起请求  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  @Override public Object adapt(Call\u0026lt;R\u0026gt; call) { Observable\u0026lt;Response\u0026lt;R\u0026gt;\u0026gt; responseObservable = isAsync ? new CallEnqueueObservable\u0026lt;\u0026gt;(call) : new CallExecuteObservable\u0026lt;\u0026gt;(call); Observable\u0026lt;?\u0026gt; observable; if (isResult) { observable = new ResultObservable\u0026lt;\u0026gt;(responseObservable); } else if (isBody) { observable = new BodyObservable\u0026lt;\u0026gt;(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return observable; }   ","description":"","id":72,"section":"posts","tags":null,"title":"Retrofit Source Code","uri":"https://jiyang.site/posts/2018-09-19-retrofit-source-code/"},{"content":"Step1 简单介绍 CoordinatorLayout  作用：协调子 View 使用核心: Behavior 布局属性类似 FrameLayout  Behavior 两个概念：\nChild：CoordinatorLayout 的子 View\nDependency：Child 依赖的 View\n简单使用：\n定义 Behavior\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class SimpleBehavior(context: Context, attrs: AttributeSet) : CoordinatorLayout.Behavior\u0026lt;Button\u0026gt;(context, attrs) { private val screenWidth: Int = context.resources?.displayMetrics?.widthPixels!! override fun layoutDependsOn(parent: CoordinatorLayout, child: Button, dependency: View): Boolean { //判断是否依赖的View \treturn dependency is WithFingerTextView } // 当依赖的 View 位置 宽高发生变化时，执行这个方法 \toverride fun onDependentViewChanged(parent: CoordinatorLayout, child: Button, dependency: View): Boolean { val x = screenWidth - dependency.x - child.width // 更新 Child \tsetPosition(child, x.toInt(), dependency.y.toInt()) return true } private fun setPosition(v: View, x: Int, y: Int) { val layoutParams: CoordinatorLayout.LayoutParams = v.layoutParams as CoordinatorLayout.LayoutParams layoutParams.leftMargin = x layoutParams.topMargin = y v.layoutParams = layoutParams\t} }   布局中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;android.support.design.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button\tandroid:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;A Button\u0026#34; app:layout_behavior=\u0026#34;com.jy.friendcircleappbar.SimpleBehavior\u0026#34; /\u0026gt; \u0026lt;com.jy.friendcircleappbar.WithFingerTextView android:id=\u0026#34;@+id/tv\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;wrap\u0026#34; android:layout_margin=\u0026#34;200dp\u0026#34;/\u0026gt; \u0026lt;/android.support.design.widget.CoordinatorLayout\u0026gt;   Step2 结合 AppBarLayout CollaspsingLayout Toolbar Toolbar 结合 AppBarLayout 才好玩 使用略过\nAppBarLayout  继承自 LinearLayout，垂直方向布局 当某个可滚动的View滚动时，可定制它内部的子 View 实现何种动作  AppBarLayout 子 View 的动作 给子 View 设置 layout_scrollFlags 属性:\n scroll：子 View 跟随滚动事件一起移动，类似将 View 嵌入 ScrollView scroll | enterAlways：当 ScollView 向下滚动时，View 直接向下滚动。ScrollView 向上滚动时，View 也跟着上滚 scroll | exitUnitCollaspsed：ScrollView 向上滚动时，View 先夺去滚动事件，滚到自己的最小高度，然后 ScrollView 接着滚动。ScrollView 向下滚动时，当 ScrollView 滚动到顶部时，View 开始滚动到默认高度。 scroll | enterAlawys | enterAllwaysCollapsed：  通过 appbar_scrolling_view_behavior 将 NestedScrollView 和 AppBarLayout 关联。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;android.support.design.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;android.support.v4.widget.NestedScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_behavior=\u0026#34;@string/appbar_scrolling_view_behavior\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/long_text\u0026#34; /\u0026gt; \u0026lt;/android.support.v4.widget.NestedScrollView\u0026gt; \u0026lt;android.support.design.widget.AppBarLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;android.support.v7.widget.Toolbar android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:minHeight=\u0026#34;?android:actionBarSize\u0026#34; app:layout_scrollFlags=\u0026#34;scroll|exitUntilCollapsed\u0026#34;/\u0026gt; \u0026lt;/android.support.design.widget.AppBarLayout\u0026gt; \u0026lt;/android.support.design.widget.CoordinatorLayout\u0026gt;    Step3 CollaspsingToolbarLayout\n针对 Toolbar\n 折叠 Title：当布局全部显示时 title 最大，随着上划逐步减小  setTitle   内容纱布：根据滚动的位置到达某个阈(yu)值，决定是否为 View 覆盖纱布  setContentScim   状态栏纱布：根据滚动的位置到达某个阈(yu)值，决定是否为状态栏覆盖纱布(5.0以上) 视差滚动子View：让子View的滚动速度比其他正常滚动的慢  layout_collapseModel:parallax   子 View 固定：Pin 模式  layout_collapseModel: pin    4 朋友圈 Toolbar 效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  \u0026lt;android.support.design.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:fitsSystemWindows=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;android.support.v7.widget.RecyclerView android:id=\u0026#34;@+id/list\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_behavior=\u0026#34;@string/appbar_scrolling_view_behavior\u0026#34; /\u0026gt; \u0026lt;android.support.design.widget.AppBarLayout android:id=\u0026#34;@+id/appBarLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;android.support.design.widget.CollapsingToolbarLayout android:id=\u0026#34;@+id/collapsing\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:collapsedTitleTextAppearance=\u0026#34;@style/CollapsedAppBar\u0026#34; app:contentScrim=\u0026#34;@android:color/white\u0026#34; app:expandedTitleMarginTop=\u0026#34;8dp\u0026#34; app:layout_scrollFlags=\u0026#34;scroll|exitUntilCollapsed\u0026#34; app:statusBarScrim=\u0026#34;@android:color/white\u0026#34;\u0026gt; \u0026lt;android.support.constraint.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_collapseMode=\u0026#34;pin\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@android:color/white\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:paddingBottom=\u0026#34;50dp\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:scaleType=\u0026#34;fitXY\u0026#34; android:src=\u0026#34;@mipmap/logo\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34; app:layout_constraintStart_toStartOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;FrameLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginEnd=\u0026#34;20dp\u0026#34; android:background=\u0026#34;@android:color/white\u0026#34; android:padding=\u0026#34;2dp\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintEnd_toEndOf=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:src=\u0026#34;@mipmap/logo\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/android.support.constraint.ConstraintLayout\u0026gt; \u0026lt;android.support.v7.widget.Toolbar android:id=\u0026#34;@+id/toolbar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:background=\u0026#34;@android:color/transparent\u0026#34; app:contentInsetLeft=\u0026#34;0dp\u0026#34; app:contentInsetRight=\u0026#34;0dp\u0026#34; app:contentInsetStart=\u0026#34;0dp\u0026#34; app:contentInsetStartWithNavigation=\u0026#34;0dp\u0026#34; app:layout_collapseMode=\u0026#34;pin\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;48dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@mipmap/back\u0026#34; /\u0026gt; \u0026lt;/android.support.v7.widget.Toolbar\u0026gt; \u0026lt;/android.support.design.widget.CollapsingToolbarLayout\u0026gt; \u0026lt;/android.support.design.widget.AppBarLayout\u0026gt; \u0026lt;/android.support.design.widget.CoordinatorLayout\u0026gt;   1 2 3 4 5 6 7 8 9  collapsingToolbarLayout.title = \u0026#34; \u0026#34; collapsingToolbarLayout.expandedTitleMarginStart = 0 appBarLayout.addOnOffsetChangedListener { appBarLayout, verticalOffset -\u0026gt; if (Math.abs(verticalOffset) \u0026gt;= appBarLayout.totalScrollRange) { collapsingToolbarLayout.title = \u0026#34;朋友圈\u0026#34; } else { collapsingToolbarLayout.title = \u0026#34; \u0026#34; } }   ","description":"","id":73,"section":"posts","tags":null,"title":"CoordinatorLayout Behavior","uri":"https://jiyang.site/posts/2018-09-07-coordinatorlayout-behavior/"},{"content":"简单的使用 RxJava，并结合线程切换:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  Observable.create(new ObservableOnSubscribe\u0026lt;Object\u0026gt;() { @Override public void subscribe(ObservableEmitter\u0026lt;Object\u0026gt; emitter) { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;[subscribe]\u0026#34; + Thread.currentThread().getName()); emitter.onNext(1); emitter.onNext(2); emitter.onNext(3); emitter.onComplete(); } }).subscribeOn(Schedulers.io()) .observeOn(AndroidScheduler.mainThread()) .subscribe(new Observer\u0026lt;Object\u0026gt;() { @Override public void onSubscribe(Disposable d) { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;[onSubscribe]\u0026#34; + Thread.currentThread().getName()); } @Override public void onNext(Object o) { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;[onNext]\u0026#34; + Thread.currentThread().getName()); } @Override public void onError(Throwable e) {} @Override public void onComplete() { Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;[onComplete]\u0026#34; + Thread.currentThread().getName()); } });   上次已经分析过不带线程的订阅和观察过程，现在直接从 subscribeOn 和 observerOn 开始分析。由上次得知 Observable.create 创建最后获得的是 ObservableCreate 被观察者对象。\n先分析 Observable.subscribeOn 1 2 3 4 5  public final Observable\u0026lt;T\u0026gt; subscribeOn(Scheduler scheduler) { ObjectHelper.requireNonNull(scheduler, \u0026#34;scheduler is null\u0026#34;); // 这里的 this 是上层的 ObservableCreate 对象，又添加一层封装，返回 ObservableSubscribeOn 对象  return RxJavaPlugins.onAssembly(new ObservableSubscribeOn\u0026lt;T\u0026gt;(this, scheduler)); }   看下 ObservableSubscribeOn 构造函数：\n1 2 3 4  public ObservableSubscribeOn(ObservableSource\u0026lt;T\u0026gt; source, Scheduler scheduler) { super(source); this.scheduler = scheduler; }   就是保存下 source 和被观察者的 scheduler。\n到这里，最初的 ObservableOnSubscribe 已经被包装了3层：\n然后到执行订阅的地方，事件的发出都是在订阅之后，所以来到 Observable.subscribe 方法，上篇也分析了最终会走到当前被观察者的 subscribeActual 方法，现在的被观察者被包装为了 ObservableSubscribeOn，\n所以直接到 ObservableSubscribeOn 的 subscribeActual 中：\n1 2 3 4 5 6 7 8  public void subscribeActual(final Observer\u0026lt;? super T\u0026gt; s) { // 将观察者包装一层  final SubscribeOnObserver\u0026lt;T\u0026gt; parent = new SubscribeOnObserver\u0026lt;T\u0026gt;(s); // 调用观察者的 onSubscribe，这里还没有进行线程切换，所以是发生在当前 Observable 被创建的线程  s.onSubscribe(parent); // 创建一个 SubscribeTask，然后由\u0008线程调度器调度执行。这里进行了线程的切换工作  parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); }   这里先将我们自己的观察者 Observer 包装为了 SubscribeOnObserver 对象。\n然后重要的是创建了一个 SubscribeTask，接着调用 scheduler.scheduDirect 执行。\n先看下 SubscribeTask 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13  final class SubscribeTask implements Runnable { private final SubscribeOnObserver\u0026lt;T\u0026gt; parent; SubscribeTask(SubscribeOnObserver\u0026lt;T\u0026gt; parent) { this.parent = parent; } @Override public void run() { // SubscribeTask 是 ObservableSubscribeOn 的内部类, 所以能直接访问 source 对象  source.subscribe(parent); } }   SubscribeTask 实现了 Runnable，并在 run() 中调用了被观察者的 Observeable.subscribe()，从而执行我们自己的事件发送代码。\n再看 scheduler.scheduDirect() 方法：\n1 2 3  public Disposable scheduleDirect(@NonNull Runnable run) { return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS); }   往下：\n1 2 3 4 5 6 7 8 9 10 11 12  public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { // 创建 worker  final Worker w = createWorker(); // 将传入的 Runnable 封装一层，实际还是传入的 Runnable  final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 将 worker 和 runnable 包装为 DisposeTask  DisposeTask task = new DisposeTask(decoratedRun, w); // 调用 worker 执行  w.schedule(task, delay, unit); return task; }   Scheduler 是个抽象类，createWorker 需要子类实现，就选常用的 IoScheduler 的 createWorker查看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  final AtomicReference\u0026lt;CachedWorkerPool\u0026gt; pool; public Worker createWorker() { // 创建一个 EventLoopWorker，并传入一个 Worker 缓存池  return new EventLoopWorker(pool.get()); } static final class EventLoopWorker extends Scheduler.Worker { private final CompositeDisposable tasks; private final CachedWorkerPool pool; private final ThreadWorker threadWorker; final AtomicBoolean once = new AtomicBoolean(); EventLoopWorker(CachedWorkerPool pool) { this.pool = pool; this.tasks = new CompositeDisposable(); // 从缓存中获取一个 Woker  this.threadWorker = pool.get(); } public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) { //...  // Runnable 交给 threadWorker 去执行，这里的 Runnable 的 run() 方法中执行的就是我们在被观察者发送事件的代码  return threadWorker.scheduleActual(action, delayTime, unit, tasks); } }   看下 CachedWorkerPool Worker 缓存池的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static final class CachedWorkerPool implements Runnable { //...  ThreadWorker get() { if (allWorkers.isDisposed()) { return SHUTDOWN_THREAD_WORKER; } while (!expiringWorkerQueue.isEmpty()) { // 如果缓存池不空，就取一个 threadWorker  ThreadWorker threadWorker = expiringWorkerQueue.poll(); if (threadWorker != null) { return threadWorker; } } // 如果空的，就创建一个新的  ThreadWorker w = new ThreadWorker(threadFactory); allWorkers.add(w); return w; } }   继续看 threadWorker.schedulerActual 实现，ThreadWorker没有实现这个方法，看下它的父类 NewThreadWorker：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public class NewThreadWorker extends Scheduler.Worker implements Disposable { public NewThreadWorker(ThreadFactory threadFactory) { // 构造时获取一个 ScheduledExecutorService  executor = SchedulerPoolFactory.create(threadFactory); } public ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) { // \u0008还是传入的 runnable 对象  Runnable decoratedRun = RxJavaPlugins.onSchedule(run); // 将 decoratedRun 包装为一个新的 runnable  ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent); Future\u0026lt;?\u0026gt; f; try { if (delayTime \u0026lt;= 0) { // 线程池中立即执行  f = executor.submit((Callable\u0026lt;Object\u0026gt;)sr); } else { // 延迟执行  f = executor.schedule((Callable\u0026lt;Object\u0026gt;)sr, delayTime, unit); } } catch (RejectedExecutionException ex) { //...  } return sr; } }   到这里，SubscribeTask 的 run() 方法最终会在线程池中被执行，也就是我们在 subscribe 方法中写的发送事件的代码\u0008在这里执行。\nobserverOn 操作 上面的栗子中，是这样的:\n1 2  // 指定观察者在 Android Main Thread 接受事件结果 .observeOn(AndroidScheduler.mainThread())   Observable类的 observeOn()方法：\n1 2 3 4 5 6 7 8 9  public final Observable\u0026lt;T\u0026gt; observeOn(Scheduler scheduler) { return observeOn(scheduler, false, bufferSize()); } public final Observable\u0026lt;T\u0026gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) { //...  // 将自身包装为新的被观察者对象，因为进行 subscribeOn 时也包装了一层，所以现在一共4层了  return RxJavaPlugins.onAssembly(new ObservableObserveOn\u0026lt;T\u0026gt;(this, scheduler, delayError, bufferSize)); }   ObservableObserveOn 类：\n1 2 3 4 5 6  public ObservableObserveOn(ObservableSource\u0026lt;T\u0026gt; source, Scheduler scheduler, boolean delayError, int bufferSize) { super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize; }   就是存一些属性。\n然后就是一样的操作，直接来到订阅的地方，ObservableObserveOn 的 subscribeActual：\n1 2 3 4 5 6 7 8 9 10 11 12 13  protected void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer) { if (scheduler instanceof TrampolineScheduler) { // 如果是当前线程，直接执行上一层的 subsribe  // 执行最里面的 ObservableSubscribeOn 的 subscribe() 方法  source.subscribe(observer); } else { // 创建 worker，栗子中的 scheduler 是 AndroidSchedulers.mainThread()  Scheduler.Worker w = scheduler.createWorker(); // 执行subscribe()，这里是在上面提到的 SubscribeTask 的 run() 中执行  // 将观察者包装为 ObserveOnObserver  source.subscribe(new ObserveOnObserver\u0026lt;T\u0026gt;(observer, w, delayError, bufferSize)); } }   加上上面的 subscribeOn 操作，观察者已经被包装了2层：\nsource.subscribe() 中将会把事件通过 onNext onError onComplete 方法发送出去，所以看下 ObserveOnObserver 的 onNext：\n1 2 3 4 5 6 7 8  public void onNext(T t) { if (sourceMode != QueueDisposable.ASYNC) { // 将结果存入队列  queue.offer(t); } // 调用 schedule()  schedule(); }   ObserveOnObserver 的 schdule 方法：\n1 2 3 4 5 6 7 8  void schedule() { if (getAndIncrement() == 0) { // ObserveOnObserver 实现了 Runnable 接口，所以把自己交给 worker 去执行  // 这里的 worker 由 Android MainThread Schduler 提供，它实际是通过向 Android MainThread 的 Looper 发送 Message 实现的线程切换。  // 构造 callback 为 this 的 Message 发送到主线程，主线程消费这条消息时，就执行 callback 的 run() 方法，即这里 this 对象 ObserveOnObserver 的 run() 方法 。  worker.schedule(this); } }   ObserveOnObserver 实现了 Runnable 接口，所以它的 run() 方法将会在主线程调用。\nObserveOnObserver 的 run() 方法:\n1 2 3 4 5 6 7 8  public void run() { // outputFused 默认为 false  if (outputFused) { drainFused(); } else { drainNormal(); } }   ObserveOnObserver 的 drainNormal() 方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  void drainNormal() { // 存消息的队列  final SimpleQueue\u0026lt;T\u0026gt; q = queue; // 上层观察者，SubscribeOnObserver  final Observer\u0026lt;? super T\u0026gt; a = actual; for (;;) { for (;;) { T v; try { // 从队列取消息  v = q.poll(); } catch (Throwable ex) { //...  return; } //...  // 调用 SubscribeOnObserver 的 onNext()  a.onNext(v); } //...  } }   SubscribeOnObserver 的 onNext 没做特别的事情，就是调用原始观察者的 onNext：\n1 2 3 4 5 6 7 8 9 10 11 12  static final class SubscribeOnObserver\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;Disposable\u0026gt; implements Observer\u0026lt;T\u0026gt;, Disposable { SubscribeOnObserver(Observer\u0026lt;? super T\u0026gt; actual) { this.actual = actual; this.s = new AtomicReference\u0026lt;Disposable\u0026gt;(); } @Override public void onNext(T t) { actual.onNext(t); } }   因此 Observer 的 onNext() 就会在 Android 的主线程执行了。其他的 onError onComplete 与 onNext 类似。\n","description":"RxJava 如何做到线程切换的","id":74,"section":"posts","tags":["Rx"],"title":"RxJava's Thread Dispatch","uri":"https://jiyang.site/posts/2018-08-13-rxjava-thread-dispatch/"},{"content":"众所周知 RxJava 是基于观察者模式的响应式编程框架。其中主要有2个主要对象：\n Observable 被观察者 Observer 观察者  不带线程切换的基本用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  Observable\u0026lt;Integer\u0026gt; observable = Observable.create(new ObservableOnSubscribe\u0026lt;Integer\u0026gt;() { @Override public void subscribe(ObservableEmitter\u0026lt;Integer\u0026gt; emitter) { emitter.onNext(1); emitter.onComplete(); } }); Observer\u0026lt;Integer\u0026gt; observer = new Observer\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(Integer o) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }; observable.subscribe(observer);   好了，一般创建被观察者都是使用静态方法 Observable.create 传递一个 ObservableOnSubscribe 对象。\n来，看 Observable 的 create 方法： 1 2 3 4  public static \u0026lt;T\u0026gt; Observable\u0026lt;T\u0026gt; create(ObservableOnSubscribe\u0026lt;T\u0026gt; source) { ObjectHelper.requireNonNull(source, \u0026#34;source is null\u0026#34;); return RxJavaPlugins.onAssembly(new ObservableCreate\u0026lt;T\u0026gt;(source)); }   查看参数 ObservableOnSubscribe 类：\n1 2 3 4 5 6  public interface ObservableOnSubscribe\u0026lt;T\u0026gt; { /** * Called for each Observer that subscribes. */ void subscribe(@NonNull ObservableEmitter\u0026lt;T\u0026gt; emitter) throws Exception; }   它就是一个接口，有一个 subscribe 方法需要具体实现。\n再看 RxJavaPlugins.onAssembly (onAssembly 上面栗子的情况下，没有特殊作用，传什么对象，返回什么对象):\n1 2 3 4 5 6 7  public static \u0026lt;T\u0026gt; Observable\u0026lt;T\u0026gt; onAssembly(@NonNull Observable\u0026lt;T\u0026gt; source) { Function\u0026lt;? super Observable, ? extends Observable\u0026gt; f = onObservableAssembly; if (f != null) { return apply(f, source); } return source; }   看 onAssembly 的参数， ObservableCreate 类：\n1 2 3 4 5 6 7 8  public final class ObservableCreate\u0026lt;T\u0026gt; extends Observable\u0026lt;T\u0026gt; { final ObservableOnSubscribe\u0026lt;T\u0026gt; source; public ObservableCreate(ObservableOnSubscribe\u0026lt;T\u0026gt; source) { this.source = source; } .... }   它继承自 Observable ，并通过构造函数将 ObservableOnSubscribe 保存为自己的属性。\n所以在创建 Observable 对象的过程中，进行了1次包装，最终返回了一个 ObservableCreate 被观察者对象：\n看 Observable 的 subscribe 方法 主要代码如下：\n1 2 3 4 5 6 7 8 9 10  public final void subscribe(Observer\u0026lt;? super T\u0026gt; observer) { try { observer = RxJavaPlugins.onSubscribe(this, observer); subscribeActual(observer); } catch (NullPointerException e) { throw e; } catch (Throwable e) { RxJavaPlugins.onError(e); } }   subscribe 方法需要接收一个 Observer 对象，看下 Observer：\n1 2 3 4 5 6 7 8 9 10  public interface Observer\u0026lt;T\u0026gt; { void onSubscribe(@NonNull Disposable d); void onNext(@NonNull T t); void onError(@NonNull Throwable e); void onComplete(); }   是个接口，观察者实例需要实现这几个方法。\n然后继续 subscribe 方法：\nRxJavaPlugins.onSubscribe(this, observer):\n1 2 3 4 5 6 7  public static \u0026lt;T\u0026gt; Observer\u0026lt;? super T\u0026gt; onSubscribe(@NonNull Observable\u0026lt;T\u0026gt; source, @NonNull Observer\u0026lt;? super T\u0026gt; observer) { BiFunction\u0026lt;? super Observable, ? super Observer, ? extends Observer\u0026gt; f = onObservableSubscribe; if (f != null) { return apply(f, source, observer); } return observer; }   没有做特别的，直接返回传进去的 Observer。\n接着看 subscribeActual:\n1  protected abstract void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer);   唉，需要子类实现。回顾上面 Observable.create 的过程，我们创建的 Observable 实际是 ObservableCreate 对象，所以到 ObservableCreate 里看 subscribeActual方法的具体实现：\n1 2 3 4 5 6 7 8 9 10 11  protected void subscribeActual(Observer\u0026lt;? super T\u0026gt; observer) { CreateEmitter\u0026lt;T\u0026gt; parent = new CreateEmitter\u0026lt;T\u0026gt;(observer); observer.onSubscribe(parent); try { source.subscribe(parent); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); parent.onError(ex); } }   里面调用了 observer.onSubscribe(parent) 方法。 parent 是一个 CreateEmitter 对象。\n 看下 CreateEmitter 的源码，发现它实现了 ObservableEmitter 接口和 Disposable 接口，所以它可以多态转为 ObservableEmitter 和 Disposable 实例对象。\n 继续， observer.onSubscribe(parent) 就是回调观察者的 onSubscribe，并将 CreateEmitter 转为 Disposable 对象传递。\n然后 source.subscribe(parent) 是调用被观察者的 subscribe 方法，并将 CreateEmitter 转为 ObservableEmitter 对象传递。\n从上面知道 source 就是 ObservableCreate 类保存的 ObservableOnSubscribe 对象，是最上面栗子里创建的被观察者，所以source.subscribe(parent) 就走到了栗子里的代码：\n1 2 3 4  public void subscribe(ObservableEmitter\u0026lt;Integer\u0026gt; emitter) { emitter.onNext(1); emitter.onComplete(); }   这里我调用了 emitter 的 onNext 和 onComplete 方法。看下 CreateEmitter 具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76  static final class CreateEmitter\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;Disposable\u0026gt; implements ObservableEmitter\u0026lt;T\u0026gt;, Disposable { private static final long serialVersionUID = -3434801548987643227L; final Observer\u0026lt;? super T\u0026gt; observer; CreateEmitter(Observer\u0026lt;? super T\u0026gt; observer) { this.observer = observer; } @Override public void onNext(T t) { if (t == null) { return; } if (!isDisposed()) { observer.onNext(t); } } @Override public void onError(Throwable t) { if (!tryOnError(t)) { RxJavaPlugins.onError(t); } } @Override public boolean tryOnError(Throwable t) { if (t == null) { t = new NullPointerException(\u0026#34;onError ...\u0026#34;); } if (!isDisposed()) { try { observer.onError(t); } finally { dispose(); } return true; } return false; } @Override public void onComplete() { if (!isDisposed()) { try { observer.onComplete(); } finally { dispose(); } } } @Override public void setDisposable(Disposable d) { DisposableHelper.set(this, d); } @Override public void setCancellable(Cancellable c) { setDisposable(new CancellableDisposable(c)); } @Override public void dispose() { DisposableHelper.dispose(this); } @Override public boolean isDisposed() { return DisposableHelper.isDisposed(get()); } }   原来 emitter 的 onNext 内会直接调用 观察者的 onNext， emitter 的 onComplete 内直接调用观察者的 onComplete。这里没有涉及线程的切换，所以所有操作都是在同一个线程进行。CreateEmitter 还有其他几个方法：\n onError(Throwable t) 在 emitter 发出 error 事件时调用 dispose() 取消这次订阅，\u0008在 onNext onError onComplete 中都会先判断是否已经 dispose，如果 dispose 了，就不会回调观察者的对应方法。  总结 在不使用 RxJava 的线程切换功能下分析了被观察者的创建和订阅观察者的流程。 主要涉及了 Observable、ObservableOnSubscribe、ObservableCreate、Observer(接口)、CreateEmitter。当被观察者的 subscribe 调用之后，就会走到 ObservableOnSubscribe 的 subscribe，从而触发 emitter 发送事件，emitter 发送事件之后，又由 emitter 调用观察者的对应事件回调方法。\n","description":"RxJava 观察者和被观察者的创建流程, 以及如何做到通知观察者的","id":75,"section":"posts","tags":["Rx"],"title":"RxJava Observer Observable(Not With Thread Dispatch) Source Code","uri":"https://jiyang.site/posts/2018-08-10-rxjava-observer-observable/"},{"content":"大学的第一堂哲学课，教授拿出一个空的透明罐子。说：“人的一生都要活一次，虽然对于广大的宇宙来说我们不过是一个小小过客，但我们有能力去完成任何事情。真的，任何事情。如果，我们善用时间的话。”\n然后教授向瓶子装满了高尔夫球，教授问在座的同学：“这罐子满了吗？”。同学们回答：“满了”。\n接着教授向瓶子倒了一些小石子，石子填满了高尔夫球之间的空隙，教授问在座的同学：“现在满了吗？”。同学们回答：“满了”。\n然后教授又向瓶子倒了一些沙子，摇了摇罐子，沙子填满了小石子之间的空隙。教授问在座的同学：“那现在呢？这罐子满了吗？”。同学们回答：“满了”。\n接着教授拿出了两瓶啤酒，开了一瓶向罐子到了一些，直到罐子完全铺平。现在罐子真的完全满了。\n教授说：“现在我要你们把这个罐子想像成自己的人生，高尔夫球代表着重要的事情，包括你的家庭，你的健康，你的热情；小石头代表着其他重要的事，像你的车子、工作、房屋\u0026hellip;；沙子就是其他东西，一些小事。如果把沙子先倒进了罐子内，你就没有空间放小石子或高尔夫球了。人生也是一样的道理。如果你把所有时间与精力都耗在小事上，你就不会有时间去在意真正重要的事情，专注那些真正能让你感到高兴的事。先把高尔夫球顾好，也就是真正重要的事，把优先事项列好。因为其他东西都只是沙子而已。啤酒\u0026hellip;代表不管你的生活多么紧凑，依然有空挡和朋友把酒言欢。”\n 高尔夫球：重要的事情 小石头：其他重要的事 沙子： 其他东西，一些小事 啤酒：空挡时间 ","description":"","id":76,"section":"posts","tags":["计划"],"title":"一个罐子，一堂人生哲学","uri":"https://jiyang.site/posts/2018-08-05-%E4%B8%80%E4%B8%AA%E7%BD%90%E5%AD%90%E4%B8%80%E5%A0%82%E4%BA%BA%E7%94%9F%E5%93%B2%E5%AD%A6/"},{"content":"树莓派控制继电器，从而控制大电流的通与断。\u0008\n树莓派控制 写一个通用的向树莓派针脚输出电位的脚本 output2pin ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #! /bin/bash # Useage: # output2pin.sh [gpio_number] [1/0] if [ $# != 2 ] then echo \u0026#34;Must have 2 args! Now have $#args.\u0026#34; exit 0 fi echo \u0026#34;Will out put $2to pin-$1\u0026#34; echo $1 \u0026gt; /sys/class/gpio/export echo out \u0026gt; /sys/class/gpio/gpio$1/direction echo $2 \u0026gt; /sys/class/gpio/gpio$1/value echo \u0026#39;Output finish!\\n\u0026#39;   如上图连接 26 号针脚，输出高电平就是：\n1  sudo output2pin 26 1    这里的 gpio_number 规则是 https://www.raspberrypi.org/documentation/usage/gpio/ 里的 GPIO 相对编码: 连接图中的 GPIO26 对应的硬编码序号是 37.\n 继电器 1路继电器的输出端一般有3个口：\n 常闭：高电位或继电器不通电时接通 常开：低电位时接通 公用：一般直接连接电源 ","description":"","id":77,"section":"posts","tags":null,"title":"树莓派控制继电器","uri":"https://jiyang.site/posts/2018-07-22-%E6%A0%91%E8%8E%93%E6%B4%BE%E6%8E%A7%E5%88%B6%E7%BB%A7%E7%94%B5%E5%99%A8/"},{"content":"经常使用 Context.getSystemService(String name) 获取一些系统服务。 其实这些服务都是以单例的方式注册在系统中的。 获取到的都是单例对象。\nLayoutInflater 为例 在 View 中经常通过 LayoutInflater.from(Context context) 获取 LayoutInflater 对象，查看方法实现：\n1 2 3 4 5 6 7 8  public static LayoutInflater from(Context context) { LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(\u0026#34;LayoutInflater not found.\u0026#34;); } return LayoutInflater; }   内部是调用的 Context 的 getSystemService(String key) 方法，查看 Context 类发现是个抽象方法，需要子类实现：\n1  public abstract @Nullable Object getSystemService(@ServiceName @NonNull String name);   View 中的 Context 通常就是 Activity，Android 中在 Application，Activity，Service 中都存在 Context。一个应用中: Context 总数 = Activity 数 + Service 数 + 1 ( Application )。\n所以从 Activity 的 Context 中分析 getSystemService 实现，先分析 Activity 的 Context 是在哪创建的。\nActivity 的入口是 ActivityThread 的 main 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public static void main(String[] args) { ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \u0026#34;ActivityThread\u0026#34;)); } ... Looper.loop(); throw new RuntimeException(\u0026#34;Main thread loop unexpectedly exited\u0026#34;); }   创建 MainLooper，创建 ActivityThread 对象 ，启动 Looper 消息循环。ActivityThread 的 attach 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } ...... }   不是系统应用(boolean system)会通过 Binder 机制与 ActivityManagerService 通信，最终调用 handleLaunchActivity，里面又会调用 performLaunchActivity 方法：\n1 2 3 4 5 6 7 8 9 10 11 12  private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... ActivityInfo aInfo = r.activityInfo; ... ContextImpl appContext = createBaseContextForActivity(r); ... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); ... }   ActivityThread createBaseContextForActivity 方法：\n1 2 3 4 5 6 7 8 9 10  private ContextImpl createBaseContextForActivity(ActivityClientRecord r) { final int displayId; try { displayId = ActivityManager.getService().getActivityDisplayId(r.token); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } ContextImpl appContext = ContextImpl.createActivityContext(this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig); ... }   performLaunchActivity 里创建了 ContextImpl 对象，Context 的具体实现就是 ComtextImpl 了。查看 ContextImpl 里 getSystemService 实现：\n1 2 3  public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); }   ContextImpl 里通过 SystemServiceRegistry 的类方法获取服务，查看 SystemServiceRegistry 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  final class SystemServiceRegistry { private static final String TAG = \u0026#34;SystemServiceRegistry\u0026#34;; // Service registry information.  // This information is never changed once static initialization has completed.  private static final HashMap\u0026lt;Class\u0026lt;?\u0026gt;, String\u0026gt; SYSTEM_SERVICE_NAMES = new HashMap\u0026lt;Class\u0026lt;?\u0026gt;, String\u0026gt;(); private static final HashMap\u0026lt;String, ServiceFetcher\u0026lt;?\u0026gt;\u0026gt; SYSTEM_SERVICE_FETCHERS = new HashMap\u0026lt;String, ServiceFetcher\u0026lt;?\u0026gt;\u0026gt;(); private static int sServiceCacheSize; private SystemServiceRegistry() { } // 静态代码块，类加载时就执行  static { registerService(Context.ACCESSIBILITY_SERVICE, AccessibilityManager.class, new CachedServiceFetcher\u0026lt;AccessibilityManager\u0026gt;() { @Override public AccessibilityManager createService(ContextImpl ctx) { return AccessibilityManager.getInstance(ctx); }}); registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class, new CachedServiceFetcher\u0026lt;LayoutInflater\u0026gt;() { @Override public LayoutInflater createService(ContextImpl ctx) { return new PhoneLayoutInflater(ctx.getOuterContext()); }}); ... } // 获取服务  public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher\u0026lt;?\u0026gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } }   静态代码块里注册了很多服务， LayoutInflater 也是在这里注册的， 看到 LayoutInflater 的实现类是 PhoneLayoutInflater。\nPhoneLayoutInflater 获得了 LayoutInflater 之后，就该调用 inflate 加载，查看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, \u0026#34;INFLATING from resource: \\\u0026#34;\u0026#34; + res.getResourceName(resource) + \u0026#34;\\\u0026#34; (\u0026#34; + Integer.toHexString(resource) + \u0026#34;)\u0026#34;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); } }   继续查看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // 查找根节点  int type; while ((type = parser.next()) != XmlPullParser.START_TAG \u0026amp;\u0026amp; type != XmlPullParser.END_DOCUMENT) { // Empty  } final String name = parser.getName(); // 解析 merge 标签  if (TAG_MERGE.equals(name)) { rInflate(parser, root, inflaterContext, attrs, false); } else { // 从 xml 中\u0008构造 View  final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; ... if (root != null \u0026amp;\u0026amp; attachToRoot) { root.addView(temp, params); } if (root == null || !attachToRoot) { result = temp; } ... rInflateChildren(parser, temp, attrs, true); ... } } ... return result; } }   调用 createViewFromTag :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { if (name.equals(\u0026#34;view\u0026#34;)) { name = attrs.getAttributeValue(null, \u0026#34;class\u0026#34;); } ... if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { if (-1 == name.indexOf(\u0026#39;.\u0026#39;)) { //内置控件解析  view = onCreateView(parent, name, attrs); } else { //自定义控件解析  view = createView(name, null, attrs); } } finally { mConstructorArgs[0] = lastContext; } } return view; ... }    解析内置控件：调用 onCreateView 解析自定义控件：直接调用 createView(name, null, attrs);  前面分析了，Activity 的 Context 返回的 LayoutInflater 对象的具体实现是 PhoneLayoutInflater，查看源码，发现其复写了 onCreateView 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public class PhoneLayoutInflater extends LayoutInflater { private static final String[] sClassPrefixList = { \u0026#34;android.widget.\u0026#34;, \u0026#34;android.webkit.\u0026#34;, \u0026#34;android.app.\u0026#34; }; ... /** Override onCreateView to instantiate names that correspond to the widgets known to the Widget factory. If we don\u0026#39;t find a match, call through to our super class. 复写 LayoutInflater 的 onCreateView */ @Override protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException { for (String prefix : sClassPrefixList) { try { View view = createView(name, prefix, attrs); if (view != null) { return view; } } catch (ClassNotFoundException e) { // In this case we want to let the base class take a crack  // at it.  } } return super.onCreateView(name, attrs); } }   所以，在 PhoneLayoutInflater 解析内置控件时，会\u0008使用3种前缀。\ncreateView 在 LayoutInflater 中实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException { //先根据类名从缓存中\u0008获取构造器  Constructor\u0026lt;? extends View\u0026gt; constructor = sConstructorMap.get(name); if (constructor != null \u0026amp;\u0026amp; !verifyClassLoader(constructor)) { constructor = null; sConstructorMap.remove(name); } Class\u0026lt;? extends View\u0026gt; clazz = null; try { // 如果构造函数不存在，就通过反射获取构造函数  if (constructor == null) { clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null \u0026amp;\u0026amp; clazz != null) { boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) { failNotAllowed(name, prefix, attrs); } } constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); } } ... //构造View  final View view = constructor.newInstance(args); if (view instanceof ViewStub) { final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); } return view; }   这样就成功从 xml 构造了一个根\u0008 View，接着就会调用 rInflateChildren 创建子 View。 rInflateChildren 调用 rInflate：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException { //获得布局深度  final int depth = parser.getDepth(); int type; boolean pendingRequestFocus = false; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() \u0026gt; depth) \u0026amp;\u0026amp; type != XmlPullParser.END_DOCUMENT) { if (type != XmlPullParser.START_TAG) { continue; } final String name = parser.getName(); //requestFocus 标签  if (TAG_REQUEST_FOCUS.equals(name)) { pendingRequestFocus = true; consumeChildElements(parser); //tag 标签  } else if (TAG_TAG.equals(name)) { parseViewTag(parser, parent, attrs); //include 标签  } else if (TAG_INCLUDE.equals(name)) { if (parser.getDepth() == 0) { throw new InflateException(\u0026#34;\u0026lt;include /\u0026gt; cannot be the root element\u0026#34;); } parseInclude(parser, context, parent, attrs); //merge 标签  } else if (TAG_MERGE.equals(name)) { throw new InflateException(\u0026#34;\u0026lt;merge /\u0026gt; must be the root element\u0026#34;); //普通 View 标签  } else { final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //递归调用  rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); } } if (pendingRequestFocus) { parent.restoreDefaultFocus(); } if (finishInflate) { parent.onFinishInflate(); } }   ","description":"","id":78,"section":"posts","tags":null,"title":"Android 源码中的单例模式","uri":"https://jiyang.site/posts/2018-07-21-android-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"content":"ListView 的视图循环使用机制主要实现自内部的 RecyclerBin。\n通过 ListView 的继承关系，可以看出它继承自 AbsListView，是个 ViewGroup。ViewGroup 的绘制流程无非就是 measure -\u0026gt; layout -\u0026gt; draw。\nListView 中实现了自己的 onMeasure\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  if (widthMode == MeasureSpec.UNSPECIFIED) { widthSize = mListPadding.left + mListPadding.right + childWidth + getVerticalScrollbarWidth(); } else { widthSize |= (childState \u0026amp; MEASURED_STATE_MASK); } if (heightMode == MeasureSpec.UNSPECIFIED) { heightSize = mListPadding.top + mListPadding.bottom + childHeight + getVerticalFadingEdgeLength() * 2; } if (heightMode == MeasureSpec.AT_MOST) { heightSize = measureHeightOfChildren(widthMeasureSpec, 0, NO_POSITION, heightSize, -1); }   没什么特别的，把各种尺寸和子View的measure求和。然后在 ListView 中没有发现 onLayout，进入 AbsListView 查看。\n1 2 3 4 5 6 7 8 9  protected void onLayout(boolean changed, int l, int t, int r, int b) { super.onLayout(changed, l, t, r, b); mInLayout = true; ...... layoutChildren(); ...... mInLayout = false; }   会调用 layoutChildren，ListView 中实现了这个方法。直接到核心步骤。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  ...... final int firstPosition = mFirstPosition; final RecycleBin recycleBin = mRecycler; if (dataChanged) { for (int i = 0; i \u0026lt; childCount; i++) { recycleBin.addScrapView(getChildAt(i), firstPosition+i); } } else { recycleBin.fillActiveViews(childCount, firstPosition); } // Clear out old views detachAllViewsFromParent(); recycleBin.removeSkippedScrap(); switch (mLayoutMode) { ...... default: if (childCount == 0) { if (!mStackFromBottom) { final int position = lookForSelectablePosition(0, true); setSelectedPositionInt(position); sel = fillFromTop(childrenTop); } else { final int position = lookForSelectablePosition(mItemCount - 1, false); setSelectedPositionInt(position); sel = fillUp(mItemCount - 1, childrenBottom); } } else { if (mSelectedPosition \u0026gt;= 0 \u0026amp;\u0026amp; mSelectedPosition \u0026lt; mItemCount) { sel = fillSpecific(mSelectedPosition, oldSel == null ? childrenTop : oldSel.getTop()); } else if (mFirstPosition \u0026lt; mItemCount) { sel = fillSpecific(mFirstPosition, oldFirst == null ? childrenTop : oldFirst.getTop()); } else { sel = fillSpecific(0, childrenTop); } } break; } recycleBin.scrapActiveViews();    childCount mStackFromBottom: AbsListView 中的属性，默认为 false，表示列表将会从上到下的填充，反之从下到上填充  不单独调用 setStackFromBottom(true)的话， ListView 就会从上到下开始填充，调用 fillFromTop，接着调用 fillDown\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  private View fillDown(int pos, int nextTop) { View selectedView = null; int end = (mBottom - mTop); if ((mGroupFlags \u0026amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) { end -= mListPadding.bottom; } while (nextTop \u0026lt; end \u0026amp;\u0026amp; pos \u0026lt; mItemCount) { // is this the selected item?  boolean selected = pos == mSelectedPosition; View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected); nextTop = child.getBottom() + mDividerHeight; if (selected) { selectedView = child; } pos++; } setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1); return selectedView; }   fillDown 里循环进行了 子View 的填充。\n end: ListView 的高度 nextTop: 表示单个 子View的顶部 相对于 ListView 的位置高度 pos: 进入 ListView 的第一个位置，默认为 0，没填充一个子 View 就 +1  循环条件 nextTop \u0026lt; end \u0026amp;\u0026amp; pos \u0026lt; mItemCount：ListView 的高度要大于下一个子 View 的顶部位置 \u0026amp;\u0026amp; pos 要小于 adapter 里返回的 ItemCount。这样就确保 ListView 只会填充一定数量，它自身高度能够显示完全\u0008的子 View。\n进入 makeAndAddView 方法中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  private View makeAndAddView(int position, int y, boolean flow, int childrenLeft, boolean selected) { if (!mDataChanged) { // Try to use an existing view for this position.  final View activeView = mRecycler.getActiveView(position); if (activeView != null) { // Found it. We\u0026#39;re reusing an existing child, so it just needs  // to be positioned like a scrap view.  setupChild(activeView, position, y, flow, childrenLeft, selected, true); return activeView; } } // Make a new view for this position, or convert an unused view if  // possible.  final View child = obtainView(position, mIsScrap); // This needs to be positioned and measured.  setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]); return child; }   如果数据没有改变，会先从 recycler 中\u0008获取与指定位置对应的视图，如果找到了就\u0008直接设置然后返回;没找到就会调用 AbsListView 的 obtainView 获取一个 View，然后设置。\n 未完待续\n","description":"","id":79,"section":"posts","tags":null,"title":"ListView原理分析","uri":"https://jiyang.site/posts/2018-07-12-listview%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"content":"ViewGroup 作为父控件可以包含多个 View 控件，并管理其包含的 View 控件。上层控件负责下层控件的测量和绘制，并传递交互事件。常用的 findViewById 就是以深度优先的方式遍历查找对应元素。\n每个 Activity 都包含一个 Window 对象，Window 的具体实现是 PhoneWindow。 PhoneWindow 将一个 DecorView 作为窗口界面的顶层视图，DecorView 将要显示的具体内容呈现在了 PhoneWindow 上，里面的所有 View 的监听事件，都通过 WindowManagerService 进行接收，并通过 Activity 对象回调对应的 onEventListener。\nView 测量模式   EXACTLY: 精确模式，layout_width/layout_height 为具体数值时，或为 match_parent 时\n  AT_MOST: 最大模式，layout_width/layout_height 为 wrap_content 时，View 的大小不超过父控件大小即可\n  UNSPECIFIED: 不指定大小的测量模式\n  View 的默认 onMeasure() 方法只支持 EXACTLY 模式，所以自定义的控件，一般都需要重写 onMeasure() 让自定义 View 支持 wrap_content 属性。\n1 2 3 4  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); }   View 的默认 onMeasure 实现里，最终会调用 setMeasuredDimension 将测量后的宽高设置进去，从而完成测量工作。所以重写 onMeasure 方法之后，最终需要把宽高参数通过 setMeasuredDimension 设置。\nViewGroup 的测量  当 ViewGroup 的大小为 wrap_content 时，ViewGroup 就需要对子 View 进行遍历，获取所有子 View 的大小，从而来决定自己的大小。  View 的绘制 View 绘制时系统会调用 onDraw()方法，重写该方法就可以实现绘制。onDraw()有一个参数Canvas canvas对象。使用这个对象，在onDraw()里就可以进行绘图的操作。但在其他地方，通常需要创建一个 Canvas对象。\n1  Canvas canvas = new Canvas(bitmap);   查看 Canvas 的这个构造函数签名可以看到:\n1 2 3 4 5 6 7 8 9 10  /** * Construct a canvas with the specified bitmap to draw into. The bitmap must be mutable. * * The initial target density of the canvas is the same as the given bitmap\u0026#39;s density. * * @param bitmap Specifies a mutable bitmap for the canvas to draw into. */ public Canvas(@NonNull Bitmap bitmap) { ... }   传进去的 bitmap 就是为了 canvas 的绘制。这个 bitmap 用来存储所有绘制在 Canvas 上的像素信息。Canvas.drawXXX 方法都会发生在 bitmap 上。\n 这样就可以通过不同的 canvas 绘制在同一个 bitmap 上。\n View 事件传递 对于 ViewGroup 主要有3个相关方法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @Override public boolean dispatchTouchEvent(MotionEvent ev) { Log.d(TAG, name + \u0026#34; ViewGroup dispatchTouchEvent\u0026#34;); return super.dispatchTouchEvent(ev); } @Override public boolean onInterceptTouchEvent(MotionEvent ev) { Log.d(TAG, name + \u0026#34; ViewGroup onInterceptTouchEvent\u0026#34;); return super.onInterceptTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent ev) { Log.d(TAG, name + \u0026#34; ViewGroup onTouchEvent\u0026#34;); return super.onTouchEvent(ev); }   View 主要有2个相关方法:\n1 2 3 4 5 6 7 8 9 10 11  @Override public boolean dispatchTouchEvent(MotionEvent ev) { Log.d(TAG, \u0026#34;View dispatchTouchEvent\u0026#34;); return super.dispatchTouchEvent(ev); } @Override public boolean onTouchEvent(MotionEvent ev) { Log.d(TAG, \u0026#34;View onTouchEvent\u0026#34;); return super.onTouchEvent(ev); }   点击一次 MyView 之后的日志:\nActivity dispatchTouchEvent A ViewGroup dispatchTouchEvent A ViewGroup onInterceptTouchEvent B ViewGroup dispatchTouchEvent B ViewGroup onInterceptTouchEvent View dispatchTouchEvent View onTouchEvent B ViewGroup onTouchEvent A ViewGroup onTouchEvent Activity onTouchEvent ","description":"","id":80,"section":"posts","tags":null,"title":"Android控件架构","uri":"https://jiyang.site/posts/2018-07-09-android%E6%8E%A7%E4%BB%B6%E6%9E%B6%E6%9E%84/"},{"content":" 继承 View 实现 ProgressBar, 练习使用 Kotlin\n  参考 https://github.com/lingochamp/MagicProgressWidget\n 一些方法说明: canvas clipRect 1 2  canvas.clipRect(RectF rect) canvas.clipRect(RectF rect, Region.Op op)   裁剪画布，设置画布的显示区域，调用 clipRect 之后，只会显示被裁剪的区域，之外的区域不会显示。只对clipRect 之后的绘制操作有效\n1 2 3 4 5 6 7  paint.isAntiAlias = true paint.color = Color.BLACK paint.textSize = 30.0F canvas.clipRect(100F, 100F, 350F, 600F, Region.Op.INTERSECT); canvas.drawColor(Color.RED); canvas.drawCircle(100F, 100F, 100F, paint);   裁剪参数:\n DIFFERENCE是第一次不同于第二次的部分显示出来 REPLACE是显示第二次的 REVERSE_DIFFERENCE 是第二次不同于第一次的部分显示 INTERSECT交集显示(默认) UNION全部显示 XOR补集 就是全集的减去交集剩余部分显示  canvas save 1 2  canvas.save() canvas.restore()   save() 用来保存 canvas 的状态，restore() 用来恢复 canvas到 save() 时的状态。例如对画布进行了旋转、缩放操作之后，画布坐标就变了，然后想继续使用正常的画布坐标，就可以使用: save() -\u0026gt; 操作 -\u0026gt; restore() -\u0026gt; 继续操作。\n绘制 SimpleProgressBar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  class SimpleProgressBar : View { constructor(context: Context) : super(context) constructor(context: Context, attributeSet: AttributeSet) : super(context, attributeSet) constructor(context: Context, attributeSet: AttributeSet, defaultAttr: Int) : super(context, attributeSet, defaultAttr) private var mAnimator: ValueAnimator? = null private var currentPresent = 0F private lateinit var mRectF: RectF private val backPaint = Paint() private val fillPaint = Paint() private var backColor = Color.GRAY set(value) { field = value invalidate() } private var fillColor = Color.RED set(value) { field = value invalidate() } init { backPaint.color = backColor backPaint.isAntiAlias = true backPaint.style = Paint.Style.FILL fillPaint.color = fillColor fillPaint.isAntiAlias = true fillPaint.style = Paint.Style.FILL setPercent(0.6F) } fun setPercent(percent: Float, duration: Long = 2000L) { mAnimator?.cancel() mAnimator = ValueAnimator.ofFloat(currentPresent, percent) mAnimator?.duration = duration mAnimator?.addUpdateListener({ currentPresent = it.animatedValue as Float invalidate() }) mAnimator?.start() } private var mWidth: Int = 0 private var mHeight: Int = 0 private var radius: Float = 0F override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) { super.onSizeChanged(w, h, oldw, oldh) mRectF = RectF( paddingLeft.toFloat(), paddingTop.toFloat(), (w - paddingRight).toFloat(), (h - paddingBottom).toFloat()) mWidth = w - paddingLeft - paddingRight mHeight = h - paddingTop - paddingBottom radius = mHeight / 2F } override fun onDraw(canvas: Canvas) { super.onDraw(canvas) //draw background rect  canvas.save() mRectF.right = mWidth.toFloat() canvas.drawRoundRect(mRectF, radius, radius, backPaint) //draw fill progress  val fillWidth = mWidth * currentPresent when { fillWidth \u0026gt; 0F \u0026amp;\u0026amp; fillWidth \u0026lt; radius * 2 -\u0026gt; { mRectF.right = fillWidth canvas.clipRect(mRectF) mRectF.right = radius * 2 canvas.drawRoundRect(mRectF, radius, radius, fillPaint) } fillWidth \u0026gt; radius -\u0026gt; { mRectF.right = fillWidth canvas.drawRoundRect(mRectF, radius, radius, fillPaint) } } canvas.restore() } }   ","description":"","id":81,"section":"posts","tags":null,"title":"绘制SimpleProgressBar","uri":"https://jiyang.site/posts/2018-06-05-%E7%BB%98%E5%88%B6simpleprogressbar/"},{"content":"今天才搞懂 Flask 自带的 session 竟然是完全依靠客户端的。\n 当写入值到 session 中后， session 就会比加密成一个字符串，然后写入到 cookie 里 当一个请求来时，获取请求的 cookie 里拿到 session 字符串，然后解析到 session 字典里  之前还使用自带的 session 做用户登录，现在看来不安全，用户是否登录完全依赖了客户端呀。本以为 Flask 自带的 session 是储存在内存中的，结果现在清楚了，内存中没有存，都是每次从请求的 cookie 中拿到，然后解析成 dict.\n使用 session 的代码:\n1 2 3 4 5 6 7 8 9 10 11  def login(): data = request.json password = data.get(\u0026#39;password\u0026#39;) account = data.get(\u0026#39;account\u0026#39;) user = UserDao.get_by_args(password, account) if not user: return jsonify(status=\u0026#39;false\u0026#39;, message=u\u0026#39;密码错误\u0026#39;), 401 session[user[\u0026#39;id\u0026#39;]] = user[\u0026#39;name\u0026#39;] resp = Response(json.dumps({\u0026#39;status\u0026#39;: \u0026#39;ok\u0026#39;, \u0026#39;user\u0026#39;: user}), mimetype=\u0026#39;application/json\u0026#39;) set_cookie(resp, \u0026#39;u_id\u0026#39;, str(user[\u0026#39;id\u0026#39;]), max_age=USER_LOGIN_MAX_AGE) return resp   登录验证:\n 这个验证就没有什么意义了，如果cookie中有 u_id，那么 session 中就一定有 u_id \u0026hellip;. 因为 session 就是从 cookie 来的\n 1 2 3 4 5 6 7 8 9  def authorize(func): @wraps(func) def wrapper(*args, **kwargs): u_id = request.cookies.get(\u0026#39;u_id\u0026#39;) authorized = u_id and session.get(u_id) if not authorized: return jsonify(message=u\u0026#34;需要登录\u0026#34;), 401 return func(*args, **kwargs) return wrapper   看来登录验证不能使用这个 session 简单的判断了，需要通过其他方式存储登录成功的 u_id，比如存到 Redis\n结合 Redis 改进之后的:\n1 2 3 4 5 6 7 8 9 10 11  def login(): data = request.json password = data.get(\u0026#39;password\u0026#39;) account = data.get(\u0026#39;account\u0026#39;) user = UserDao.get_by_args(password, account) if not user: return jsonify(status=\u0026#39;false\u0026#39;, message=u\u0026#39;密码错误\u0026#39;), 401 resp = Response(json.dumps({\u0026#39;status\u0026#39;: \u0026#39;ok\u0026#39;, \u0026#39;user\u0026#39;: user}), mimetype=\u0026#39;application/json\u0026#39;) set_cookie(resp, \u0026#39;u_id\u0026#39;, str(user[\u0026#39;id\u0026#39;]), max_age=USER_LOGIN_MAX_AGE) redis_client.sadd(\u0026#39;logined_user_ids\u0026#39;, user[\u0026#39;id\u0026#39;]) return resp   1 2 3 4 5 6 7 8 9  def authorize(func): @wraps(func) def wrapper(*args, **kwargs): u_id = request.cookies.get(\u0026#39;u_id\u0026#39;) authorized = u_id and redis_client.sismember(\u0026#39;logined_user_ids\u0026#39;, u_id) if not authorized: return jsonify(message=u\u0026#34;需要登录\u0026#34;), 401 return func(*args, **kwargs) return wrapper   ","description":"","id":82,"section":"posts","tags":null,"title":"Flask自带的Session","uri":"https://jiyang.site/posts/2018-05-28-flask%E8%87%AA%E5%B8%A6%E7%9A%84session/"},{"content":" 单词高亮的TextView控件。额，为什么做这个\u0026hellip;. 好吧，之前面试时公司要求的题目\n  特定词组高亮显示(中文/英文) 单词自动换行 高亮词组保持在同一行显示  继承自 View 实现，文本都是使用画布画上去。使用两支画笔表示默认文本和高亮文本。\n文本分组实现 ExtendText 表示文本单元是否高亮 1 2 3 4 5 6 7 8  private class ExtendText { String textUnit; boolean isHighlight; ExtendText(String textUnit, boolean isHighlight) { this.textUnit = textUnit; this.isHighlight = isHighlight; } }    将原文中匹配给定的高亮词组的前后加 # 号 根据 # 号将原文 split 成数组 遍历数组，构造 ExtendText 数组  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public void setDisplayedText(final String text, final List\u0026lt;String\u0026gt; highlighted) { if (TextUtils.isEmpty(text)) { return; } String s = text; String[] words; extendTexts.clear(); if (highlighted != null) { for (String str : highlighted) { s = s.replaceAll(str, \u0026#34;#\u0026#34; + str + \u0026#34;#\u0026#34;); } words = s.split(\u0026#34;#\u0026#34;); for (String str : words) { boolean isHighlight = highlighted.contains(str); if (isHighlight) { ExtendText t = new ExtendText(str, true); extendTexts.add(t); } else { for (String word : Arrays.asList(str.split(\u0026#34; \u0026#34;))) { ExtendText tt = new ExtendText(word + \u0026#34; \u0026#34;, false); extendTexts.add(tt); } } } } else { words = s.split(\u0026#34; \u0026#34;); for (String str : words) { ExtendText t = new ExtendText(str, false); extendTexts.add(t); } } requestLayout(); invalidate(); }   控件不同情况下尺寸确定  在这里也学习了自定义 View 里的尺寸测量方法\n View 的测量模式有3种:\n UNSPECIFIED: 表示视图的尺寸未指明，比如 wrap_content 模式下，如果此时父容器也是wrap_content(比如父容器的 ScrollView)，则需要自己计算 View 的实际占用值 AT_MOST: 表示视图的尺寸最多达到多少，比如 match_content，一般取测量值和View实际占用值的最小值 EXACTLY: 表示视图的尺寸是确定的，比如 layout_width=\u0026quot;100dp\u0026quot;，一般直接返回测量值  首先是 onMeasure 里根据测量值和测量模式获取实际需要绘制的宽高\n1 2 3 4 5 6 7  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); width = measureWithSize(MeasureSpec.getSize(widthMeasureSpec), widthMeasureSpec); width -= (getPaddingRight() + getPaddingLeft()); int height = measureHeightSize(heightMeasureSpec); setMeasuredDimension(width, height); }   测量宽度 1 2 3 4 5 6 7 8 9 10 11 12  private int measureWithSize(int defaultSize, int measureSpec) { int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: case MeasureSpec.AT_MOST: return Math.min(defaultSize, specSize); case MeasureSpec.EXACTLY: return specSize; } return defaultSize; }   测量高度 高度的测量比宽度多了UNSPECIFIED模式下，自己测量了View需要的高度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  private int measureHeightSize(int measureSpec) { int result; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); //确保layout_height为wrap_content时所占高度合适  int wrapHeight = (int) (getPaddingTop() + dfPaint.getTextSize() + getPaddingBottom()); float x_draw = getPaddingLeft(); for (ExtendText t : extendTexts) { Paint paint = t.isHighlight ? hlPaint : dfPaint; float textLen = paint.measureText(t.textUnit); if (x_draw + textLen \u0026gt; width) { x_draw = getPaddingLeft(); wrapHeight += paint.getTextSize(); } x_draw += textLen; } result = wrapHeight; switch (specMode) { case MeasureSpec.UNSPECIFIED: //父控件为Scrollview情况，直接使用wrapHeight  break; case MeasureSpec.AT_MOST: result = Math.min(result, specSize); break; case MeasureSpec.EXACTLY: result = specSize; } return result; }   绘制时自动换行 使用 Pain.measureText测量画笔绘制文本将要的宽度，然后与空间的宽度比较判断是否需要换行，换行就增加 y 方向的坐标值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  protected void onDraw(Canvas canvas) { super.onDraw(canvas); float x_draw = getPaddingLeft(); float y_draw = getPaddingTop() + dfPaint.getTextSize(); for (ExtendText t : extendTexts) { Paint paint = t.isHighlight ? hlPaint : dfPaint; float textLen = paint.measureText(t.textUnit); if (x_draw + textLen \u0026gt; width) { x_draw = getPaddingLeft(); y_draw += paint.getTextSize(); } canvas.drawText(t.textUnit, x_draw, y_draw, paint); x_draw += textLen; } }   ","description":"","id":83,"section":"posts","tags":null,"title":"单词高亮TextView","uri":"https://jiyang.site/posts/2018-05-25-%E5%8D%95%E8%AF%8D%E9%AB%98%E4%BA%AEtextview/"},{"content":"权限字符 1  drwxrwxrwx   拆分为4部分，d rwx rwx rwx，分别表示：文件类型、属主权限(文件拥有者)、属组权限(与文件拥有者同用户组的其他用户)、其他用户组用户权限\n权限具体意义和数值:\n x 可执行 1 w 可写 2 r 可读 4  使用3者数值的和，表示一个用户的权限。比如某个文件的权限为 777，代表所有用户对该都具有读、写、执行的三种权限。\n例如 755  属主 读、写、执行 1+2+4 属组 读、执行 1+4 其他 读、执行 1+4  为何是 1 2 4 表示  1、2、4使用2进制表示很方便 2进制表示方便对权限的验证  要验证用户是否拥有某个权限，只需判断 用户权限值 \u0026amp;(与运算) 权限数值 的结果是否不为 0。\n 例如：权限值为7:  7\u0026amp;1=1 != 0  表示拥有 执行 权限\n0000 00111 ---------- 0000 00001 = 0000 00001 = 1 != 0 7\u0026amp;2=2 != 0  表示拥有 写 权限\n0000 00111 ---------- 0000 00010 = 0000 00010 =2 !=0 7\u0026amp;4=4 !=0  表示拥有 读 权限\n 权限值为5:  5\u0026amp;1=1 !=0  拥有 执行 权限\n5\u0026amp;2=0 ==0 没有 写 权限\n0000 00101 ---------- 0000 00010 = 0000 00000 = 0 == 0 =\u0026gt; 无该权限 5\u0026amp;4=4 != 0 拥有 读 权限\n","description":"","id":84,"section":"posts","tags":null,"title":"Linux 权限 124","uri":"https://jiyang.site/posts/2018-05-21-linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90124/"},{"content":"参照 https://ubuntu.pkgs.org/17.10/webupd8-amd64/winusb_3.1.4-1~webupd8~artful0_all.deb.html\n 安装  1 2 3  sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get update sudo apt-get install winusb   启动。安装之后程序名是 WoeUSB   选择镜像文件 选择目标设备(U盘) 然后 Install   如果报错 Target device is currently busy 确保没有其他程序使用设备之后，把 U 盘格式化为 NTFS 格式。参照 https://github.com/slacka/WoeUSB/issues/112\n 重启电脑，从 U 盘启动安装 ","description":"","id":85,"section":"posts","tags":null,"title":"Ubuntu制作windows启动盘-WoeUSB","uri":"https://jiyang.site/posts/2018-04-27-ubuntu%E5%88%B6%E4%BD%9Cwindows%E5%90%AF%E5%8A%A8%E7%9B%98-woeusb/"},{"content":"Python 中现在存在两种类的定义方式:\n 1 旧式  1 2 3 4  class A(): def foo(self): print(\u0026#39;A foo\u0026#39;)    2 新式( Python 3 默认的方式)  1 2 3 4  class A(object): def foo(self): print(\u0026#39;A foo\u0026#39;)   今天在其他文章里看到说两者的区别: 查找方法的算法不一样。\n旧式类是 深度优先, 新式类是 广度优先。\n 深度优先: 和树的 先序遍历 类似 广度优先：和树的 层序遍历 类似  深度优先: D -\u0026gt; B -\u0026gt; A -\u0026gt; C\n广度优先: D -\u0026gt; B -\u0026gt; C -\u0026gt; A\n两个简单的例子看区别:\n Python 2.x 环境下\n  旧式类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class A(): def foo(self): print(\u0026#39;a foo\u0026#39;) class B(A): pass class C(A): def foo(self): print(\u0026#39;c foo\u0026#39;) class D(B,C): pass D().foo() # 输出: a foo    新式类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class A(object): def foo(self): print(\u0026#39;a foo\u0026#39;) class B(A): pass class C(A): def foo(self): print(\u0026#39;c foo\u0026#39;) class D(B,C): pass D().foo() # 输出: c foo   ","description":"","id":86,"section":"posts","tags":null,"title":"Python新旧类的方法查找区别","uri":"https://jiyang.site/posts/2018-04-20-python%E6%96%B0%E6%97%A7%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E6%9F%A5%E6%89%BE%E5%8C%BA%E5%88%AB/"},{"content":" ADB:Android Debug Bridge 是能够和手机或模拟器通信的一个命令行工具。下载地址\n 命令分类 1. ADB Debugging 1  adb devices 输出连接的模拟器/真机列表   1  adb forward tcp:8000 tcp:9000 实现PC和Android设备Socket通信   1  adb kill-server 关闭adb服务   2. 连接设备 1  adb connect 192.168.0.101 使用WIFI连接设备,connect设备的ip地址   1  adb usb 使用usb连接模式   3. 包管理 adb install 1  adb install test.apk 安装应用到设备   1  adb install -l test.apk 对应用加锁   1  adb install -r test.apk 如果安装的应用已经存在，卸载已经存在的   1  adb install -t test.apk 允许安装测试包   1  adb install -s test.apk 将应用安装到SD卡   1  adb install -d test.apk 允许安装低版本   1  adb install -p test.apk 安装应用的局部    各项参数可以结合使用\n 1  adb install -r -t test.apk   adb uninstall 删除一个应用包\n1  adb uninstall com.test.app 卸载应用   1  adb uninstall -k com.test.app 卸载应用，保存数据和缓存目录   adb shell pm list package 输出所有应用包名，可以追加选项过滤\n1  adb shell pm list packages 输出所有应用包名   1  adb shell pm list packages -f 输出所有应用包名和应用的安装位置 例如📦/data/app/io.github.jiyangg.app/base.apk=io.github.jiyangg.app   1  adb shell pm list packages -d 输出禁用的应用包名   1  adb shell pm list packages -e 输出可以使用的应用的包名   1  adb shell pm list packages -s 输出系统应用包名   1  adb shell pm list packages -3 输出第三方应用包名   1  adb shell pm list packages -i 输出应用包名和安装器   1  adb shell pm list packages -u 输出包括已经卸载的应用包名   1  adb shell pm list packages --user \u0026lt;USER_ID\u0026gt; 输出制定用户空间的应用包名    选项命令可以结合使用\n 1  adb shell pm list packages -3 -f 查看第三方应用的安装位置和包名   adb shell pm path 根据包名显示APK存放位置\n1  adb shell pm path com.android.phone   adb shell pm clear 删除指定包名的所有数据，包括data和cache\n1  adb shell pm clear com.test.abc   4. 文件管理 adb pull adb pull \u0026lt;remote\u0026gt; [local]\n从设备下载文件到电脑\n1  adb pull /sdcard/test.mp4 下载SD卡根目录test.mp4到电脑的当前目录下   1  adb pull /sdcard/test.mp4 d: 下载SD卡根目录test.mp4到电脑的指定目录d盘下   adb push adb push \u0026lt;local\u0026gt; \u0026lt;remote\u0026gt;\n从电脑复制文件到设备\n1  adb push test.apk /sdcard 将电脑当前目录下test.apk文件复制到设备SD卡根目录   1  adb push d:\\test.apk /sdcard 将电脑d盘目录下test.apk文件复制到设备SD卡根目录   adb shell ls 输出文件列表\n ls 输出文件列表，不包含隐藏文件 ls -a 输出文件列表，包含隐藏文件 ls -i 输出文件列表，包含文件下标 ls -s 输出文件列表，包含文件的大小 ls -n 输出文件列表，包含文件的UID,GID ls -R 递归列出子目录  adb shell rm 删除文件\n rm -f 强制删除文件 rm -r 递归删除文件夹的文件 rm -d 删除文件夹,即使非空.(==rmdir) rm -i 删除前提示  adb shell mkdir 创建目录\n mkdir /sdcard/tmp mkdir -m 777 /sdcard/tmp 创建并设置权限 mkdir -p /sdcard/tmp/sub1/sub2 根据需要创建父目录  adb shell touch 新建文件 adb shell pwd 返回当前路径 adb shell cp 复制文件 adb shell mv 移动或重命名文件 5. 网络 1  adb shell netstat 网络信息统计   1  adb shell netcfg 查看网络连接信息,通过配置文件管理   adb shell ip ip [ OPTIONS ] OBJECT\nOBJECT := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp } OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]} 1  adb shell ip -f inet addr show wlan0 显示WIFI的ip地址   6. Logcat 打印日子到屏幕\nadb logcat [option] [filter-specs] 1  adb logcat 打印所有日志   根据不同的级别打印日志，日志级别:V \u0026lt; D \u0026lt; I \u0026lt; W \u0026lt; E\n V : Verbose 详细 D : Debug I :Info W :Warn E : Error  1 2 3 4 5 6 7  adb logcat *:V 显示V,D,I,W,E级别日志 adb logcat *:D 显示D,I,W,E级别日志 adb logcat *:I 显示I,W,E级别日志 adb logcat *:W 显示W,E级别日志 adb logcat *:E 显示E级别日志 adb logcat *:F 显示致命级别日志 adb logcat *:S 沉默级别，不显示任何日志   adb logcat -b \u0026lt;Buffer\u0026gt; 查看缓冲区信息\n1  adb logcat -b main 默认，查看全部缓冲区   1  adb logcat -b radio 查看包含无线电/电话相关消息的缓冲区   1  adb logcat -b event 查看包含事件相关消息的缓冲区   1  adb logcat -c 清除整个日志并退出   1  adb logcat -d 将日志全部打印到屏幕并退出   1  adb logcat -f test.logs 将日志写入到文件test.logs   1  adb logcat -g 输出日志缓冲区大小并退出   1  adb logcat -n \u0026lt;count\u0026gt;   1  adb logcat -r \u0026lt;kbytes\u0026gt; 日志文件每次的输出，需要结合 -f   ","description":"","id":87,"section":"posts","tags":null,"title":"ADB-Shell-Commands","uri":"https://jiyang.site/posts/2017-08-22-adb-shell-commands/"},{"content":"在 Android 中，一次点击完成实际会产生多个事件，比如一个按钮的点击是: TouchDown → TouchUp → 按钮的 onClickListener 回调触发。\nTouch Down Event Touch Down 事件在Parent View 和 View 是否是 clickable 的情况下都会产生和分发。\n TouchEvent 由 Activity 传递到父 ViewGroup，父ViewGroup的 dispatchTouchEvent 中执行事件的分发流程，返回 true 代表事件被消费了，不会再向下走，返回 false 就走 onInterceptTouchEvent 流程。 父 ViewGroup 的 onInterceptTouchEvent的返回值决定是否传递到子 View。  注: ClickListener 在 TouchUp 事件触发之后才会回调\nTouch Up Event 情况一    View isClickable     Parent true   Child true    Parent 和 Child 都是 clickable 的：事件传递到 Child View 的onTouchEvent 里会执行 onClickListener.onClick ，然后事件被消费；如果 Child View 的 onTouchEvent 返回了 false，则会执行 Parent 的 onTouchEvent，进而执行 Parent 的 onClick 。\n一次点击事件的日志:\nActivity dispatchTouchEvent: action_down EventLayout dispatchTouchEvent EventLayout onInterceptTouchEvent EventButton dispatchTouchEvent: action_down EventButton onTouchEvent: action_down ----------------Touch Up------------------- Activity dispatchTouchEvent: action_up EventLayout dispatchTouchEvent EventLayout onInterceptTouchEvent EventButton dispatchTouchEvent: action_up EventButton onTouchEvent: action_up EventButton onClick 情况二    View isClickable     Parent false   Child true    执行 Child View 的 onClick 或者 Child View 的 onTouchEvent 返回了 false，执行 Parent 的 onTouchEvent，由于 clickable == false, 就由返回值决定是否将事件传递到外层 Activity。\n","description":"","id":88,"section":"posts","tags":null,"title":"Android TouchEvent Dispatch 再分析","uri":"https://jiyang.site/posts/2017-06-07-android-touchevent-dispatch-%E5%86%8D%E5%88%86%E6%9E%90/"},{"content":"LRU 算法描述 当序列达到设置的内存上限时, 丢弃序列中最近最少使用的元素.\nLruCache  Android SDK 提供的使用了(Least Recently Used)最近最少使用算法的缓存类.\n 编写一个 LruCache, 用于缓存 Integer.\n1 2 3 4 5 6 7 8 9 10  public class IntegerCache extends LruCache\u0026lt;String, Integer\u0026gt; { public IntegerCache(int maxSize) { super(maxSize); } @Override protected int sizeOf(String key, Integer value) { return Integer.SIZE; } }   1 2 3 4 5 6 7 8 9 10  // 最大容量为 4 个 Integer IntegerCache ca = new IntegerCache(4 * Integer.SIZE) ca.put(\u0026#34;1\u0026#34;, 1); ca.put(\u0026#34;2\u0026#34;, 2); ca.put(\u0026#34;3\u0026#34;, 3); ca.put(\u0026#34;4\u0026#34;, 4); ca.get(\u0026#34;4\u0026#34;); ca.put(\u0026#34;5\u0026#34;, 5); ca.put(\u0026#34;4\u0026#34;, 4); ca.put(\u0026#34;6\u0026#34;, 6);   缓存中内容:\n1 2 3 4 5 6 7 8 9  {1=1} // put 1 {1=1, 2=2} // put 2 {1=1, 2=2, 3=3} // put 3 {1=1, 2=2, 3=3, 4=4} // put 4 --- {1=1, 2=2, 3=3, 4=4} // get 4 {2=2, 3=3, 4=4, 5=5} // put 5 {2=2, 3=3, 5=5, 4=4} // put 4 {3=3, 5=5, 4=4, 6=6} // put 6   可见, 每次的 get 和 put 操作, 都会造成序列中的重排序, 最近使用的元素在末尾, 最近最少使用的元素在头部, 当容量超过限制时会移出最近最少使用的元素.\nLruCache 的构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class LruCache\u0026lt;K, V\u0026gt; { // 构造时就初始化的一个 LinkedHashMap  private final LinkedHashMap\u0026lt;K, V\u0026gt; map; private int size; /* 记录当前缓存占用的内存大小 */ private int maxSize; /* 最多能缓存的内存大小 */ private int putCount; /* 记录 put 调用的次数 */ private int createCount; /* 记录 create 调用的次数 */ private int evictionCount; /* 记录被丢弃的对象个数 */ private int hitCount; /* 记录调用 get 时,缓存命中的次数 */ private int missCount; /* 记录调用 get 时,缓存未命中的次数 */ public LruCache(int maxSize) { if (maxSize \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;maxSize \u0026lt;= 0\u0026#34;); } this.maxSize = maxSize; // 初始容量为0, 扩容系数为 0.75, 排序模式: true 表示按访问排序, false 表示按插入排序, SDK 实现里固定为 ture  this.map = new LinkedHashMap\u0026lt;K, V\u0026gt;(0, 0.75f, true); }   LruCache 插入元素 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public final V put(K key, V value) { V previous; synchronized (this) { putCount++; // 内存占用记录增加  size += safeSizeOf(key, value); // 存入新的值, 并获取 key 对应的旧值  previous = map.put(key, value); if (previous != null) { // 如果旧值存在, 就减去对应内存  size -= safeSizeOf(key, previous); } } // 如果 size \u0026gt; maxSize, 就执行丢弃元素, 裁剪内存操作  trimToSize(maxSize); return previous; }   LurCache 获取缓存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  public final V get(K key) { V mapValue; synchronized (this) { // 从缓存中获取 key 对应的 value, 如果存在就直接返回  mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } // 如果缓存中没有, 就尝试创建一个对应对象, 该方法由子类实现, 可以返回 null  V createdValue = create(key); if (createdValue == null) { return null; } // 如果子类 create 返回了非 null 对象, 就把这个对象返回, 并插入到缓存中  synchronized (this) { createCount++; mapValue = map.put(key, createdValue); // 上面 get 时得到了 null 才会走到这, 怎么在插入时旧值又跑出来了 ?  if (mapValue != null) { // 这里应该是避免多线程访问时, 在 get 获取为 null 之后, 其他线程插入了对应的值, 所以这里把其他线程插入的值还原回去  map.put(key, mapValue); } else { // 如果没有其他插入, 就把新创建的内存占用记账  size += safeSizeOf(key, createdValue); } } ... }   以上就是 LruCache 里主要的方法了, 看完也没发现与 LRU 算法有关的东西, 那 LRU 的具体实现肯定就在 LinkedHashMap 里了.\nLinkedHashMap 的实现  内部数据结构: 双向链表  1 2 3 4 5 6 7  // LinkedHashMap 的节点数据结构, 继承自 HashMap.Node static class LinkedHashMapEntry\u0026lt;K,V\u0026gt; extends HashMap.Node\u0026lt;K,V\u0026gt; { LinkedHashMapEntry\u0026lt;K,V\u0026gt; before, after; LinkedHashMapEntry(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { super(hash, key, value, next); } }   构造 1 2 3 4 5 6 7  public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) { super(initialCapacity, loadFactor); // accessOrder 决定内部的排序顺序  this.accessOrder = accessOrder; }   获取操作 1 2 3 4 5 6 7 8 9 10 11  public V get(Object key) { Node\u0026lt;K,V\u0026gt; e; // 调用父类 HashMap 的方法  if ((e = getNode(hash(key), key)) == null) return null; // 如果按访问顺序排序为 ture, 则进行重排序  if (accessOrder) // 将 e 移动到最后  afterNodeAccess(e); return e.value; }   可以看到, 重点就是 afterNodeAccess 这个方法.\n访问 node 之后的排序操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  void afterNodeAccess(Node\u0026lt;K,V\u0026gt; e) { // move node to last  LinkedHashMapEntry\u0026lt;K,V\u0026gt; last; if (accessOrder \u0026amp;\u0026amp; (last = tail) != e) { LinkedHashMapEntry\u0026lt;K,V\u0026gt; p = (LinkedHashMapEntry\u0026lt;K,V\u0026gt;)e, /* p 指向当前节点 e */ b = p.before, /* b 指向前一个节点 */ a = p.after; /* a 指向后一个节点 */ p.after = null; /* 当前节点 after 置 null */ if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } }   Case 1: 访问元素的前后存在元素    初始状态 移动指向 最终结果           Case 1.2: 访问元素的前后存在多个元素    初始状态 移动指向 最终结果           Case 2: 访问元素的后面存在元素, 前面不存在    初始状态 移动指向 最终结果           Case 3: 访问元素的前面存在元素, 后面不存在 这种 case 不会做排序操作, 因为元素已经位于链表尾部了.\n在访问元素之后, 通过 afterNodeAccess 排序之后, 被访问的元素就移动到了链表的尾部.\n插入操作 LinkedHashMap 的 put 操作是直接调用父类 HashMap 的, HashMap 的 put 操作之后, 被插入的元素将会位于链表的尾部, 然后会调用 afterNodeInsertion, 该方法在 LinkedHashMap 中的实现:\n1 2 3 4 5 6 7 8 9  void afterNodeInsertion(boolean evict) { // possibly remove eldest  LinkedHashMapEntry\u0026lt;K,V\u0026gt; first; // 如果 removeEldestEntry 为 true, 则移出头部的元素  // LinkedHashMap 中 removeEldestEntry 默认返回 false  if (evict \u0026amp;\u0026amp; (first = head) != null \u0026amp;\u0026amp; removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } }   由于 LinkedHashMap 中 removeEldestEntry 默认返回 false, 所以 LinkedHashMap 的插入操作, 默认不会移出元素, 移出元素的操作实际在 LruCache 中的 trimToSize 实现.\n 在获取和插入之后, LinkedHashMap 中的元素排列就会是: 最近最多使用的位于尾部, 最近最少使用的位于头部.\n LruCache 的 trimToSize trimToSize 目的在于当缓存大于设置的最大内存时, 会移出最近最少使用到的元素(在 LinkedHashMap 中就是头部的元素):\nandroidxref 上的源码实现:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size \u0026lt;= maxSize) { break; } // 该方法会返回 LinkedHashMap 的头节点  Map.Entry\u0026lt;K, V\u0026gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); // 移出这个节点  map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } }   总结   Android 提供的 LruCache 基于 LinkedHashMap 实现, 利用 LinkedHashMap 会在每次访问元素之后, 将元素移动到序列末尾的特点, 保证了最近最多使用的元素位于尾部, 最近最少使用的元素位于头部.\n当缓存占用达到设置的上限时, LruCache 就会移出 LinkedHashMap 中的头节点.\n  LinkedHashMap 扩展 HashMap, 实现了一套双向链表机制, 保证了在元素的移动上和元素的查找上的时间复杂度都为 $ O(1) $.\n  ","description":"通过使用 LruCache, 查看 LinkedHashMap 源码, 分析 LRU 算法的具体实现细节.","id":89,"section":"posts","tags":["缓存算法"],"title":"LruCache缓存机制实现原理","uri":"https://jiyang.site/posts/2017-05-24-lrucache%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"content":"拍了 100 多张之后，终于拍到了几张闪电。\n","description":"9栋窗台，室友陪伴，苦苦守候，只为闪光瞬间！","id":90,"section":"posts","tags":["雷电"],"title":"拍摄闪电⚡️","uri":"https://jiyang.site/posts/2015-04-01-%E6%8B%8D%E6%91%84%E9%97%AA%E7%94%B5%EF%B8%8F/"},{"content":" Android提供了MediaPlayer播放器播放媒体文件，其实MediaPlyer只是对Android Media包下的MediaCodec和MediaExtractor进行了包装，方便使用。但是最好理解下Android媒体文件的解码，编码和渲染流程。\n  Shape Of My Heart.mp4\n  使用android.media包下的MediaCodec和MediaExtractor实现一个简单的视频解码渲染。\n使用到了:\n MediaCodec:负责媒体文件的编码和解码工作，内部方法均为native MediaExtractor:负责将指定类型的媒体文件从文件中找到轨道，并填充到MediaCodec的缓冲区中 AudioTrack:负责将解码之后的音频播放 SurfaceView:展示解码之后的视频  视频被播放主要分为以下步骤:\n 将资源加载到extractor 获取视频所在轨道 设置extractor选中视频所在轨道 创将解码视频的MediaCodec，decoder 开始循环，直到视频资源的末尾 将extractor中资源以一个单位填充进decoder的输入缓冲区 decoder将解码之后的视频填充到输出缓冲区 decoder释放输出缓冲区的同时，将缓冲区中数据渲染到surface  音频的播放类似，只多了AudioTrack部分，少了渲染到surface部分。\nMediaCodec.releaseOutputBuffer(int outputBufferIndex, boolean render);\n render为true就会渲染到surface  播放的控制，视频和音频各自拥有一个Thread。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public void play() { isPlaying = true; if (videoThread == null) { videoThread = new VideoThread(); videoThread.start(); } if (audioThread == null) { audioThread = new AudioThread(); audioThread.start(); } } public void stop() { isPlaying = false; }   VideoThread\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  private class VideoThread extends Thread { @Override public void run() { MediaExtractor videoExtractor = new MediaExtractor(); MediaCodec videoCodec = null; try { videoExtractor.setDataSource(filePath); } catch (IOException e) { e.printStackTrace(); } int videoTrackIndex; //获取视频所在轨道  videoTrackIndex = getMediaTrackIndex(videoExtractor, \u0026#34;video/\u0026#34;); if (videoTrackIndex \u0026gt;= 0) { MediaFormat mediaFormat = videoExtractor.getTrackFormat(videoTrackIndex); int width = mediaFormat.getInteger(MediaFormat.KEY_WIDTH); int height = mediaFormat.getInteger(MediaFormat.KEY_HEIGHT); //视频长度:秒  float time = mediaFormat.getLong(MediaFormat.KEY_DURATION) / 1000000; callBack.videoAspect(width, height, time); videoExtractor.selectTrack(videoTrackIndex); try { videoCodec = MediaCodec.createDecoderByType(mediaFormat.getString(MediaFormat.KEY_MIME)); videoCodec.configure(mediaFormat, surface, null, 0); } catch (IOException e) { e.printStackTrace(); } } if (videoCodec == null) { Log.v(TAG, \u0026#34;MediaCodec null\u0026#34;); return; } videoCodec.start(); MediaCodec.BufferInfo videoBufferInfo = new MediaCodec.BufferInfo(); ByteBuffer[] inputBuffers = videoCodec.getInputBuffers(); // ByteBuffer[] outputBuffers = videoCodec.getOutputBuffers();  boolean isVideoEOS = false; long startMs = System.currentTimeMillis(); while (!Thread.interrupted()) { if (!isPlaying) { continue; } //将资源传递到解码器  if (!isVideoEOS) { isVideoEOS = putBufferToCoder(videoExtractor, videoCodec, inputBuffers); } int outputBufferIndex = videoCodec.dequeueOutputBuffer(videoBufferInfo, TIMEOUT_US); switch (outputBufferIndex) { case MediaCodec.INFO_OUTPUT_FORMAT_CHANGED: Log.v(TAG, \u0026#34;format changed\u0026#34;); break; case MediaCodec.INFO_TRY_AGAIN_LATER: Log.v(TAG, \u0026#34;解码当前帧超时\u0026#34;); break; case MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED: //outputBuffers = videoCodec.getOutputBuffers();  Log.v(TAG, \u0026#34;output buffers changed\u0026#34;); break; default: //直接渲染到Surface时使用不到outputBuffer  //ByteBuffer outputBuffer = outputBuffers[outputBufferIndex];  //延时操作  //如果缓冲区里的可展示时间\u0026gt;当前视频播放的进度，就休眠一下  sleepRender(videoBufferInfo, startMs); //渲染  videoCodec.releaseOutputBuffer(outputBufferIndex, true); break; } if ((videoBufferInfo.flags \u0026amp; MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) { Log.v(TAG, \u0026#34;buffer stream end\u0026#34;); break; } }//end while  videoCodec.stop(); videoCodec.release(); videoExtractor.release(); } }   获取指定类型媒体文件所在轨道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  //获取指定类型媒体文件所在轨道  private int getMediaTrackIndex(MediaExtractor videoExtractor, String MEDIA_TYPE) { int trackIndex = -1; for (int i = 0; i \u0026lt; videoExtractor.getTrackCount(); i++) { //获取视频所在轨道  MediaFormat mediaFormat = videoExtractor.getTrackFormat(i); String mime = mediaFormat.getString(MediaFormat.KEY_MIME); if (mime.startsWith(MEDIA_TYPE)) { trackIndex = i; break; } } return trackIndex; }   将缓冲区传递至解码器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //将缓冲区传递至解码器  private boolean putBufferToCoder(MediaExtractor extractor, MediaCodec decoder, ByteBuffer[] inputBuffers) { boolean isMediaEOS = false; int inputBufferIndex = decoder.dequeueInputBuffer(TIMEOUT_US); if (inputBufferIndex \u0026gt;= 0) { ByteBuffer inputBuffer = inputBuffers[inputBufferIndex]; int sampleSize = extractor.readSampleData(inputBuffer, 0); if (sampleSize \u0026lt; 0) { decoder.queueInputBuffer(inputBufferIndex, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM); isMediaEOS = true; Log.v(TAG, \u0026#34;media eos\u0026#34;); } else { decoder.queueInputBuffer(inputBufferIndex, 0, sampleSize, extractor.getSampleTime(), 0); extractor.advance(); } } return isMediaEOS; }   音频的部分类似，完整源码请移步jiyangg/MediaPlaySimpleDemo\n","description":"","id":91,"section":"posts","tags":null,"title":"Anddroid媒体解码学习MediaCodec-MediaExtractor","uri":"https://jiyang.site/posts/2017-07-07-anddroid%E5%AA%92%E4%BD%93%E8%A7%A3%E7%A0%81%E5%AD%A6%E4%B9%A0mediacodec-mediaextractor/"},{"content":" 最近在Android和IOS上都需要对用户的某些输入进行简单的加密，于是采用MD5加密方式。\n  首先将目的字符串加密一次，获得32位字符串 然后将32位字符串拆为2段，分别加密1次 最后将加密后的2段拼接，加密100次  下面是Android的Java部分和IOS的Objective-C部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; public class MD5Util { public static String getMD5(String content) { String s = makeMD5(content); String s1 = null; if (s != null) { s1 = s.substring(0, 16); } String s2 = null; if (s != null) { s2 = s.substring(16, 32); } s1 = makeMD5(s1); s2 = makeMD5(s2); s = s1 + s2; for (int i = 0; i \u0026lt; 100; i++) { s = makeMD5(s); } return s; } private static String makeMD5(String content) { try { MessageDigest messageDigest = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); messageDigest.update(content.getBytes()); return getHashString(messageDigest); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return null; } private static String getHashString(MessageDigest messageDigest) { StringBuilder builder = new StringBuilder(); for (byte b : messageDigest.digest()) { builder.append(Integer.toHexString( ( b \u0026gt;\u0026gt; 4 ) \u0026amp; 0xf ) ); builder.append(Integer.toHexString( b \u0026amp; 0xf ) ); } return builder.toString(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  #import \u0026#34;MD5Utils.h\u0026#34; #import \u0026lt;CommonCrypto/CommonDigest.h\u0026gt;  @implementation MD5Utils +(NSString*)MD5:(NSString *)input{ NSString* s = [self makeMd5:input]; NSString* s1 = [s substringToIndex:16]; NSString* s2 =[s substringFromIndex:16]; s1 = [self makeMd5:s1]; s2 = [self makeMd5:s2]; NSMutableString* md5String = [NSMutableString stringWithString:s1]; [md5String appendString:s2]; for(int i =0;i\u0026lt;100;i++){ md5String = [self makeMd5WithMutaleString:md5String]; } return md5String; } + (NSString*)makeMd5:(NSString*) str{ const char * pointer = [str UTF8String]; unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH]; CC_MD5(pointer, (CC_LONG)strlen(pointer), md5Buffer); NSMutableString *string = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i \u0026lt; CC_MD5_DIGEST_LENGTH; i++) [string appendFormat:@\u0026#34;%02x\u0026#34;,md5Buffer[i]]; return string; } + (NSMutableString*)makeMd5WithMutaleString:(NSMutableString*) str{ const char * pointer = [str UTF8String]; unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH]; CC_MD5(pointer, (CC_LONG)strlen(pointer), md5Buffer); NSMutableString *string = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i \u0026lt; CC_MD5_DIGEST_LENGTH; i++) [string appendFormat:@\u0026#34;%02x\u0026#34;,md5Buffer[i]]; return string; } @end   ","description":"","id":92,"section":"posts","tags":null,"title":"Android和IOS等效MD5加密","uri":"https://jiyang.site/posts/2017-03-26-android%E5%92%8Cios%E7%AD%89%E6%95%88md5%E5%8A%A0%E5%AF%86/"},{"content":" Android程序不能无限制的使用设备的内存和CPU。正如经典所说，设备的资源不是给程序员用的，是给用户用的。在编写程序时，应该经常注意内存和CPU的使用。\n 在Android中，过多的使用内存容易导致OOM，过多的使用CPU容易导致手机卡顿甚至ANR。常见的优化方面有：\n 布局优化 绘制优化 内存泄漏优化 响应速度优化 列表List优化 Bitmap优化 线程优化  布局优化   布局的核心是尽量扁平，不要嵌套。\n 删除无用的控件和层级 使用性能较高的ViewGroup。能用LinearLayout代替RelativeLayout的就尽量用。但是如果使用LinearLayout会产生嵌套布局，那还是用Relativelayout好，布局嵌套越少越好。    使用include merge ViewStub标签\n \u0026lt;include\u0026gt;用于复用布局。 \u0026lt;merge\u0026gt;和\u0026lt;include\u0026gt;一起使用，用于剔除多余的ViewGroup。如果当前布局是竖向的LinearLayout，include进来的布局根布局也是竖向的LinearLayout，使用\u0026lt;merge\u0026gt;就能去掉多余的这层布局。 \u0026lt;ViewStub\u0026gt;用于按需加载布局。使用 ViewStub 标签引入的布局，默认不会被加载，只有通过 ViewStub 的setVisibility 或者inflater方法加载后，ViewStub 就会被它引入的布局替换掉。    绘制优化 在View的onDraw中要避免执行大量的操作：\n 不用创建大量的局部变量。onDraw方法会被频繁调用，如果一瞬间产生大量临时对象，不仅占用过多内存，还用于引起GC，从而造成卡顿。 不要做耗时操作，也不能执行千万级循环。每帧的绘制时间不要超过16ms(1000/60fps)。  内存泄漏优化  静态变量引用了Context Activity对象，会造成内存泄漏。 单列模式导致的内存泄漏。单列的生命周期和 Application 的生命周期一致。单列如果引用了Activity，Activity销毁之后，一直到程序结束都不会被回收。造成内存泄漏。 属性动画导致内存泄漏。属性动画如果在Activity结束时没有被cancle，就会导致 Activity 不能被释放，造成内存泄漏。解决方法是，在 Activity 的 onDestroy 中调用 animator.cancel()停止动画。 Handler 导致的内存泄漏。在 Activity 中创建的Handler持有Activity的引用。如果当 Activity 结束之后，handler所在的线程还在执行，就会造成 Activity 不能被释放。解决方法是，Handler持有Activity的弱引用(WeakReference)。  响应速度优化  避免在主线程做耗时操作。 Activity 5秒没有响应触摸或键盘输入就会触发ANR。BroadcastReceiver 10秒没有执行完操作也会触发ANR。 当一个进程发生ANR之后，系统会在data/anr目录下创建一个tracks.txt文件记录原因。可以上传该文件到服务器进而分析ANR原因。  列表优化  ListView 采用 ViewHolder 避免在getView中执行耗时操作 通过列表的滑动状态来控制加载任务。比如滑动时，不加载网络图片，不进行异步任务。 可以尝试开启硬件加速，提升滑动质量。  Bitmap优化  边界压缩。通过设置options.inJustDecodeBounds = true;只加载图片边界，获取图片的尺寸等信息。 质量降低。通过修改Bitmap.Config修改解码的颜色空间。 缩放图片。通过修改options.inSampleSize压缩图片尺寸。 使用缓存。使用LurCache在内存中缓存Bitmap，使用DiskLruCache实现磁盘缓存。  线程优化  使用线程池控制线程数量和复用线程  其他优化  常量使用 static final修饰 使用Android的特有数据结构：  ArrayMap代替HashMap SpareseArray代替以Integer为key的ArrayList。如ArrayList\u0026lt;Integer,Object\u0026gt;。 Pair成双成对的数据。   尽量采用静态内部类。可以避免非静态内部类隐式持有外部类的引用，造成内存泄漏。(比如推荐在Activity使用静态内部类的Handler)。 合理使用WeakReference和SoftReference。  ","description":"","id":93,"section":"posts","tags":null,"title":"Android性能优化","uri":"https://jiyang.site/posts/2017-08-18-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"content":"在非UI线程使用Handler进行线程通信时，一般都需要进行3个步骤：\n 创建Looper Looper.prepar() 创建Handler 启动消息循环Looper.loop()  通过这3步，基本就建立好了 Android 的多线程消息通信机制：\n Handler MessageQueue Looper Message  这几者可谓是你中有我，我中有你的存在。通过 Handler 发送 Message 到 Looper 的 MessageQueue 中，待 Looper 的循环执行\u001d到 Message 后，就会根据 Message \u0008的 target handler，回调对应 Handler 的 handlerMessage 方法。\n例如: Thread-A 拥有一个 Looper，Thread-B 持有一个在 Thread-A 中构造的 Handler，Thread-B 就可以通过这个 Handler 将 Message 发送到 Thread-A 的 Looper 的 MessageQueue 中，然后消息会走到 Thread-A 的 Handler 的 handleMessage 方法。\nLooper 原理图 在 Looper 类加载时就会创建一个 ThreadLocal \u001d类型的类变量 sThreadLocal\n1 2 3 4 5  public final class Looper { private static final String TAG = \u0026#34;Looper\u0026#34;; // sThreadLocal.get() will return null unless you\u0026#39;ve called prepare().  static final ThreadLocal\u0026lt;Looper\u0026gt; sThreadLocal = new ThreadLocal\u0026lt;Looper\u0026gt;();   Looper.prepar() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } // 将构造的 looper 存到类变量 sThreadLocal 中  sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { // 构建一个 messageQueue 成员  mQueue = new MessageQueue(quitAllowed); // 将当前线程存入 mThread 中  mThread = Thread.currentThread(); }   在这里面主要执行了 3 步：\n 构建一个 looper  构建一个 messageQueue 成员 将当前线程存入 mThread 中   将构造的 looper 存到类变量 sThreadLocal 中  至此，执行 Looper.praper 的当前线程就会拥有一个 looper 成员了，\u0008存放在 Looper 的 sThreadLocal 中。\n创建Handler 1 2 3 4 5 6 7 8 9 10 11  public Handler(Callback callback, boolean async) { ... // 通过`Looper.myLooper()` 类方法获取 sThreadLocal 中储存的当前线程的 looper，将这个 looper 绑定到 handler 的成员变量 mLooper 中  mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException(\u0026#34;Can\u0026#39;t create handler inside thread that has not called Looper.prepare()\u0026#34;); } // 将 mLooper 中的 messageQueue 绑定到 handler 的成员变量 mQueue 中  mQueue = mLooper.mQueue; ... }   1 2 3  public static @Nullable Looper myLooper() { return sThreadLocal.get(); }   Looper.loop()   声明一个局部常量final Loop me = myLoop()\n myLoop()将返回当前线程的looper成员    声明一个局部常量final MessageQueue queue\n 将me.mQueue赋值给queue    进入无限循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //进入无限循环  for (;;) { //取出一条消息  Message msg = queue.next(); //没有消息就阻塞  if (msg == null) { return; } ... //分发消息  try { msg.target.dispatchMessage(msg); //msg.target是一个Handler对象  } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } ... //回收消息  msg.recycleUnchecked();     通过Message.obtain()获取的消息，需要使用Handler.sendMessage()插入到消息队列。\n  通过Handler.obtainMessage()获取的消息，可以使用message.sendToTaget()插入到消息队列。\n  ","description":"","id":94,"section":"posts","tags":null,"title":"Android消息机制","uri":"https://jiyang.site/posts/2017-06-08-android%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"content":"AsyncTask类的初始化过程 初始化阶段：\n 初始化线程池THREAD_POOL_EXECUTOR。用于执行任务。 构造一个负责调度线程的线程池的Executor SerialExecutor，用于任务的排队，维护AsyncTask的任务串行执行。 构造一个sHandlerInternalHandler。负责将执行结果从线程切换到主线程(UI线程)。\nAsyncTask内部的线程是通过一个线程池负责调度执行 :  构造THREAD_POOL_EXECUTOR\n1 2 3 4 5 6  public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor( CORE_POOL_SIZE, //核心线程池大小，CPU核心数+1 \tMAXIMUM_POOL_SIZE, //线程池最大容量，CPU核心数*2+1 \tKEEP_ALIVE,TimeUnit.SECONDS, //每个空闲线程的等待时间，60秒 \tsPoolWorkQueue, //缓冲队列为LinkedBlockingQueue \tsThreadFactory); //新建线程的工程方法，每个线程使用一个静态自增标志命名    AsyncTask的线程池不同于Java中通过Executors.newFixedThreadPool(int nThreads)创建的线程池。\n Java的newFixedThreadPool\n1 2 3 4 5  public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); }   比较两者可知 :\n FixedThreadPool的核心线程池容量和最大线程池容量相等。 FixedThreadPool的缓存队列为没有数量限制的LinkedBlockingQueue。 FixedThreadPool的空闲线程的等待时间为0,线程完成之后就会被回收。 AsyncTask的核心线程池容量和最大线程池容量都与当前设备的CPU核心数有关。 AsyncTask的缓存队列有最大容量限制。 AsyncTask的空闲线程会等待60s才被回收。  这样的差别就使得AsyncTask不适合做耗时线程的操作。如果一个线程太耗时，线程池又满了，那后面的线程就会一直等待。\n线程池的配置参数\n1 2 3 4  static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); static final int CORE_POOL_SIZE = CPU_COUNT + 1; static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; static final int KEEP_ALIVE = 1;   线程池缓存队列为LinkedBlockingQueue\n1 2  private static final BlockingQueue\u0026lt;Runnable\u0026gt; sPoolWorkQueue = new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;(128);   新建线程的工厂方法\n1 2 3 4 5 6 7  private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, \u0026#34;AsyncTask #\u0026#34; + mCount.getAndIncrement()); } };   SerialExecutor\n创建AsyncTask实例 AsyncTask实例主要拥有以下属性 :\n WorkerRunnable\u0026lt;Params, Result\u0026gt; mWorker : 实现了Callable接口 FutureTask mFuture : 一个并发类，充当Runnable的作用。 volatile Status mStatus : 当前AsyncTask的状态 : PENDING,RUNNING,FINISHED AtomicBoolean mCancelled : 任务是否被取消 AtomicBoolean mTaskInvoked : 任务是否执行  执行任务 Executor的execute方法 : AsyncTask内部的SerialExecutor实现了Executor接口，提供了execute方法的实现\nprivate static class SerialExecutor implements Executor { final ArrayDeque\u0026lt;Runnable\u0026gt; mTasks = new ArrayDeque\u0026lt;Runnable\u0026gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 首先把FutureTask对象插入到队列mTasks中，如果这个时候没有正在活动的AsyncTask任务，就会调用 scheduleNext() 来执行下一个任务。\n同时，当mTask队列中的FutureTask对象执行完成之后，也会调用 scheduleNext() 来执行下一个任务。\n 这就证明AsyncTask是串行执行的，同一时刻只能有一个处于活动状态的任务。下一个必须等上一个执行完成之后，才能执行。\n FutureTask对象执行任务是通过调用自己的run方法，在run方法中会调用 mWoker 的 call 方法。\nmWorker = new WorkerRunnable\u0026lt;Params, Result\u0026gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); } }; mWorker首先把mTaskInvoked设为 true 表示，当前任务已经被调用过了。然后执行 AsynckTask 的 doInBackground 方法，接着将返回值传递给 postResult 方法。\npostResult的实现\n1 2 3 4 5 6 7  private Result postResult(Result result) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult\u0026lt;Result\u0026gt;(this, result)); message.sendToTarget(); return result; }   postResult 方法通过 sHandler 发送一个 MESSAGE_POST_RESULT 消息。\nsHandler的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private static class InternalHandler extends Handler { @Override public void handleMessage(Message msg) { AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result  result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } }   sHandler 是一个静态对象的，在类加载时就被创建。为了能将消息从线程池传递到主线程，就要求AsyncTask类必须在主线程中加载，否则同一个进程中的AsyncTask无法正常工作。Android系统会在Application启动时调用AsyncTask的init方法。\nsHandler 收到 MESSAGE_POST_RESULT 消息后会调用 AsyncTask 的 finish 方法。\nfinish方法\n1 2 3 4 5 6 7 8  private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; }   如果 AsyncTask 任务被取消了，就调用 onCancelled 方法，否则调用 onPostExecute 方法。\n 在Android 3.0 开始，AsyncTask 多加了一个线程池SerialExecutor来串行执行任务。\n 想让AsyncTask并行执行，可以调用executeOnExecutor(Executor exec, Params... params)传入自己的线程池。也可以直接使用AsyncTask的线程池。\n例如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); new MyAsyncTask(\u0026#34;Task1\u0026#34;).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, \u0026#34;\u0026#34;); new MyAsyncTask(\u0026#34;Task2\u0026#34;).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, \u0026#34;\u0026#34;); new MyAsyncTask(\u0026#34;Task3\u0026#34;).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, \u0026#34;\u0026#34;); } class MyAsyncTask extends AsyncTask\u0026lt;String, Integer, String\u0026gt; { private String name; public MyAsyncTask(String name) { this.name = name; } @Override protected String doInBackground(String... params) { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } return name; } @Override protected void onPostExecute(String s) { super.onPostExecute(s); Log.i(\u0026#34;TAG\u0026#34;, s); } }   ","description":"","id":95,"section":"posts","tags":null,"title":"AsyncTask Source Code","uri":"https://jiyang.site/posts/2017-08-06-asynctask%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"},{"content":" BlockingQueue:Java提供的线程安全的队列接口。 CountDownWatch:可用来让一个线程一直等待watch的值为0,另一个线程来修改watch的值。达到让线程依次执行的目的。  BlockingQueue的常用实现类:\n ArrayBlockingQueue DelayQueue LinkedBlockingDeque  操作方法:\n   操作\\结果 Throw Exception Return false Block Times Out     插入 add(E e) offer(E e) put(E e) offer(E e,int timeOut,TimeUtil util)   检索并删除 remove() poll() take() poll(long timeout, TimeUnit unit)   检索不删除 element() peek()      当对队列的操作，被打断或者队列容量填满时，以上方法的返回如上表不同。有的会抛异常，有的会返回false，有的会一直阻塞进程等待。\nBlockingQueue实例，生产者-消费者问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class Producer implements Runnable { private final BlockingQueue\u0026lt;Integer\u0026gt; queue; Producer(BlockingQueue\u0026lt;Integer\u0026gt; queue) { this.queue = queue; } @Override public void run() { System.out.println(\u0026#34;start produce\u0026#34;); while (true) { boolean insertSuc = queue.offer(producer()); if (!insertSuc) { System.out.println(\u0026#34;produce over\u0026#34;); return; } } } int i = 0; private Integer producer() { return ++i; } } class Consumer implements Runnable { private final BlockingQueue\u0026lt;Integer\u0026gt; queue; Consumer(BlockingQueue\u0026lt;Integer\u0026gt; queue) { this.queue = queue; } @Override public void run() { System.out.println(\u0026#34;start consumer\u0026#34;); while (true) { try { Integer i = queue.take(); System.out.print( i+\u0026#34; \u0026#34;); } catch (InterruptedException e) { } } } } BlockingQueue\u0026lt;Integer\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(10); new Thread(new Producer(queue)).start(); new Thread(new Consumer(queue)).start();   输出:\n1 2 3 4  start produce produce over start consumer 1 2 3 4 5 6 7 8 9 10   CountDownWatch实例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  CountDownLatch countDownLatch = new CountDownLatch(10); Runnable r1 = new Runnable() { @Override public void run() { try { System.out.println(\u0026#34;r1 wait countDown count=\u0026#34; + countDownLatch.getCount()); countDownLatch.await(); System.out.println(\u0026#34;r1 goon countDown count=\u0026#34; + countDownLatch.getCount()); } catch (InterruptedException e) { e.printStackTrace(); } } }; Runnable r2 = new Runnable() { @Override public void run() { int i = 10; System.out.println(\u0026#34;r2 run\u0026#34;); while (i \u0026gt; 0) { countDownLatch.countDown(); System.out.print(countDownLatch.getCount() + \u0026#34; \u0026#34;); i--; } } }; new Thread(r1).start(); new Thread(r2).start();   输出:当countDown的值为0时，thread1就从等待变为运行。\n1 2 3 4  r1 wait countDown count=10 r2 run 9 8 7 6 5 4 3 2 1 r1 goon countDown count=0 0   ","description":"","id":96,"section":"posts","tags":null,"title":"BlockingQueue-CountDownLatch","uri":"https://jiyang.site/posts/2017-07-25-blockingqueue-countdownlatch/"},{"content":"DNA分子是以4种脱氧核苷酸为单位连接而成的长链，这4种脱氧核苷酸分别含有A,T,C,G四种碱基。\n碱基互补配对原则：A和T是配对的，C和G是配对的。\n如果两条碱基链长度是相同的并且每个位置的碱基是配对的，那么他们就可以配对合成为DNA的双螺旋结构。\n现在给出两条碱基链，允许在其中一条上做替换操作：把序列上的某个位置的碱基更换为另外一种碱基。\n问最少需要多少次让两条碱基链配对成功\n  输入描述:\n 输入包括一行： 包括两个字符串,分别表示两条链,两个字符串长度相同且长度均小于等于50。    输出描述:\n输出一个整数，即最少需要多少次让两条碱基链配对成功\n  输入例子:\n  ACGT TGCA  输出例子:\n0   Java解决方案:\n  获取两天链对应的配对链 将配对链和原链交叉比较，获取不同的碱基计数 获得两个计数的最小值即为答案  import java.util.Scanner; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); String[] strings = scanner.nextLine().split(\u0026quot; \u0026quot;); scanner.close(); String s1 = strings[0]; String s2 = strings[1]; char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); char[] c1a = new char[c1.length]; char[] c2a = new char[c2.length]; getA(c1, c1a); getA(c2, c2a); int count1 = getCount(c1, c2a); int count2 = getCount(c2, c1a); int min = Math.min(count1, count2); System.out.println(min); } static void getA(char[] c1, char[] c1a) { for (int i = 0; i \u0026lt; c1.length; i++) { switch (c1[i]) { case 'A': c1a[i] = 'T'; break; case 'T': c1a[i] = 'A'; break; case 'C': c1a[i] = 'G'; break; case 'G': c1a[i] = 'C'; break; default: break; } } } static int getCount(char[] c1, char[] c2) { int count = 0; for (int i = 0; i \u0026lt; c1.length; i++) { if (c1[i] != c2[i]) { count++; } } return count; } } ","description":"","id":97,"section":"posts","tags":null,"title":"DNA合成问题","uri":"https://jiyang.site/posts/2017-08-24-dna%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/"},{"content":"Activity的启动方式分为两种:  显式启动 通过指明启动的Activity类 隐式启动 通过Intent匹配目标组件的IntentFilter中设置的信息。如果不匹配，就无法启动目标Activity。  隐式启动中IntentFilter的作用 IntentFilter主要包括 : action   category data。只有Intent完全匹配三者，才能成功启动Activity。一个Activity可以拥有多个IntentFilter，一个Intent只要能匹配其中一个，就能成功启动Activity。\n1 2 3 4 5 6 7 8  \u0026lt;activity android:name=\u0026#34;.MyActivity\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.me.my_activity\u0026#34; /\u0026gt; \u0026lt;categoriey android:name=\u0026#34;com.me.my_category\u0026#34; /\u0026gt; \u0026lt;categoriey android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;data android:mimeType=\u0026#34;image/*\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt;   action 匹配规则 actioin 根据name属性值进行匹配。Intent的 action 需要与 name 的值完全一样，才算匹配成功。一个 IntentFilter 可以有多个 action , Intent 的 action 只要和其中一个action匹配成功就可以。一个Intent如果没有指定action,那么匹配失败。\ncategory 匹配规则 category根据name属性值进行匹配。Intent要么不携带 category 参数，直接默认匹配。要么携带的 category 每一个都必须在 IntentFilter 中的 category 能匹配到。\nIntent 不携带category也能匹配成功是因为 : 调用startActivity和startActivityForResult时，系统会默认为Intent添加\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot; /\u0026gt;category。所以想要Activity能接受隐式调用，就必须给Activity指定\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot; /\u0026gt;这个category。\ndata 匹配规则 data的匹配和action类似，也是只要Intent的data能匹配多个data中的一个就匹配成功。\ndata 由两部分组成 :\n mineType 媒体类型。比如image/* video/*。可以表示图片，文本，视频等不同媒体格式。 URI  URI的结构 \u0026lt;scheme\u0026gt;://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/[\u0026lt;[path]\u0026gt;|[pathPrefix]|[pathPattern]]\n scheme : URI的模式，比如http file content等。如果Intent的URI中没有指定scheme，那么整个URI的其他参数无效，这个URI也就无效。过滤规则中的scheme默认需要匹配content或file。 host : URI的主机名。比如www.mm.com。如果Intent的URI中没有指定host，那么整个URI的其他参数无效，这个URI也就无效。 port : URI的端口号。只有Intent的URI中指定了scheme和port参数时才有意义。 path pathPattern pathPrefix : 表示路径信息  path 完整路径。 pathPattern 完成路径。可以包含通配符*，表示0个或多个任意字符 pathProfix 路径的前缀信息。    实例1\n\u0026lt;intent-filter\u0026gt; ......\t\u0026lt;data android:mimeType=\u0026quot;image/*\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; Intent中的mimeType必须是image/*才能匹配。这里的过滤规则虽然没有指定URI，但是scheme默认为contene和file。\n只设置mimeType的intent.setType(\u0026quot;image/*\u0026quot;)将不能匹配。\n需要同时设置 :\n1  intent.setDataAndType(Uri.parse(\u0026#34;file://xxx\u0026#34;), \u0026#34;image/*\u0026#34;);    intent.setType和intent.setData不能分开调用，因为两者都会清空彼此的信息\n 从Android源码中可以看到 :\n1 2 3 4 5  public Intent setData(Uri data) { mData = data; mType = null; return this; }   1 2 3 4 5  public Intent setType(String type) { mData = null; mType = type; return this; }   实例2\n1 2 3 4 5 6 7 8 9  \u0026lt;intent-filter\u0026gt; ...... \u0026lt;data android:mimeType=\u0026#34;image/jpeg\u0026#34; android:scheme=\u0026#34;http\u0026#34; /\u0026gt; \u0026lt;data android:mimeType=\u0026#34;video/mpeg\u0026#34; android:scheme=\u0026#34;http\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt;   这个data规则\nintent.setDataAndType(Uri.parse(\u0026quot;http://xxx\u0026quot;),\u0026quot;image/jpeg\u0026quot;); 或者\nintent.setDataAndType(Uri.parse(\u0026quot;http://zzz\u0026quot;),\u0026quot;video/mpeg\u0026quot;); 都可以匹配。\n data的属性可以同行写，也可以分开下。\n \u0026lt;data android:host=\u0026quot;www.xxx.com\u0026quot; android:mimeType=\u0026quot;image/*\u0026quot; android:scheme=\u0026quot;http\u0026quot; /\u0026gt; ------------------------------------- \u0026lt;data android:host=\u0026quot;www.xxx.com\u0026quot; /\u0026gt; \u0026lt;data android:scheme=\u0026quot;http\u0026quot; /\u0026gt; \u0026lt;data android:mimeType=\u0026quot;image/*\u0026quot; /\u0026gt;  Android的其他组件，Service BroadcastReceiver的IntentFiler匹配规则和Activity的类似。\n  当隐式启动一个Activity时，可以使用Intent的resolveActivity(PackageManager pm)方法判断是否有匹配的activity。 也可以调用PackageManager的resolveActivity(Intent itent,int flag)方法判断。  第二个参数 flag 作为匹配的选项。一般使用MATCH_DEFAULT_ONLY参数。 MATCH_DEFAULT_ONLY 只匹配 intent-filter 中声明了\u0026lt;category android:name=\u0026quot;android.intent.category.DEFAULT\u0026quot; /\u0026gt;的Activity。因为没有声明这个category的Activity不能隐式调用。    if (intent.resolveActivity(getPackageManager()) == null) { //证明没有对应的activity } ","description":"","id":98,"section":"posts","tags":null,"title":"IntentFilter匹配规则","uri":"https://jiyang.site/posts/2017-08-05-intentfilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"},{"content":"单例常见实现方式  饿汉式：在类被加载时就初始化单例 懒汉式：在需要的地方才初始化单例  饿汉式加载问题 传统的在类加载时就创建单例的方法存在一些问题：\n1 2 3 4 5 6 7 8 9 10  class SingleInstance { private SingleInstance() {...} private static SingleInstance mInstance = new SingleInstance(); public static SingleInstance getInstance(){ return mInstance; } }   如果类的实例化含义太多的操作，就可能会影响程序的性能，启动时间等。而且如果单例在程序中并未用到，则会一直存在一个无法被GC回收的对象，造成浪费。\n如果单例一定会使用，而且构造方法中又没有太多操作，则可以在类加载时就初始化单例。\n懒汉式加载问题 下面这种懒加载，在多线程情况下可能会造成创建了多个单例。\n线程A正在执行new操作，线程B同时来获取单例，此时instance还是null，线程B就也会去执行new操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13  class SingleInstance { private SingleInstance() {} private static SingleInstance mInstance; public static SingleInstance getmInstance() { if (null == mInstance) { mInstance = new SingleInstance(); } return mInstance; } }   使用synchronized优化懒加载  方式一：对获取方法加锁（不推荐）  1 2 3 4 5 6  public synchronized static SingleInstance getInstance(){ if(null==mInstance){ mInstance = new SingleInstance(); } return mInstance; }   这种方式加锁，会造成性能问题。synchronized修饰了方法，所有线程获取单例时都会经历同步锁，不论单例是否已经被创建。而且获取单例可能是个频繁的操作，直接对方法加锁会降低性能。\n 方式二：双重验证，只对构建加锁  1 2 3 4 5 6 7 8 9 10 11 12 13 14  private volatile static SingleInstance mInstance; public static SingleInstance getInstance() { // 避免在 mInstance 初始化之后, 多个线程每次都获取同步锁  if (null == mInstance) { synchronized (SingleInstance.class) { // JVM 可能存在指令重排序, 先为对象分配内存并赋值给引用返回, 后进行初始化  if(null == mInstance) { mInstance = new SingleInstance(); } } } return mInstance; }   推荐这种方式实现单例懒加载，只当单例没有被构造时才会进入加锁的部分。而且使用volatitle关键字, 禁止对 volatile 修饰的变量进行指令重排序, 且 volatitle 会让每个线程每次都从主内存获取最新的变量值, 确保了变量在多线程下的可见性.\n使用静态内部类优化懒加载 静态内部类(Holder)只有在被用到时才会被加载, 加载过程由 JVM 保证多线程安全, 而且静态变量的赋值只会在类加载时执行一次. 后续在获取单例时因为内部类(Holder)已经加载过了所以不会再走赋值过程, 直接返回静态变量(mInstance).\n1 2 3 4 5 6 7 8 9 10 11 12 13  class SingleInstance { private SingleInstance() {} public static SingleInstance getInstance() { return Holder.mInstance; } private static class Holder { private static final SingleInstance mInstance = new SingleInstance(); } }   ","description":"","id":99,"section":"posts","tags":null,"title":"Java 单例实现","uri":"https://jiyang.site/posts/2017-08-19-%E5%8D%95%E4%BE%8B%E5%88%86%E6%9E%90/"},{"content":" 在Android上进行网络请求时，经常需要维持登录之后的session和cookie状态。session和cookie是加在HTTP请求的header里的。可以通过从header中获取，进行请求时手动添加登录获取的cookie。\n OkHttp提供的拦截器可以添加，删除或替换请求标头。 还可以转换具有一个请求的正文。例如，如果您连接到的Web服务器支持压缩，就可以使用应用程序拦截器添加请求体压缩。\n square的一张图\n OkHttp提供了一个拦截器接口Interceptor和两种添加拦截器的方式：\n Application Interceptor NetWork Interceptor  两者最大的区别就是在一次网络访问中拦截的次数和拦截到的信息。\nInterceptors 调用时序图 @startuml participant client.interceptors #SpringGreen participant RetryAndFollowUpInterceptor participant BridgeInterceptor participant CacheInterceptor participant ConnectInterceptor participant client.networkInterceptors #SpringGreen participant CallServerInterceptor client.interceptors -\u0026gt; RetryAndFollowUpInterceptor activate client.interceptors activate RetryAndFollowUpInterceptor RetryAndFollowUpInterceptor -\u0026gt; BridgeInterceptor activate BridgeInterceptor BridgeInterceptor -\u0026gt; CacheInterceptor activate CacheInterceptor CacheInterceptor -\u0026gt; ConnectInterceptor activate ConnectInterceptor ConnectInterceptor -\u0026gt; client.networkInterceptors activate client.networkInterceptors client.networkInterceptors -\u0026gt; CallServerInterceptor activate CallServerInterceptor CallServerInterceptor --\u0026gt; client.networkInterceptors deactivate CallServerInterceptor client.networkInterceptors --\u0026gt; ConnectInterceptor deactivate client.networkInterceptors ConnectInterceptor --\u0026gt; CacheInterceptor deactivate ConnectInterceptor CacheInterceptor --\u0026gt; BridgeInterceptor deactivate CacheInterceptor BridgeInterceptor --\u0026gt; RetryAndFollowUpInterceptor deactivate BridgeInterceptor RetryAndFollowUpInterceptor --\u0026gt; client.interceptors deactivate RetryAndFollowUpInterceptor deactivate client.interceptors @enduml Application Interceptor  不必担心中间响应，如重定向和重试。 总是调用一次，即使是从缓存中提供的HTTP响应。 遵守应用程序的原始意图。OkHttp注入的标题，如If-None-Match，不会生效。 允许短路，不调用Chain.proceed（）。 允许重试并多次调用Chain.proceed（）。  NetWork Interceptor  能够对重定向和重试等中间响应进行操作。 对于缓存网络短路的响应不被调用。 观察数据，就像通过网络传输一样。 访问携带请求的连接。  使用拦截器自动储存和添加cookie  OkHttp 有提供 CookieJar 辅助存储 cookie\n OkHttp提供了Interceptors拦截器可以很方便的实现类似cookie本地化维持的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  private class AddCookiesInterceptor implements Interceptor { @Override public Response intercept(@NonNull Chain chain) throws IOException { //get cached cookie from local  HashSet\u0026lt;String\u0026gt; cookies = (HashSet\u0026lt;String\u0026gt;) SharedPrefsUtils .getStringSetPreference( AccessApplication.getGlobalContext(), C.SP_COOKIE); //add cached cookie into request  Request.Builder builder = chain.request().newBuilder(); if (cookies != null) { for (String cookie : cookies) { builder.addHeader(\u0026#34;Cookie\u0026#34;, cookie); } } Request request = builder.build(); //get response  Response response = chain.proceed(request); //save response cookie to local cache  List\u0026lt;String\u0026gt; newCookies = response.headers(\u0026#34;Set-Cookie\u0026#34;); if (!newCookies.isEmpty()) { HashSet\u0026lt;String\u0026gt; cookie = new HashSet\u0026lt;\u0026gt;(); for (String header : newCookies) { cookie.add(header); } SharedPrefsUtils.setStringSetPreference( AccessApplication.getGlobalContext(), C.SP_COOKIE, cookie); } return response; } }   ","description":"","id":100,"section":"posts","tags":null,"title":"OkHttp拦截器使用","uri":"https://jiyang.site/posts/2017-08-23-okhttp%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BD%BF%E7%94%A8/"},{"content":" 绘制了x,y坐标轴 绘制了4条直线  一些函数说明:\n  gl.glLoadIdentity():\n将当前画布矩阵的状态回归初始状态。\n因为Translate``Rotate等操作都是基于当前画布矩阵的状态，如果在每次调用Translate之前不使用glLoadIdentity(),画布则会一直移动。\n  gl.glTranslatef(0, 0, -4):\n将画布后移4个单位。\n  gl.glVertexPointer(3, GL10.GL_FLOAT, 0, vertex):设置顶点\n参数说明:\n 每个顶点的坐标个数(只能是2,3,4中的一个，默认值是4) 每个顶点的数据类型(可取常量:GL_BYTE, GL_SHORT,GL_FIXED,GL_FLOAT) 连续顶点之间的排列方式(如果为0，数组中的顶点就会被认为是按照紧凑方式排列的，默认值为0) 数组的首地址（Android中就是数组名）    gl.glDrawArrays(GL10.GL_LINE_STRIP, 0, 4):绘制函数\n参数说明:\n 绘制方式：  GL_POINTS:点 GL_LINES：线，2点构成的独立的线 GL_LINE_LOOP：线，所有点连接的线，首尾相接 GL_LINE_STRIP：线，所有点连接的线，首尾不相接 GL_TRIANGLES：三角形，3点构成的独立的三角形 GL_TRIANGLE_STRIP：三角形，详见 GL_TRIANGLE_FAN：三角形，详见   从数组缓存中的哪一位开始绘制，一般为0 数组中顶点的数量    \t 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  private void drawLine(GL10 gl) { //画坐标轴  float[] vertexArr1 = { -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, -1.0f, 0.0f }; ByteBuffer byteBuffer = ByteBuffer.allocateDirect(vertexArr1.length * 4); byteBuffer.order(ByteOrder.nativeOrder()); FloatBuffer floatBuffer1 = byteBuffer.asFloatBuffer(); floatBuffer1.put(vertexArr1); floatBuffer1.position(0); gl.glColor4f(0.0f, 1.0f, 0.0f, 0.0f); gl.glLineWidth(5.0f); gl.glLoadIdentity(); gl.glTranslatef(0, 0, -4); gl.glEnableClientState(GL10.GL_VERTEX_ARRAY); gl.glVertexPointer(3, GL10.GL_FLOAT, 0, floatBuffer1); gl.glDrawArrays(GL10.GL_LINES, 0, 4); gl.glDisableClientState(GL10.GL_VERTEX_ARRAY); //4条线  float[] vertexArr2 = { -0.5f, -0.5f, 0f, 0.0f, .5f, 0f, 0.5f, -0.5f, 0f, 0.9f, -0.0f, 0f, }; byteBuffer = ByteBuffer.allocateDirect(vertexArr2.length * 4); byteBuffer.order(ByteOrder.nativeOrder()); FloatBuffer floatBuffer2 = byteBuffer.asFloatBuffer(); floatBuffer2.put(vertexArr2); floatBuffer2.position(0); gl.glColor4f(1.0f, 0.0f, 0.0f, 0.0f); gl.glLineWidth(20.0f); gl.glEnableClientState(GL10.GL_VERTEX_ARRAY); gl.glVertexPointer(3, GL10.GL_FLOAT, 0, floatBuffer2); gl.glDrawArrays(GL10.GL_LINE_STRIP, 0, 4); }   ","description":"","id":101,"section":"posts","tags":null,"title":"OpenGL-ES-Line","uri":"https://jiyang.site/posts/2017-07-01-opengl-es-line/"},{"content":"Python数据类型\n  Number 数字\n int 有符号整数 long 长整形，也可以代表十六进制或八进制 float 浮点型 complex 复数     String 字符串   list 列表   按索引存取\n 1  list = [\u0026#39;item1\u0026#39;, 2, \u0026#39;3\u0026#39;, 4, 5]    元组 只读列表   按索引存取\n 1  tuple = (\u0026#39;item1\u0026#39;, 2, \u0026#39;3\u0026#39;, 4, 5)    字典   按键值对存取\n 1 2 3 4  dict = {}\t//声明一个字典变量 dict[2] = \u0026#34;2\u0026#34;\t//key为2的值为\u0026#34;2\u0026#34; dict[\u0026#39;key2\u0026#39;] = \u0026#34;this is key2\u0026#34;\t//key为`key2`的值为\u0026#34;this is key2\u0026#34; tinyDict = {\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;, \u0026#39;key2\u0026#39;: 2} //声明并用键值对初始化字典   运算符  幂运算 **  1 2 3  a = 10 b = 2 a = a ** b #a=100    取整数 // 返回商的部分的整数  1 2  9//2 输出结果 4 9.0//2.0 输出结果 4.0    幂赋值运算 a **= c等效于a = a ** c 取整除运算 a //= c等效于a = a // c  1 2 3 4  a = 5.0 c = 2 a /= c #a=2.5 a // = c #a=2.0   逻辑运算符  and 等效 与 or 等效 或 not 等效 非  成员运算符 成员运算符常用于字符串，列表，元组\n in 如果在序列中找到就返回True，否则返回False not in 如果在序列中没有找到就返回True，否则返回False  1 2 3 4 5 6 7 8 9 10 11 12 13 14  a = \u0026#39;test\u0026#39; b = 1 list = [\u0026#39;test\u0026#39;, 0, 10, 11] if (a in list): print a, \u0026#39;in list\u0026#39; else: print a, \u0026#39;not in list\u0026#39; if (b not in list): print b, \u0026#39;not in list\u0026#39; else: print b, \u0026#39;in list\u0026#39;   身份运算符 判断两个对象的储存单元\n is 判断两个标识符是不是引用自一个对象 is not判断两个标识符是否引用自不同对象  1 2 3 4  a = 1 b = 1 print (a is b) # True    is和==的区别\n  is类似Java的==，判断两个对象的引用是否为同一个 ==类似Java的equals()，判断两个对象的值是否相等  1 2 3 4 5 6 7  a = [1, 2, 3, 4] b = a print (a is b) # True b = a[:] #相当于 b = a[0:]，b中内容与a完全一样，只是b引用了一个新的对象 print (a is b) # False print (a == b) # True   ","description":"","id":102,"section":"posts","tags":null,"title":"Python笔记-基础","uri":"https://jiyang.site/posts/2017-03-24-python%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80/"},{"content":"实现方法   Chrome headless 模式结合 selenium webDriver 实现通过扫描二维码登录 QZone 获取 Cookie\n  携带登录成功的 cookie 和 token 访问好友空间\n  遍历好友所有说说， 解析数据存入数据库\n  使用 jieba 分词和 wordcloud 词云实现词云图\n  环境要求: ChromeDriver, Chrome version \u0026gt;= 64, Python 2.X\n  login_qzone.py\n 参考 http://shenchao.me/2016/04/16/qqzone/\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  # coding=utf-8 import re from time import sleep from PIL import Image from selenium import webdriver def login_by_qr(): def getGTK(cookie): \u0026#34;\u0026#34;\u0026#34; 根据cookie得到GTK \u0026#34;\u0026#34;\u0026#34; hashes = 5381 for letter in cookie[\u0026#39;p_skey\u0026#39;]: hashes += (hashes \u0026lt;\u0026lt; 5) + ord(letter) return hashes \u0026amp; 0x7fffffff option = webdriver.ChromeOptions() option.add_argument(\u0026#39;--headless\u0026#39;) option.add_argument(\u0026#39;--disable-gpu\u0026#39;) browser = webdriver.Chrome(executable_path=\u0026#39;etc/chromedriver_linux\u0026#39;, options=option) url = \u0026#34;https://qzone.qq.com/\u0026#34; browser.get(url) sleep(3) # 等三秒 browser.get_screenshot_as_file(\u0026#39;QR.png\u0026#39;) im = Image.open(\u0026#39;QR.png\u0026#39;) im.show() print (\u0026#39;wait scanner QR\u0026#39;) sleep(20) # 等二十秒，可根据自己的网速和性能修改 print(\u0026#39;\u0026#39;.format(browser.title)) cookie = {} for elem in browser.get_cookies(): cookie[elem[\u0026#39;name\u0026#39;]] = elem[\u0026#39;value\u0026#39;] print(\u0026#39;Get the cookie of qq login successfully!\u0026#39;) html = browser.page_source # 从网页源码中提取g_qzonetoken g_qzonetoken = re.search(r\u0026#39;window\\.g_qzonetoken = \\(function\\(\\)\\{ try\\{return (.*?);\\} catch\\(e\\)\u0026#39;, html) token = g_qzonetoken.group(1) gtk = getGTK(cookie) # 通过getGTK函数计算gtk browser.quit() return cookie, gtk, token   fetch_moods.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105  # coding=utf-8 import csv import json import re import requests from login_qzone import login_by_qr from utils.util import clear_text GET_MOODS_URL = \u0026#39;https://h5.qzone.qq.com/proxy/domain/taotao.qq.com/cgi-bin/emotion_cgi_msglist_v6\u0026#39; RESP_REGEX = r\u0026#39;_preloadCallback\\((.*?)\\}\\)\u0026#39; def read_friends_qq(csv_file_path): csv_reader = csv.reader(open(csv_file_path)) csv_reader.next() friend = [] for row in csv_reader: friend.append(row[3]) friends = [] for f in friend: friends.append(f[:-7]) return friends class Fetcher(object): def __init__(self): self.headers = { \u0026#39;Host\u0026#39;: \u0026#39;h5.qzone.qq.com\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;*/*\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate, br\u0026#39;, \u0026#39;Referer\u0026#39;: \u0026#39;https://user.qzone.qq.com/408776303?_t_=0.22746974226377736\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;keep-alive\u0026#39; } self.cookie = None self.gtk = None self.token = None def login(self): self.cookie, self.gtk, self.token = login_by_qr() def fetch(self, qq): if not self.cookie or not self.gtk or not self.token: print (\u0026#39;Need login!\u0026#39;) return count = 0 p = 1 session = requests.session() while True: pos = p * 20 params = { \u0026#39;uin\u0026#39;: qq, \u0026#39;ftype\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;sort\u0026#39;: \u0026#39;0\u0026#39;, \u0026#39;pos\u0026#39;: pos, \u0026#39;num\u0026#39;: \u0026#39;20\u0026#39;, \u0026#39;replynum\u0026#39;: \u0026#39;100\u0026#39;, \u0026#39;g_tk\u0026#39;: self.gtk, \u0026#39;callback\u0026#39;: \u0026#39;_preloadCallback\u0026#39;, \u0026#39;code_version\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;format\u0026#39;: \u0026#39;jsonp\u0026#39;, \u0026#39;need_private_comment\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;qzonetoken\u0026#39;: self.token } try: response = session.request(\u0026#39;GET\u0026#39;, GET_MOODS_URL, params=params, headers=self.headers, cookies=self.cookie) print(response.status_code) text = response.text matcher = re.match(RESP_REGEX, text) if matcher: t = matcher.group(1) + \u0026#39;}\u0026#39; data = json.loads(t) if not data: continue msg_list = data.get(\u0026#39;msglist\u0026#39;) if isinstance(msg_list, list): total = len(msg_list) for item in msg_list: yield self._wrap_mood(qq, item) else: total = 0 count += total if total == 0: print(u\u0026#39;{}-total: {}\u0026#39;.format(qq, count)) break except Exception as e: print(e) finally: p += 1 @staticmethod def _wrap_mood(qq, item): mood = { \u0026#39;content\u0026#39;: clear_text(item.get(\u0026#39;content\u0026#39;)), \u0026#39;created_time\u0026#39;: item.get(\u0026#39;created_time\u0026#39;), \u0026#39;qq\u0026#39;: qq, \u0026#39;nick_name\u0026#39;: clear_text(item.get(\u0026#39;name\u0026#39;)) } return mood   generator_cloud.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # coding=utf-8 import jieba import matplotlib.pyplot as plt from wordcloud import WordCloud def generator_cloud(name, text): \u0026#34;\u0026#34;\u0026#34; :param name: 存放的图片文件名 :param text: 目标生成词云的文本 :return: \u0026#34;\u0026#34;\u0026#34; # 分词 word_list_after_jieba = jieba.cut(text, cut_all=True) wl_space_split = \u0026#34; \u0026#34;.join(word_list_after_jieba) if not wl_space_split: return # 生成词云 my_word_cloud = WordCloud(font_path=\u0026#39;etc/font.ttf\u0026#39;, width=1800, height=800, margin=5).generate(wl_space_split) plt.imshow(my_word_cloud) plt.axis(\u0026#34;off\u0026#34;) plt.savefig(\u0026#39;png/{}.png\u0026#39;.format(name))   ","description":"爬取所有QQ好友说说，分析词语出现的次数，生成词云","id":103,"section":"posts","tags":null,"title":"QQ-Friends-Word-Cloud","uri":"https://jiyang.site/posts/2018-02-10-qq-friends-word-cloud/"},{"content":" 快速排序-维基百科\n 一次快排分区的结果\nclass QuickSort { private int[] mArray; public QuickSort(int[] array) { this.mArray = array; } private void swap(int from, int to) { int t = mArray[from]; mArray[from] = mArray[to]; mArray[to] = t; } /** * 分区(原地版本) * * @param left 数组左侧 * @param right 数组末尾 * @return 分区下标 */ private int partition(int left, int right) { //选择左则作为分区基准值 int pivotValue = mArray[left]; //将基准移到尾部 swap(left, right); int storeIndex = left; for (int i = left; i \u0026lt; right; i++) { if (mArray[i] \u0026lt;= pivotValue) { swap(storeIndex, i); storeIndex++; } } //将基准移到分区位置 swap(right, storeIndex); return storeIndex; } /* * 分区(基础版本) * 以每次分区left元素为标志 */ private int partition(int left, int right) { int key = arr[left]; while (left \u0026lt; right) { while (left \u0026lt; right \u0026amp;\u0026amp; arr[right] \u0026gt;= key) { right--; } if (left \u0026lt; right) arr[left] = arr[right]; while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] \u0026lt; key) { left++; } if (left \u0026lt; right) arr[right] = arr[left]; } arr[left] = key; return left; } public void sort(int left, int right) { if (right \u0026gt; left) { //进行分区，返回分区下标 int pivotNewIndex = partition(left, right); sort(left, pivotNewIndex - 1); sort(pivotNewIndex + 1, right); } } } ","description":"","id":104,"section":"posts","tags":null,"title":"QuickSort快排","uri":"https://jiyang.site/posts/2017-08-12-quicksort%E5%BF%AB%E6%8E%92/"},{"content":"less /etc/hosts\n127.0.0.1 localhost 127.0.1.1 PC-UserName less /etc/resolv.conf\nnameserver 127.0.1.1 nameserver 172.22.0.1 每当任何应用程序在Linux操作系统中执行DNS查找时，它都会在“/ etc / hosts”和“/etc/resovl.conf”配置文件中查找以解析DNS名称。 在Linux的DNS查找顺序中，使用“/etc/nsswitch.conf”文件。 有两个库libc和glibc用于在Linux中执行此操作，方法是定义DNS查找顺序。\n/etc/nsswitch.conf file 在/etc/nsswitch.conf文件有一个称作 hosts 的 DNS 查找数据库\n1 2  $ less /etc/nsswitch.conf | grep \u0026#39;hosts\u0026#39; hosts: files mdns4_minimal [NOTFOUND=return] dns   首先，DNS查找将调查 /etc/hosts 文件来解析域名,然后查看 /etc/resolv.conf 文件来解析主机名。\n请注意：DNS查找指令（如nslookup和dig）将忽略 /etc/nsswitch.conf 文件，并始终使用 /etc/resolv.conf 引用DNS服务器。\n/etc/hosts 一个包含了域名解析的文本文件。每行包含 ip 地址和对应的域名\n/etc/resolv.conf 这是Linux操作系统中的另一个重要文件。 它包含帮助计算机将域名转换为IP地址的信息。\nnameserver 127.0.1.1 nameserver 172.22.0.1 也可以使用常见的共用DNS服务器:\nnameserver 8.8.8.8 nameserver 4.4.4.4  只要第一个DNS服务器正在运行并且活动，所有的绑定请求都会发送到它。 您到达第二个DNS服务器的唯一方法是，如果列表中的之前的DNS服务器已经死亡，并且在LONG超时之后。\n 上面有个系统默认的DNS解析服务地址127.0.1.1。\n$ ps -ef | grep 'dnsmasq' /usr/sbin/dnsmasq --listen-address=127.0.1.1 ubuntu下有一个本地的dns服务叫做dnsmasq，它是由NetworkManager控制。\n它监听的本地地址，\u0026ndash;listen-address=127.0.1.1 (ubuntu12.04及之前的版本 是 127.0.0.1)， 这个地址是一个本地回环地址而真实的dns服务器地址，是被这个服务管理维护着的由一张图表示就是：\nlocal process -\u0026gt; local dnsmasq -\u0026gt; router -\u0026gt; ISP dns\nDnsmasq 提供 DNS 缓存和 DHCP 服务功能。作为域名解析服务器(DNS)，dnsmasq可以通过缓存 DNS 请求来提高对访问过的网址的连接速度。作为DHCP 服务器，dnsmasq 可以用于为局域网电脑分配内网ip地址和提供路由。DNS和DHCP两个功能可以同时或分别单独实现。dnsmasq轻量且易配置，适用于个人用户或少于50台主机的网络。此外它还自带了一个 PXE 服务器。\nhttps://wiki.archlinux.org/index.php/Dnsmasq_(简体中文)\n比如ISP分配的DNS server是220.250.64.26，则dnsmasq会将客户端向127.0.0.1:53发出的DNS请求，转发到220.250.64.26:53 。\n参考:\n  http://www.looklinux.com/etchosts-vs-etcresolv-conf-in-linux/\n  https://www.jianshu.com/p/8f36fe09e39e\n  ","description":"因为连接Vpn引出的:Ubuntu中resolv.conf和hosts区别和联系","id":105,"section":"posts","tags":null,"title":"resolv.conf和hosts","uri":"https://jiyang.site/posts/2017-12-23-resolv.conf%E5%92%8Chosts/"},{"content":"Conflict 产生原因  当两个版本的同一文件之间的合并不能干净的执行时，就会产生合并冲突。\n 大多数情况下，Git可以自动完成合并，但有时却不行。例如，如果我们在新功能分支中更改了一行，但该行也在主分支中更改，Git不知道哪一行可以接受。当发生这种情况时，需要有人手动告诉Git使用哪个版本的，这会产生合并冲突。\n例如合并 master 分支到 dev:\na.txt文件产生冲突了:\n\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD dev modify ======= master modify \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; master HEAD 和 ======之间的版本是当前分支dev的修改\n====== 和 master之间的版本是master分支的修改\n修复冲突,手动保留某一个版本，如下:\ndev modify 提交冲突解决\ngit add a.txt git commit -m \u0026quot;Merge master fixed conflict.\u0026quot; ","description":"Resolve Github/GitLab's merge(pull) request conflict.","id":106,"section":"posts","tags":null,"title":"Resolve-Merge(Pull)-Request-Conflict","uri":"https://jiyang.site/posts/2017-12-13-resolve-mergepull-request-conflict/"},{"content":"通过客户端和服务端以指定时间间隔(小于超时时间)发送空数据包来避免SSH连接超时。\n 在客户端或服务端一侧进行如下配置即可\n 在客户端避免超时 编辑 Linux or Mac 的~/.ssh/config，添加如下:\n1  ServerAliveInterval 120   本地客户端将会每120秒发送一次空数据包到服务器，从而保持SSH连接存活。\n在服务端避免超时 编辑 /etc/ssh/sshd_config,添加如下，之后sudo service ssh reload:\n1 2  ClientAliveInterval 120 ClientAliveCountMax 720   服务器每120秒向客户端发送一次空数据包，从而保持SSH连接存活。ClientAliveCountMax意味者服务器不会主动断开客户端的连接，除非连接数达到了720。\n服务器这样配置后，客户端就不用上面的配置了。\n","description":"保持SSH会话存活，并避免SSH超时. Keep SSH sessions alive and prevent the SSH timeout.","id":107,"section":"posts","tags":null,"title":"Ssh-Keep-alive","uri":"https://jiyang.site/posts/2017-12-06-ssh-keep-alive/"},{"content":" 不同的线程可以通过同一个 ThreadLocal 对象获取只属于自己的数据。\n ThreadLocal.ThreadLocalMap ThreadLocal的内部类。是以ThreadLocal的 hash 值为数组下标，Entry元素为值的数组。ThreadLocalMap 内部是\u0008实现了一个类似 Map 的映射关系，内部的 Entry 继承自WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt;，它持有ThreadLocal的弱引用，保存ThreadLocal.set(value)传入的value。\n1 2 3 4 5 6 7 8 9  static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } }   ThreadLocal get 方法 1 2 3 4 5 6 7 8 9 10 11 12 13  public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); }   set 方法 1 2 3 4 5 6 7 8 9 10 11 12  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); }   使用地方有:  Android的消息循环机制(Looper Handler MessageQueue)就是基于这个。 \u0026hellip;  实例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class Main { static final ThreadLocal\u0026lt;String\u0026gt; mThreadLocal = new ThreadLocal\u0026lt;\u0026gt;(); public static void main(String[] args) { new Thread(\u0026#34;thread1\u0026#34;) { @Override public void run() { mThreadLocal.set(\u0026#34;value1\u0026#34;); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(currentThread().getName() + \u0026#34; localValue:\u0026#34; + mThreadLocal.get()); } }.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(\u0026#34;thread2\u0026#34;) { @Override public void run() { mThreadLocal.set(\u0026#34;value2\u0026#34;); System.out.println(currentThread().getName() + \u0026#34; localValue:\u0026#34; + mThreadLocal.get()); } }.start(); } }   输出:\n1 2  thread2 localValue:value2 thread1 localValue:value1   虽然是同一个ThreadLocal对象，而且都调用的同样的set get方法，但是get方法返回的值，一定是与当前线程对应的。\n","description":"","id":108,"section":"posts","tags":null,"title":"ThreadLocal理解","uri":"https://jiyang.site/posts/2017-08-02-threadlocal%E7%90%86%E8%A7%A3/"},{"content":"transient 关键字 transient关键字声明的成员变量，在序列化时会被忽略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  public abstract class Main { public static void main(String[] args) { User user = new User(\u0026#34;name\u0026#34;, \u0026#34;pwd\u0026#34;); try (ObjectOutputStream oop = new ObjectOutputStream(new FileOutputStream(\u0026#34;user.txt\u0026#34;))) { oop.writeObject(user); } catch (IOException e) { e.printStackTrace(); } User readUser = null; try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;user.txt\u0026#34;))) { readUser = (User) ois.readObject(); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } if (readUser != null) { System.out.println(readUser); } } } class User implements Serializable { String name; transient String pwd; public User(String name, String pwd) { this.name = name; this.pwd = pwd; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, pwd=\u0026#39;\u0026#34; + pwd + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } }   输出:\n1  User{name=\u0026#39;name\u0026#39;, pwd=\u0026#39;null\u0026#39;}   ","description":"","id":109,"section":"posts","tags":null,"title":"transient关键字","uri":"https://jiyang.site/posts/2017-07-30-transient%E5%85%B3%E9%94%AE%E5%AD%97/"},{"content":"  为内容增加padding。\n操作:\n  进入/home/\u0026lt;User\u0026gt;/.config/gtk-3.0\n  vi gtk.css\n  增加样式:\n  1 2 3 4 5  VteTerminal, TerminalScreen { padding: 10px 10px 10px 10px; -VteTerminal-inner-border: 10px 10px 10px 10px; }   重启Terminal  增加之前:\n增加之后:\n  配置ZSH和oh-my-zsh\n 安装zsh,参考oh-my-zsh\u0026rsquo;s wiki 安装了之后，会默认添加一些主题  3den.zsh-theme dst.zsh-theme intheloop.zsh-theme minimal.zsh-theme Soliah.zsh-theme adben.zsh-theme duellj.zsh-theme itchy.zsh-theme mira.zsh-theme sonicradish.zsh-theme ......  修改配置文件 ~/.zshrc  修改主题 ZSH_THEME=\u0026quot;amuse\u0026quot;  安装缺少字体 powerline  1 2 3  wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf mv PowerlineSymbols.otf ~/.fonts/    更新字体缓存  1  fc-cache -vf ~/.fonts/    配置字体  1  mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/    最后重启终端    ","description":"为Terminal的内容增加内边距,设置ZSH主题。","id":110,"section":"posts","tags":null,"title":"Ubuntu-Terminal-Style","uri":"https://jiyang.site/posts/2017-12-17-ubuntu-terminal-style/"},{"content":" 以StringRequest为例子，分析Volley是怎样执行一个网络请求的。\n 先看实现Request抽象类的StringRequest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class StringRequest extends Request\u0026lt;String\u0026gt; { private Listener\u0026lt;String\u0026gt; mListener; /** * Creates a new request with the given method. * * @param method the request {@link Method} to use * @param url URL to fetch the string at * @param listener Listener to receive the String response * @param errorListener Error listener, or null to ignore errors */ public StringRequest(int method, String url, Listener\u0026lt;String\u0026gt; listener, ErrorListener errorListener) { super(method, url, errorListener); mListener = listener; } }   Request有3个参数：\n method 对应请求的方式 url 请求的地址 errorListener 发生错误时回调  StringRequest多了一个自己的listener作为成功请求的回调接口。\nStringRequest实现了parseNetworkResponse方法。这个方法会传入一个NetworkResponse对象，包装了请求的响应结果。\n然后根据响应结结果header里的编码格式构造一个String对象，最后使用封装了最终请求的Response类构造一个代表成功的response返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13  @Override protected Response\u0026lt;String\u0026gt; parseNetworkResponse(NetworkResponse response) { String parsed; try { //根据编码格式构造字符串  parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); } catch (UnsupportedEncodingException e) { //如果格式不支持编码，就构造一个默认的UTF-8编码的字符串  parsed = new String(response.data); } return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); }   NetworkResponse封装了具体的请求内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class NetworkResponse implements Serializable{ /** * @param statusCode the HTTP status code * @param data Response body * @param headers Headers returned with this response, or null for none * @param notModified True if the server returned a 304 and the data was already in cache * @param networkTimeMs Round-trip network time to receive network response */ public NetworkResponse(int statusCode, byte[] data, Map\u0026lt;String, String\u0026gt; headers, boolean notModified, long networkTimeMs) { this.statusCode = statusCode; this.data = data; this.headers = headers; this.notModified = notModified; this.networkTimeMs = networkTimeMs; } }    StringReqeust 负责封装请求 NetworkResponse 负责封装从服务器返回的请求 Response 负责构造最终的结果。  RequestQueue的创建 Volley.newRequestQueue有几个重载方法，最终都会执行这个：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) { File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = \u0026#34;volley/0\u0026#34;; try { String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + \u0026#34;/\u0026#34; + info.versionCode; } catch (NameNotFoundException e) { } if (stack == null) { if (Build.VERSION.SDK_INT \u0026gt;= 9) { stack = new HurlStack(); } else { stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); } } Network network = new BasicNetwork(stack); RequestQueue queue; if (maxDiskCacheBytes \u0026lt;= -1){ queue = new RequestQueue(new DiskBasedCache(cacheDir), network); } else{ queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network); } queue.start(); return queue; }   其中执行了一些对象的创建工作：\n 创建缓存文件，文件名默认为volley 创建一个UserAgent字符串，代表HTTP头里的客户端身份。默认为包名+APPb版本号。 创建执行网络请求的工具。HurlStack(Android 2.3及以上)或HttpClientStack(Android 2.3以下)。Stack负责真正的HTTP请求。HurlStack使用的是HttpURLConnection;HttpClientStack使用的是HttpClient。 创建一个Netwoker对象。Netwoker通过调用Stack进行网络访问，并将执行结果封装为NetworkResponse对象。 创建一个RequestQueue对象，同时创建一个DiskBasedCache缓存对象，作为本地缓存。 RequestQueue创建完毕之后，就调用queue.start()开始不断执行添加到RequestQueue中的请求。  RequestQueue的创建： RequestQueue有3个构造函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //最终调用 public RequestQueue(Cache cache, Network network, int threadPoolSize, ResponseDelivery delivery) { mCache = cache; mNetwork = network; mDispatchers = new NetworkDispatcher[threadPoolSize]; mDelivery = delivery; } public RequestQueue(Cache cache, Network network, int threadPoolSize) { //会调用最终的构造函数  this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper()))); } public RequestQueue(Cache cache, Network network) { //会调用第二个  this(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE); }   三个构造函数最终都是调用最上面那个。第二个构造函数，则是创建了一个ExecutorDelivery对象，并在创建时传入了拥有UI线程的handler。\n可见ExecutorDelivery是与主线程打交道的工具。\n最后一个构造函数，则创建了：\n 一个NetworkDispatcher数组，数组大小为threadPoolSize，默认为4。  NetworkDispatcher NetworkDispatcher继承Thread。RequestQueue在创建时，创建了一个NetworkDispatcher数组，实际就是创建了一个线程数组。\n1 2 3 4 5 6 7 8 9 10 11 12  public class NetworkDispatcher extends Thread { /** The queue of requests to service. */ private final BlockingQueue\u0026lt;Request\u0026lt;?\u0026gt;\u0026gt; mQueue; /** The network interface for processing requests. */ private final Network mNetwork; /** The cache to write to. */ private final Cache mCache; /** For posting responses and errors. */ private final ResponseDelivery mDelivery; /** Used for telling us to die. */ private volatile boolean mQuit = false; }   NetworkDispatcher拥有：\n BlockingQueue\u0026lt;Request\u0026lt;?\u0026raquo; 一个保存者Request的阻塞队列 Network 执行网络访问，并返回结果 Cache 本地缓存 ResponseDelivery 负责与UI线程打交道。ReqeustQueue在创建时，创建的ExecutorDelivery就是一个实现了ResponseDelivery接口的类。 volatile boolen mQuit 一个多线程可以安全访问的布尔，负责结束线程  NetworkDispatcher既然继承自Thread，那么就实现了run方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  public void run() { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Request\u0026lt;?\u0026gt; request; while (true) { long startTimeMs = SystemClock.elapsedRealtime(); // release previous request object to avoid leaking request object when mQueue is drained.  request = null; try { // Take a request from the queue.  request = mQueue.take(); } catch (InterruptedException e) { // We may have been interrupted because it was time to quit.  if (mQuit) { return; } continue; } try { request.addMarker(\u0026#34;network-queue-take\u0026#34;); // If the request was cancelled already, do not perform the  // network request.  if (request.isCanceled()) { request.finish(\u0026#34;network-discard-cancelled\u0026#34;); continue; } addTrafficStatsTag(request); // Perform the network request.  NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\u0026#34;network-http-complete\u0026#34;); // If the server returned 304 AND we delivered a response already,  // we\u0026#39;re done -- don\u0026#39;t deliver a second identical response.  if (networkResponse.notModified \u0026amp;\u0026amp; request.hasHadResponseDelivered()) { request.finish(\u0026#34;not-modified\u0026#34;); continue; } // Parse the response here on the worker thread.  Response\u0026lt;?\u0026gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\u0026#34;network-parse-complete\u0026#34;); // Write to cache if applicable.  // TODO: Only update cache metadata instead of entire record for 304s.  if (request.shouldCache() \u0026amp;\u0026amp; response.cacheEntry != null) { mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\u0026#34;network-cache-written\u0026#34;); } // Post the response back.  request.markDelivered(); mDelivery.postResponse(request, response); } catch (VolleyError volleyError) { volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); } catch (Exception e) { VolleyLog.e(e, \u0026#34;Unhandled exception %s\u0026#34;, e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); } } }    设置当前线程的优先级为后台线程 从阻塞队列中获取一个request请求。这里使用的take方法，这个方法会阻塞线程，直到线程从队列中拿到了东西。 给request添加network-queue-take标记 调用netwoke的performRequest方法，并传入requset获取请求的结果networkResponse 给request添加network-http-complete标记 通过response判断是否是304状态码，如果是就调用request.finish()，并跳过下面步骤。否则继续下面的步骤。 使用request.parseNetworkResponse(networkResponse);创建一个Response对象response 给request添加network-parse-complete标记 将请求requset和结果response写入缓存。 调用request.markDelivered();表明，当前请求已被解决 调用mDelivery.postResponse(request, response);将请求和结果传递到UI线程。   这就是一个NetworkDispatcher线程执行一个Request的大致流程。\n ResponseDelivery-\u0026gt;ExecutorDelivery 在NetworkDispatcher线程中，最终结果是通过mDeliery这个ResponseDelivery对象传递到UI线程的。在创建NetworkDispatcher时，mDeliery被赋予的实际是ExecutorDelivery的实例。ExecutorDelivery是ResponseDelivery接口的实现类。\nExecutorDelivery类的postResponse方法：\n1 2 3 4 5 6 7 8 9 10  public void postResponse(Request\u0026lt;?\u0026gt; request, Response\u0026lt;?\u0026gt; response) { postResponse(request, response, null); } @Override public void postResponse(Request\u0026lt;?\u0026gt; request, Response\u0026lt;?\u0026gt; response, Runnable runnable) { request.markDelivered(); request.addMarker(\u0026#34;post-response\u0026#34;); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); }   postResponse 方法调用了 mResponsePoster的execute()方法，并传入了一个Runnable对象。\nmResponsePoster 对象是一个 Executor对象，并在 ExecutorDelivery 并创建时就创建。它的execute方法，就是调用\tRequestQueue在创建 ExecutorDelivery 传入的拥有UI线程的Looper的handler的post(Runnable)方法。\n1 2 3 4 5 6 7 8 9  public ExecutorDelivery(final Handler handler) { // Make an Executor that just wraps the handler.  mResponsePoster = new Executor() { @Override public void execute(Runnable command) { handler.post(command); } }; }   handler post 的runnable对象是一个内部类：在 run 方法里调用了\tRequest对象的deliverResponse deliverError finish方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  private class ResponseDeliveryRunnable implements Runnable { private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) { mRequest = request; mResponse = response; mRunnable = runnable; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) @Override public void run() { // If this request has canceled, finish it and don\u0026#39;t deliver.  if (mRequest.isCanceled()) { mRequest.finish(\u0026#34;canceled-at-delivery\u0026#34;); return; } // Deliver a normal response or error, depending.  if (mResponse.isSuccess()) { mRequest.deliverResponse(mResponse.result); } else { mRequest.deliverError(mResponse.error); } // If this is an intermediate response, add a marker, otherwise we\u0026#39;re done  // and the request can be finished.  if (mResponse.intermediate) { mRequest.addMarker(\u0026#34;intermediate-response\u0026#34;); } else { mRequest.finish(\u0026#34;done\u0026#34;); } // If we have been provided a post-delivery runnable, run it.  if (mRunnable != null) { mRunnable.run(); } } }   经过这样的转化，相当于Request的几个方法就是在UI线程执行了：\n1 2 3 4 5 6 7 8 9 10 11 12 13  //Requset自己实现的deliverError public void deliverError(VolleyError error) { if (mErrorListener != null) { mErrorListener.onErrorResponse(error); } } //StringRequest实现的Request的抽象方法deliverResponse protected void deliverResponse(String response) { if (mListener != null) { mListener.onResponse(response); } }   Requset的deliver方法实际就是调用的在创建Request的时候，传入的Listener接口的方法。\nVolley每创建一个消息队列，就创建了4个这样的NetworkDispatcher线程一直从请求队列中获取请求，然后执行，最后post到UI线程。4个线程都去拿请求，不会发生冲突是因为请求放在了BlockingQueue中，保证了每次take获取操作只有一个线程能获取。而且Volley的BlockingQueue使用的是PriorityBlockingQueue，这个队列在拥有BlockingQueue功能的同时，还对队列中的请求进行了排序。\nadd请求操作 RequestQueue中的线程们一直在跑着，它们不断的有序的从消息阻塞队列中拿请求，执行请求，传递到UI线程。\nReqeustQueue的add操作就是将请求添加到请求队列中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // Process requests in the order they are added. request.setSequence(getSequenceNumber()); request.addMarker(\u0026#34;add-to-queue\u0026#34;); // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) { mNetworkQueue.add(request); return request; } // Insert request into stage if there\u0026#39;s already a request with the same cache key in flight. synchronized (mWaitingRequests) { String cacheKey = request.getCacheKey(); if (mWaitingRequests.containsKey(cacheKey)) { // There is already a request in flight. Queue up.  Queue\u0026lt;Request\u0026lt;?\u0026gt;\u0026gt; stagedRequests = mWaitingRequests.get(cacheKey); if (stagedRequests == null) { stagedRequests = new LinkedList\u0026lt;Request\u0026lt;?\u0026gt;\u0026gt;(); } stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) { VolleyLog.v(\u0026#34;Request for cacheKey=%s is in flight, putting on hold.\u0026#34;, cacheKey); } } else { // Insert \u0026#39;null\u0026#39; queue for this cacheKey, indicating there is now a request in  // flight.  mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); } return request; }    如果加入的请求没有被缓存过，就直接加入到消息队列。直接加入不用获取消息队列的锁。因为消息队列是个BlockingQueue，本就支持并发操作。而且即使add操作是在UI线程，也不会阻塞UI线程，因为\nmNetworkQueue.add(request);内部是调用BlockingQueue的offer操作，offer入队操作不会阻塞线程，如果入队失败，它会返回false。   以上只是我分析的Volley的RequestQueue的大概执行过程。其中还有CacheQueue WaitRequests CurrentRequests等一些细节和HurlStack和HttpClientStack的网络请求部分没有具体分析。\n如果有哪里不对的，希望指正。\n ","description":"","id":111,"section":"posts","tags":null,"title":"Volley Source Code","uri":"https://jiyang.site/posts/2017-08-09-volley%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"content":"二叉树：\n AVL树(自平衡二叉树) 红黑树 哈夫曼树(最优二叉树)  B树不是二叉树\n二叉树  二叉树的第 $i$ 层至多拥有 $ 2^{i-1} $ 个节点数； 深度为 $k$ 的二叉树至多总共有 $2^{k+1} - 1$ 个节点数（定义根节点所在深度为$k_{0}=0$），而总计拥有节点数匹配的，称为“满二叉树”； 深度为 $k$ 有 $n$ 个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 $k$ 的满二叉树，序号为 $1$ 到 $n$ 的节点一对一对应时，称为“完全二叉树”。； 对任何一棵非空的二叉树 T , 如果其叶片(终端节点)数为 $n_{0}$，分支度为 $2$ 的节点数为 $n_{2}$，则 $n_{0}= n_{2} + 1$ 。  赫夫曼树(最优二叉树)  一颗带权路径长度最小的二叉树称作赫夫曼数(最优二叉树)。\n 赫夫曼算法  将n个权值集合F {$w_1$,$w_2$,$w_3$,\u0026hellip;,$w_i$} 看作 n 颗二叉树的集合   从下往上构建 选择两颗根结点权值最小的树作为左右子树构建一颗新的二叉树，新二叉树的根结点的权值为左、右子树上根结点之和。 从F中删除这辆颗树，同时将新得到的数加入 重复3到4，直到F中只剩一棵树为止。 最后一颗树就是最优二叉树。  二叉查找树（原理为二分查找）  左节点小于或等于父结点 右节点大于或等于父结点 最大查找次数为树的高度  红黑树(自平衡二叉查找树)  解决了二叉查找树在多次插入新的节点会破坏平衡的问题\n 解决方法为:\n 节点变色。通过将结点变为红或黑保持平衡 旋转。通过左旋转和右旋转保持平衡  ","description":"","id":112,"section":"posts","tags":["二叉树"],"title":"二叉树-B+树-AVL树-红黑树-哈夫曼树","uri":"https://jiyang.site/posts/2018-04-07-%E4%BA%8C%E5%8F%89%E6%A0%91-b+%E6%A0%91-avl%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"},{"content":"二叉树节点：\n1 2 3 4 5 6 7 8 9  class BinaryTreeNode { int val; BinaryTreeNode left; BinaryTreeNode right; public BinaryTreeNode(int val) { this.val = val; } }   访问节点操作 1 2 3  void visit(BinaryTreeNode node) { System.out.print(node.val + \u0026#34; \u0026#34;); }   二叉树节点数目  如果是空树：返回0 如果不是空树：节点数 = (左子树节点数)+(右子数节点数) + 1  1 2 3 4 5 6  int TreeNodeCount(BinaryTreeNode root) { if (root == null) { return 0; } return TreeNodeCount(root.left) + TreeNodeCount(root.right) + 1; }   求二叉树深度  如果是空树：返回0 如果不是空树：深度 = Max(左子树深度,右子树深度) + 1  1 2 3 4 5 6 7 8  int TreeDepth(BinaryTreeNode root) { if (root == null) { return 0; } int leftDepth = TreeDepth(root.left); int rightDepth = TreeDepth(root.right); return leftDepth \u0026gt; rightDepth ? (leftDepth + 1) : (rightDepth + 1); }   前序遍历  如果是空树：return 如果不是空树：根-\u0026gt;左-\u0026gt;右  1 2 3 4 5 6 7 8  void preOrderTraverse(BinaryTreeNode root) { if (root == null) { return; } visit(root); //访问根节点  preOrderTraverse(root.left); //前序遍历左子树  preOrderTraverse(root.right); //前序遍历右子树 }   非递归算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void preOrderByStack(Node head) { if (head == null) { return; } Stack\u0026lt;Node\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); Node cur = head; while (!stack.isEmpty() || cur != null) { while (cur != null) { System.out.print(cur.val + \u0026#34; \u0026#34;); //如果要改为中序遍历, 只用将这行移到 cur=stack.pop(); 后面  stack.push(cur); cur = cur.left; } if (!stack.isEmpty()) { cur = stack.pop(); cur = cur.right; } } }   中序遍历  如果是空树：return 如果不是空树：左-\u0026gt;根-右  1 2 3 4 5 6 7 8  void inOrderTraverse(BinaryTreeNode root) { if (root == null) { return; } inOrderTraverse(root.left); //中序遍历左子树  visit(root); //访问根节点  inOrderTraverse(root.right); //中序遍历右子树 }   后序遍历  如果是空树：return 如果不是空树：左-\u0026gt;右-\u0026gt;根  1 2 3 4 5 6 7 8  void postOrderTraverse(BinaryTreeNode root) { if (root == null) { return; } postOrderTraverse(root.left); //后序遍历左子树  postOrderTraverse(root.right); //后序遍历右子树  visit(root); //访问根节点 }   层序遍历(从上到下，从左到右)  使用队列实现：  队列初始化：将根节点入队 当队列不为空：弹出一个节点，访问，若左节点或右节点不为空，将其入队    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  void levelTraverse(BinaryTreeNode root){ if (root == null) { return; } Queue\u0026lt;BinaryTreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { BinaryTreeNode node = queue.poll(); visit(node); if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } }    python 实现  数组版\n1 2 3 4 5 6 7 8 9 10 11  def level_tranvel(root): row=[root] while row: new_row=[] for item in row: print(item.data) if item.left: new_row.append(item.left) if item.right: new_row.append(item.right) row = new_row   队列版\n1 2 3 4 5 6 7 8 9 10  def level_tranvel(root): if not root: return que = deque() que.append(root) while len(que)\u0026gt;0: node = que.popleft() print(node.data) if node.left: que.append(node.left) if node.right: que.append(node.right)   重建二叉树  根据前序遍历和中序遍历的结果重建二叉树\n 通过前序遍历的第一个元素为树的根找到根节点，然后在中序遍历中找到根节点的位置就能确定树的左右子树的节点数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  BinaryTreeNode reConstructBinaryTree(int[] pre, int[] in) { if (pre == null || in == null || pre.length \u0026lt;= 0 || in.length \u0026lt;= 0) { return null; } //储存根节点  BinaryTreeNode root = new BinaryTreeNode(pre[0]); int rootPositionInOrder = -1; //查找根节点在中序遍历的位置  for (int i = 0; i \u0026lt; in.length; i++) { if (root.val == in[i]) { rootPositionInOrder = i; break; } } if (rootPositionInOrder == -1) { return null; } //确定左子树节点数  int numOfLeft = rootPositionInOrder; //存储左子树前序遍历结果  int[] leftPre = new int[numOfLeft]; for (int i = 0; i \u0026lt; numOfLeft; i++) { leftPre[i] = pre[i + 1]; } //储存左子树中序遍历结果  int[] leftIn = new int[numOfLeft]; for (int i = 0; i \u0026lt; numOfLeft; i++) { leftIn[i] = in[i]; } //重建左子树  root.left = reConstructBinaryTree(leftPre, leftIn); //确定右子树节点数  int numOfRight = in.length - numOfLeft - 1; //储存右子树前序遍历结果  int[] rightPre = new int[numOfRight]; for (int i = 0; i \u0026lt; numOfRight; i++) { rightPre[i] = pre[i + numOfLeft + 1]; } //储存右子树中序遍历结果  int[] rightIn = new int[numOfRight]; for (int i = 0; i \u0026lt; numOfRight; i++) { rightIn[i] = in[i + numOfLeft + 1]; } //重建右子树  root.right = reConstructBinaryTree(rightPre, rightIn); return root; }   ","description":"","id":113,"section":"posts","tags":null,"title":"二叉树集锦","uri":"https://jiyang.site/posts/2017-08-15-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9B%86%E9%94%A6/"},{"content":" 纪录自己入门IOS\n To Do 利用到的IOS知识有:\n storyboard界面设计 IOS应用生命周期 视图控制器ViewController storyboard的界面跳转segue 数据和视图分离的MVC模式 存取简单的XML数据到本地 Text Field,Lable,Button,NavigationController,Table View Controller,Image View,Bar Button Item,Table View,Table View Cell的使用 UI控件和Controller绑定的方法 通过协议代理实现界面间数据传递  查看TO DO的完整代码，应用的制作过程是跟着Github上的kidscoding做的iOS开发初学者入门教程来的\n 从之前学习Android开发，自己就是从只有C和C++基础，然后先学习了Java的基本语法和数据类型之后，就直接混着Android SDK做应用开发了，随着后门开发的深入又学习了Java的其他特性。总结学习移动开发，先搞懂开发语言的基础知识和数据结构这些之后，就可以开始进行移动开发了。\n 于是学习了Objective-C的基础知识之后，便跟着教程做了这个简单的应用。\n在开始阶段学习的Objective-C基础有:\n  Objective-C特有的语法：\n 所有非面向对象的语法，包括变量类型，预处理器，流程控制，函数声明与调用都与C语言一致。 但有些C语言合法代码在objective-c中表达意思不一定相同。比如布尔表达式，Objective-C 中增加BOOL类型来表示YES、NO，注意不是TRUE、FALSE，Objective-C中，非零值未必是BOOL的YES，但是0 一定是NO。    消息传递\n Objective-C里，与其说对象互相调用方法，不如说对象之间互相传递消息更为精确 调用方法视为对对象发送消息，所有方法都被视为对消息的回应 一个类别不保证一定会回应收到的消息，如果类别收到了一个无法处理的消息，程序只会抛出异常，不会出错或崩溃    字符串\n Objective-C提供了一个字符串的包装类NSString，提供了许多常用的字符串操作方法 在普通的字符串前加一个@符号，就可以快速创建NSString对象    类\n    Interface 声明部分，清楚定义了类的名称、数据成员和方法。 以关键字@interface作为开始，@end作为结束\n  加号（+）代表类方法（Java里的静态方法)，减号（-）即是一般的实例方法（属于对象）\n  定义一个新的方法时，名称内的冒号（:）代表参数传递\n- (id)initWithString:(NSString*)aName withAge:(NSInterger)aAge;\n(方法的数据返回类型) 方法名: (参数1数据类型) 参数1变量名 参数2的描述:(参数2数据类型)参数2变量名\n  Implementation 实现类\n实现区块则包含了公开方法的实现，以及定义私有（private）变量及方法。 以关键字@implementation作为区块起头，@end结尾。\n  注意：不止声明区可定义实体变量，实现区也可以定义实体变量。二者的差别在于访问权限的不同。声明区默认权限为protected，实现区默认权限为private。所以类的私有信息就不需要暴露公开在声明区。\n  创建对象： 先调用类的alloc方申请内存，然后调用对象的init方法初始化\nMyObject * my = [[MyObject alloc] init];    在Objective-C 2.0里,如果创建对象不需要参数，则可直接使用new\n MyObject * my = [MyObject new];    set和get方法\n@interface Student : NSObject //实例变量 { int age; NSString* name; } //声明set方法 - (void)setAge:(int)aAge; - (void)setName:(NSString*)aName; //声明get方法 - (int)age; - (NSString*)name; @end @implementation Student //实现set get 方法 - (void)setAge:(int)aAge{ age = aAge; } - (void)setName:(NSString *)aName{ name = aName; } - (int)age{ return age; } - (NSString*)name{ return name; } @end int main(int argc, const char * argv[]) { @autoreleasepool { Student* stu = [[Student alloc]init]; [stu setAge:17]; [stu setName:@\u0026quot;Stu 001\u0026quot;]; NSLog(@\u0026quot;age:%d,name:%@\u0026quot;,stu.age,stu.name); //实现了set方法的实例变量，还可这样访问 stu.age = 18; stu.name = @\u0026quot;stu 002\u0026quot;; NSLog(@\u0026quot;age:%d,name:%@\u0026quot;,stu.age,stu.name); } return 0; }    属性\n 属性可以简化实例变量的set和get代码  @property 数据类型 属性名   还可以通过不同于实例变量名的属性对实例变量进行操作  @synthesize 属性名 = 实例变量名    @interface Student : NSObject\n@property int age;\n@property NSString* name;\n@end\n@implementation Student\n@end\nint main(int argc, const char * argv[]) {\n@autoreleasepool {\nStudent* stu = [[Student alloc]init];\nstu.age = 18;\nstu.name = @\u0026ldquo;stu 001\u0026rdquo;;\nNSLog(@\u0026ldquo;age:%d,name:%@\u0026quot;,stu.age,stu.name);\n}\nreturn 0;\n}\n  @interface Student : NSObject{ NSString* name; } @property int age; @property NSString* nameTemp; //name的get方法 - (NSString*)name; @end @implementation Student //对nameTemp的操作=对name的操作 @synthesize nameTemp = name; //实现name的get - (NSString*)name{ return name; } @end int main(int argc, const char * argv[]) { @autoreleasepool { Student* stu = [[Student alloc]init]; stu.age = 18; stu.nameTemp = @\u0026quot;stu 001\u0026quot;; NSLog(@\u0026quot;age:%d,name:%@\u0026quot;,stu.age,stu.name); } return 0; }   协议  类似Java里的接口    在Student类的生命前，这样定义协议\n@class Student; @protocol StudentDelegate - (void)showName:(Student*)student withName:(NSString*)name; @end  Teacher类声明它采纳了StudentDelegate协议\n#import \u0026quot;Student.h\u0026quot; @interface Teacher : NSObject \u0026lt;StudentDelegate\u0026gt; @end  Teacher就必须实现协议里的方法，使用了@optional修饰了的方法为可选方法，可不实现\n@implementation Teacher - (void)showName:(Student*)student withName:(NSString *)name{ NSLog(@\u0026quot;stu name :%@\u0026quot;,name); } @end    动态类型 id\n id 可以表示任意类型的实例   (void)showObj:(id)obj;\nobj可以是任意类型的实例    - (void)showObj:(id \u0026lt;StudentDelegate\u0026gt;)obj; obj必须是实现了StudentDelegate协议的实例  - (void)showObj:(NSString*)obj; obj必须是NSString* 类型的实例  ","description":"","id":114,"section":"posts","tags":null,"title":"从第一个应用-To-Do，纪录总结入门IOS第一课","uri":"https://jiyang.site/posts/2017-02-26-%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8-to-do%E7%BA%AA%E5%BD%95%E6%80%BB%E7%BB%93%E5%85%A5%E9%97%A8ios%E7%AC%AC%E4%B8%80%E8%AF%BE/"},{"content":" 使用 Beanstalkd 作为消息队列服务，然后结合 Python 的装饰器语法实现一个简单的异步任务处理框架.\n 最终效果 定义任务:\n1 2 3 4 5 6 7  from xxxxx.job_queue import JobQueue queue = JobQueue() @queue.task(\u0026#39;task_tube_one\u0026#39;) def task_one(arg1, arg2, arg3): # do task   提交任务:\n1  task_one.put(arg1=\u0026#34;a\u0026#34;, arg2=\u0026#34;b\u0026#34;, arg3=\u0026#34;c\u0026#34;)   然后就可以由后台的 work 线程去执行这些任务了。\n实现过程  了解 Beanstalk Server   Beanstalk is a simple, fast work queue. https://github.com/kr/beanstalkd\n Beanstalk 是一个 C 语言实现的消息队列服务。 它提供了通用的接口，最初设计的目的是通过异步运行耗时的任务来减少大量Web应用程序中的页面延迟。针对不同的语言，有不同的 Beanstalkd Client 实现。 Python 里就有 beanstalkc 等。我就是利用 beanstalkc 来作为与 beanstalkd server 通信的工具。\n任务异步执行实现原理  beanstalkd 只能进行字符串的任务调度。为了让程序支持提交函数和参数，然后由woker执行函数并携带参数。需要一个中间层来将函数与传递的参数注册。\n实现主要包括3个部分:\n Subscriber: 负责将函数注册到 beanstalk 的一个tube上,实现很简单，注册函数名和函数本身的对应关系。(也就意味着同一个分组(tube)下不能有相同函数名存在)。数据存储在类变量里。  1 2 3 4 5 6  class Subscriber(object): FUN_MAP = defaultdict(dict) def __init__(self, func, tube): logger.info(\u0026#39;register func:{} to tube:{}.\u0026#39;.format(func.__name__, tube)) Subscriber.FUN_MAP[tube][func.__name__] = func    JobQueue: 方便将一个普通函数转换为具有 Putter 能力的装饰器  1 2 3 4 5 6 7 8  class JobQueue(object): @classmethod def task(cls, tube): def wrapper(func): Subscriber(func, tube) return Putter(func, tube) return wrapper    Putter: 将函数名、函数参数、指定的分组组合为一个对象，然后 json 序列化为字符串，最后通过 beanstalkc 推送到beanstalkd 队列。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Putter(object): def __init__(self, func, tube): self.func = func self.tube = tube # 直接调用返回 def __call__(self, *args, **kwargs): return self.func(*args, **kwargs) # 推给离线队列 def put(self, **kwargs): args = { \u0026#39;func_name\u0026#39;: self.func.__name__, \u0026#39;tube\u0026#39;: self.tube, \u0026#39;kwargs\u0026#39;: kwargs } logger.info(\u0026#39;put job:{} to queue\u0026#39;.format(args)) beanstalk = beanstalkc.Connection(host=BEANSTALK_CONFIG[\u0026#39;host\u0026#39;], port=BEANSTALK_CONFIG[\u0026#39;port\u0026#39;]) try: beanstalk.use(self.tube) job_id = beanstalk.put(json.dumps(args)) return job_id finally: beanstalk.close()    Worker: 从 beanstalkd 队列中取出字符串，然后通过 json.loads 反序列化为对象，获得 函数名、参数和tube。最后从 Subscriber 中获得 函数名对应的函数代码，然后传递参数执行函数。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89  class Worker(object): worker_id = 0 def __init__(self, tubes): self.beanstalk = beanstalkc.Connection(host=BEANSTALK_CONFIG[\u0026#39;host\u0026#39;], port=BEANSTALK_CONFIG[\u0026#39;port\u0026#39;]) self.tubes = tubes self.reserve_timeout = 20 self.timeout_limit = 1000 self.kick_period = 600 self.signal_shutdown = False self.release_delay = 0 self.age = 0 self.signal_shutdown = False signal.signal(signal.SIGTERM, lambda signum, frame: self.graceful_shutdown()) Worker.worker_id += 1 import_module_by_str(\u0026#39;pear.web.controllers.controller_crawler\u0026#39;) def subscribe(self): if isinstance(self.tubes, list): for tube in self.tubes: if tube not in Subscriber.FUN_MAP.keys(): logger.error(\u0026#39;tube:{} not register!\u0026#39;.format(tube)) continue self.beanstalk.watch(tube) else: if self.tubes not in Subscriber.FUN_MAP.keys(): logger.error(\u0026#39;tube:{} not register!\u0026#39;.format(self.tubes)) return self.beanstalk.watch(self.tubes) def run(self): self.subscribe() while True: if self.signal_shutdown: break if self.signal_shutdown: logger.info(\u0026#34;graceful shutdown\u0026#34;) break job = self.beanstalk.reserve(timeout=self.reserve_timeout) # 阻塞获取任务，最长等待 timeout if not job: continue try: self.on_job(job) self.delete_job(job) except beanstalkc.CommandFailed as e: logger.warning(e, exc_info=1) except Exception as e: logger.error(e) kicks = job.stats()[\u0026#39;kicks\u0026#39;] if kicks \u0026lt; 3: self.bury_job(job) else: message = json.loads(job.body) logger.error(\u0026#34;Kicks reach max. Delete the job\u0026#34;, extra={\u0026#39;body\u0026#39;: message}) self.delete_job(job) @classmethod def on_job(cls, job): start = time.time() msg = json.loads(job.body) logger.info(msg) tube = msg.get(\u0026#39;tube\u0026#39;) func_name = msg.get(\u0026#39;func_name\u0026#39;) try: func = Subscriber.FUN_MAP[tube][func_name] kwargs = msg.get(\u0026#39;kwargs\u0026#39;) func(**kwargs) logger.info(u\u0026#39;{}-{}\u0026#39;.format(func, kwargs)) except Exception as e: logger.error(e.message, exc_info=True) cost = time.time() - start logger.info(\u0026#39;{} cost {}s\u0026#39;.format(func_name, cost)) @classmethod def delete_job(cls, job): try: job.delete() except beanstalkc.CommandFailed as e: logger.warning(e, exc_info=1) @classmethod def bury_job(cls, job): try: job.bury() except beanstalkc.CommandFailed as e: logger.warning(e, exc_info=1) def graceful_shutdown(self): self.signal_shutdown = True   写上面代码的时候，发现一个问题： 通过 Subscriber 注册函数名和函数本身的对应关系，是在一个Python解释器，也就是在一个进程里运行的，而 Worker 又是异步在另外的进程运行，怎么样才能让 Worker 也能拿到和 Putter 一样的 Subscriber。最后发现通过 Python 的装饰器机制可以解决这个问题。\n就是这句解决了 Subscriber 的问题\n1  import_module_by_str(\u0026#39;pear.web.controllers.controller_crawler\u0026#39;)   1 2 3 4 5  # import_module_by_str 的实现 def import_module_by_str(module_name): if isinstance(module_name, unicode): module_name = str(module_name) __import__(module_name)   执行 import_module_by_str 时， 会调用 __import__ 动态加载类和函数。将使用了 JobQueue 的函数所在模块加载到内存之后。当 运行 Woker 时，Python 解释器就会先执行 @修饰的装饰器代码，也就会把 Subscriber 中的对应关系加载到内存。\n实际使用可以看 https://github.com/jiyangg/Pear/blob/master/pear/jobs/job_queue.py\n","description":"","id":115,"section":"posts","tags":null,"title":"使用Beanstalkd做异步任务处理","uri":"https://jiyang.site/posts/2018-04-10-%E4%BD%BF%E7%94%A8beanstalkd%E5%81%9A%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"},{"content":" 继承View基类，画了这样的扇形图\n 直接来步骤吧  (参考了GcsSloop的教程)\n 1.分析  自定义View需要认真的分析下，里面还是会用到一些数学知识\n   首先是扇形该怎么表现\n 扇形的外观是个圆弧，而且是围绕一个中心点旋转一定角度构成的 View主要的绘制都是通过画布(canvas)进行，canvas里提供了许多绘制的方法。其中有一个 drawArc() 画圆弧的方法。  1 2 3  public void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter,@NonNull Paint paint) { drawArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter,paint); }      这个方法就给画扇形提供了捷径。\n 发现里面有个RectF参数，隐约有点是矩形的感觉，网查一下： 这个类包含一个矩形的四个单精度浮点坐标。矩形通过上下左右4个边的坐标来表示一个矩形  参数说明一下：\n oval :指定圆弧的外轮廓矩形区域 startAngle: 圆弧起始角度，单位为度。 sweepAngle: 圆弧扫过的角度，顺时针方向，单位为度。 useCenter: 如果为True时，在绘制圆弧时将圆心包括在内，通常用来绘制扇形。 paint: 绘制圆弧的画笔属性，如颜色，是否填充等。  1.1 分析需要哪些数据 参照上面的画圆弧函数的参数需求和上面那个结(cu)果(cao)图\n要使用canvas画扇形需要这些参数吧\n 外轮廓矩形 起始角度 扫过的角度 画笔  再看上面那个结(cu)果(cao)图，还需要\n 颜色 文字  这样就可以定义一个数据结构了\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class ViewData { public String name; //名字 \tpublic int value; //数值  public int color; //颜色 \tpublic float percentage; //百分比 \tpublic float angle; //角度  public ViewData(int value, String name) { this.value = value; this.name = name; } }   1.2 角度计算 扇形图应该反应的是里面每块扇形占总数的百分比，在我们的数据结构里应该是通过数值(value)计算出扇形区域占总体的比例和扫过的角度\n 比例 = 数值 / 各块数值之和 角度 = 比例 x 圆周(360度)  1.3 文字位置确定 文字不像扇形区域可以直接调用画布的圆弧方法绘制，文字使用画布的**drawText()**方法\n1 2 3  public void drawText(@NonNull String text, float x, float y, @NonNull Paint paint) { ...... }   查看源码可知需要传递字符内容、x坐标、y坐标和画笔，字符内容和画笔容易，就是坐标位置我们要好好想想\n 需要注意这里的文字的位置坐标都是基于canvas为父元素的\n 回到以前的数学应用题，先摆出我们有哪些已知量\n 扇形圆的半径 每块扇形的扫过的角度 起始的角度  想想根据这些数据，应该可以求出文字位置(上图黑圆点)的坐标\n 文字位置角度 = 起始角度 + 扇形块角度/2 文字x坐标 = 半径/2 x cos(文字位置角度) 文字y坐标 = 半径/2 x sin(文字位置角度)   分析差不多了，开始实践了\n 2 实践 2.1 数据结构 1 2 3 4 5 6 7 8 9 10 11 12 13  public class ViewData { public String name; //名字  public int value; //数值  public int color; //颜色  public float percentage; //百分比  public float angle; //角度  public ViewData(int value, String name) { this.value = value; this.name = name; } }   2.2 View实现  先来一张图镇店\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96  public class MyView extends View { private int[] mColors = {Color.BLUE, Color.DKGRAY, Color.CYAN, Color.RED, Color.GREEN}; private Paint paint; //画笔 \tprivate ArrayList\u0026lt;ViewData\u0026gt; viewDatas; //数据集 \tprivate int w; //View宽高 \tprivate int h; private RectF rectF; //矩形  public MyView(Context context) { super(context); initPaint(); //设置画笔 \t} //设置数据 \tpublic void setData(ArrayList\u0026lt;ViewData\u0026gt; viewDatas) { this.viewDatas = viewDatas; initData(); //设置数据的百分度和角度 \tinvalidate(); //刷新UI \t} public MyView(Context context, AttributeSet attrs) { super(context, attrs); initPaint(); } public MyView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); initPaint(); } //初始化画笔 \tprivate void initPaint() { paint = new Paint(); //设置画笔默认颜色 \tpaint.setColor(Color.WHITE); //设置画笔模式：填充 \tpaint.setStyle(Paint.Style.FILL); // \tpaint.setTextSize(30); //初始化区域 \trectF = new RectF(); } //确定View大小 \t@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) { super.onSizeChanged(w, h, oldw, oldh); this.w = w; //获取宽高 \tthis.h = h; } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.translate(w / 2, h / 2); //将画布坐标原点移到中心位置 \tfloat currentStartAngle = 0; //起始角度 \tfloat r = (float) (Math.min(w, h) / 2); //饼状图半径(取宽高里最小的值) \trectF.set(-r, -r, r, r); //设置将要用来画扇形的矩形的轮廓 \tfor (int i = 0; i \u0026lt; viewDatas.size(); i++) { ViewData viewData = viewDatas.get(i); paint.setColor(viewData.color); //绘制扇形(通过绘制圆弧) \tcanvas.drawArc(rectF, currentStartAngle, viewData.angle, true, paint); //绘制扇形上文字 \tfloat textAngle = currentStartAngle + viewData.angle / 2; //计算文字位置角度 \tpaint.setColor(Color.BLACK); float x = (float) (r / 2 * Math.cos(textAngle * Math.PI / 180)); //计算文字位置坐标 \tfloat y = (float) (r / 2 * Math.sin(textAngle * Math.PI / 180)); paint.setColor(Color.YELLOW); //文字颜色 \tcanvas.drawText(viewData.name, x, y, paint); //绘制文字  currentStartAngle += viewData.angle; //改变起始角度 \t} } private void initData() { if (null == viewDatas || viewDatas.size() == 0) { return; } float sumValue = 0; //数值和 \tfor (int i = 0; i \u0026lt; viewDatas.size(); i++) { ViewData viewData = viewDatas.get(i); sumValue += viewData.value; int j = i % mColors.length; //设置颜色 \tviewData.color = mColors[j]; } for (ViewData data : viewDatas) { float percentage = data.value / sumValue; //计算百分比 \tfloat angle = percentage * 360; //对应的角度 \tdata.percentage = percentage; data.angle = angle; } } }    最终实现效果就是开头那张了，自定义View还有很长路要走\n 完整代码请移步这里\n","description":"","id":116,"section":"posts","tags":null,"title":"分析实现Android自定义View之扇形图","uri":"https://jiyang.site/posts/2016-12-25-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E6%89%87%E5%BD%A2%E5%9B%BE/"},{"content":" 继上次分析实现Android自定义View之扇形图之后，自己又画了下面的这个递增直方图，本来是想做个静态的直方图就完了，结果想想静态的没啥趣味，于是就加了递增\n 1 从分析最终效果  界面上要展现的东西有：x和y两个坐标轴 主角直方图每列 直方图顶部文字  2 再分析，要在屏幕上画这样的竖直列，怎样画？  在屏幕上画图就是给指定的屏幕坐标点上色\n 于是就想到只要能给出每列的起始坐标和高度的终点坐标，然后给起点和终点之间的点全部上色，最终就应该能有这样的效果\n接着去看我们的绘画师（canvas）有哪些工具能给我使用，找到有这两个工具，可能可以给我们使用\ndrawPoint 画点 drawLine 画直线 再想想刚才想的：把起点和终点之间的点全部上色，不就是在起点和终点之间画一条直线嘛，想把线画成像直方图，可以直接把画笔调粗点不就可以了\n确定了，就用drawLine来试试\n3 接着把界面上的元素转换为数据 看看每列直方图有哪些属性:\n 最明显：颜色 color 顶上的描述：name 底部的位置应该用x轴坐标来描述吧：x 每列的高度：y  于是肯定就需要一个bean来存放每列直方图的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class HistogramData { public int value; //数值  public String name; //文字描述  public float persentage; //占数据总数的百分比  public float y; //在直方图上的x轴坐标  public float x; //在直方图上的y轴坐标  public int color; //填充颜色  public HistogramData(int value, String name) { this.value = value; this.name = name; } }   4 结合Android的屏幕坐标，分析：  Andriod屏幕的坐标系统默认是左上角为原点，正方向x轴向右，y轴向下 View的画布（canvas）的坐标系统默认和屏幕的一样  而直方图的坐标系是以左下角为原点，所以首先就要获取直方图View画布在屏幕中的尺寸，然后找到左下角的点作为直方图的原点\n获取View在屏幕中的尺寸，只需在onSizeChanged中就可以得到\n1 2 3 4 5  protected void onSizeChanged(int w, int h, int oldw, int oldh){ super.onSizeChanged(w, h, oldw, oldh); this.w = w - 10; this.h = h - 10; }   这里减去10，是为了让直方图原点距离画布编辑有一定间隔\n 由于画布坐标和直方图坐标的y轴方向是相反的，所以后面有关坐标的计算需要注意  如图：计算每列直方图的y轴坐标时，就需要通过***( h - 列高度 )***来得到，使用**drawLine**画线时还是这样\n1  canvas.drawLine(histogramData.x, h, histogramData.x, histogramData.y,paint);   竖直方向是画从h到y的直线，而不是从0到y的直线\n5 具体实现 通过上面的分析，基本上已经可以开始画直方图了\n会用到的变量\n1 2 3 4 5 6 7  int[] mColors = {Color.BLUE, Color.DKGRAY, Color.CYAN, Color.RED, Color.GREEN}; ArrayList\u0026lt;HistogramData\u0026gt; datas; Paint paint; //画笔 int mWidth = 70; //直方图宽 int width2 = 20; //直方图间距 int w; //画布宽 int h; //画布高   在onSizeChanged方法里确定了画布宽高之后，就会走到onDraw里开始画画\n画直方图坐标 1 2 3 4  paint.setColor(Color.BLACK); paint.setStrokeWidth(5); canvas.drawLine(10, h, w, h, paint); //画坐标系X轴 \tcanvas.drawLine(10, h, 10, 10, paint); //画坐标系Y轴   画每列直方图 1 2 3 4 5 6 7 8 9 10 11 12 13 14  paint.setStrokeWidth(mWidth); paint.setStyle(Paint.Style.STROKE); if (null == datas) { return; } for (int i = 0; i \u0026lt; datas.size(); i++) { HistogramData histogramData = datas.get(i); paint.setColor(histogramData.color); canvas.drawLine(histogramData.x, h, histogramData.x, histogramData.y,paint); //直方图顶部文字  paint.setColor(Color.BLACK); paint.setStyle(Paint.Style.FILL); canvas.drawText(histogramData.name, histogramData.x - mWidth / 4, histogramData.y - 10, paint); }   6 实现递增 递增的实现主要是在数据处理的时候加上了线程和handler\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public void setData(ArrayList\u0026lt;HistogramData\u0026gt; data) { this.datas = data; if (null == datas || datas.size() == 0) { return; } myHandler = new MyHandler(this); new Thread(new Runnable() { @Override public void run() { //计算数据总和  float sum = 0; for (int i = 0; i \u0026lt; datas.size(); i++) { sum += datas.get(i).value; } //计算数据占总数的百分比  for (int i = 0; i \u0026lt; datas.size(); i++) { HistogramData histogramData = datas.get(i); histogramData.persentage = histogramData.value / sum; } //计算单列数据高度，并缓慢增加  float startX, endY; for (int i = 0; i \u0026lt; datas.size(); i++) { HistogramData histogramData = datas.get(i); startX = (i + 1) * mWidth + i * width2; endY = HistogramView.this.h - histogramData.persentage * HistogramView.this.h; histogramData.color = mColors[i % mColors.length]; //注意：画布的坐标是左上角为原点，所以是  // 从 画布高-10 为起点, 数据高度 为终点  // 递减  for (int j = HistogramView.this.h; j \u0026gt;= endY; j--) { histogramData.x = startX; histogramData.y = j; //通知UI更新  myHandler.sendEmptyMessage(0); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } } } } }).start(); }   完整代码请移步\n","description":"","id":117,"section":"posts","tags":null,"title":"分析实现Android自定义View之递增直方图","uri":"https://jiyang.site/posts/2016-12-30-%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0android%E8%87%AA%E5%AE%9A%E4%B9%89view%E4%B9%8B%E9%80%92%E5%A2%9E%E7%9B%B4%E6%96%B9%E5%9B%BE/"},{"content":" 作为Chrome的重度使用者，解决了访问Google的问题之后，书签又经常不能同步。\n 利用Chrome的Api接口获取所有书签，然后上传到自己的服务器数据库保存。本来想使用七牛云的接口储存，但是七牛云只能上传文件保存。所以自己实现了一个简单的Flask框架Python后台来保存。\n 上传书签到服务器 从服务器拉取书签恢复(待实现)  {: .center-img}\n179个书签上传成功\n{: .center-img}\n主要逻辑:\n chrome.bookmarks.getTree()接口返回的书签数据是数组和树结合的，使用递归比较方便提取。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67  document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { getBookmarks(); }); var bookmarks; function getBookmarks(){ bookmarks = [] chrome.bookmarks.getTree(function(result){ for(var i=0;i\u0026lt;result.length;i++){ reversBookmarks(result[i]); } syncBook(); }); } function reversBookmarks(result){ if(result==null){ return; } var bookmark = { id:result.id == null ? 0 : result.id, parentId:result.parentId == null ? 0 : result.parentId, index:result.index == null ? 0 : result.index, url:result.url == null ? \u0026#39;None\u0026#39; : result.url, title:result.title == null ? \u0026#39;None\u0026#39; : result.title } bookmarks.push(bookmark) if(result.children==null){ return; } for(var i=0; i\u0026lt;result.children.length;i++){ reversBookmarks(result.children[i]); } } function syncBook(){ jsonStr = JSON.stringify({data:bookmarks}); $.ajax({ type: \u0026#34;post\u0026#34;, url: \u0026#34;http://***/uploadBookmark\u0026#34;, async: \u0026#34;true\u0026#34;, data: { \u0026#39;key\u0026#39;:new Date().toLocaleDateString(), \u0026#39;data\u0026#39;:jsonStr }, success: function (data,status) { console.log(data); obj = JSON.parse(data); code = obj.code; count = obj.count; error = obj.error;\t$(\u0026#39;#loading\u0026#39;).hide(); if(code==0){ $(\u0026#39;#sync\u0026#39;).text(\u0026#39;OK!Synced \u0026#39;+count+\u0026#39; bookmarks.\u0026#39;); }else{ $(\u0026#39;#sync\u0026#39;).text(\u0026#39;Failed! Error:\u0026#39;+error+\u0026#39; Status:\u0026#39;+status); $(\u0026#39;#btnRetry\u0026#39;).show(); } }, error: function (error) { $(\u0026#39;#loading\u0026#39;).hide(); $(\u0026#39;#sync\u0026#39;).text(\u0026#39;Failed! Error:\u0026#39;+error); $(\u0026#39;#btnRetry\u0026#39;).show(); } }); }   后台实现:\n1 2 3 4 5  @app.route(\u0026#39;/uploadBookmark\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def uploadBookMark(): key = request.form.get(\u0026#39;key\u0026#39;) data = request.form.get(\u0026#39;data\u0026#39;) return dbBookmark.saveBookMark(key, data)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  import json import os import sqlite3 PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__)) DATABASE = os.path.join(PROJECT_ROOT, \u0026#39;bookmark.chromeExtension\u0026#39;) def initDB(): conn = None try: conn = sqlite3.connect(DATABASE) cursor = conn.cursor() cursor.execute( \u0026#39;CREATE TABLE bookmark (id INT PRIMARY KEY , parentId INT, indexId INT,url VARCHAR (20),title VARCHAR(20))\u0026#39;) cursor.close() conn.commit() except BaseException as e: print e finally: if conn: conn.close() def saveBookMark(key, data): bookMarks = json.loads(data) data = bookMarks.get(\u0026#39;data\u0026#39;) conn = None count = 0 error = \u0026#39;null\u0026#39; try: conn = sqlite3.connect(DATABASE) cursor = conn.cursor() sql = \u0026#34;DELETE FROM bookmark\u0026#34; cursor.execute(sql) for bookMark in data: id = bookMark.get(\u0026#39;id\u0026#39;) pId = bookMark.get(\u0026#39;parentId\u0026#39;) iId = bookMark.get(\u0026#39;index\u0026#39;) url = bookMark.get(\u0026#39;url\u0026#39;).encode(\u0026#39;utf-8\u0026#39;) title = bookMark.get(\u0026#39;title\u0026#39;).encode(\u0026#39;utf-8\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34; \u0026#34;) sql = \u0026#34;INSERT INTO bookmark (id,parentId,indexId,url,title) VALUES (\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;,\u0026#39;{}\u0026#39;)\u0026#34; \\ .format(id, pId, iId, url, title) try: cursor.execute(sql) count = count + cursor.rowcount except Exception as e: print e error = e.message cursor.close() conn.commit() except Exception as e: error = e.message finally: if conn: conn.close() if count == 0: return \u0026#39;{\u0026#34;code\u0026#34;:%d,\u0026#34;count\u0026#34;:%d,\u0026#34;error\u0026#34;:\u0026#34;%s\u0026#34;}\u0026#39; % (-1, count, error) else: return \u0026#39;{\u0026#34;code\u0026#34;:%d,\u0026#34;count\u0026#34;:%d,\u0026#34;error\u0026#34;:\u0026#34;%s\u0026#34;}\u0026#39; % (0, count, error)    参考Chrome开发文档:developer.chrome.com/extensions/bookmarks\n ","description":"","id":118,"section":"posts","tags":null,"title":"制作Chrome书签同步插件","uri":"https://jiyang.site/posts/2017-09-12-%E5%88%B6%E4%BD%9Cchrome%E4%B9%A6%E7%AD%BE%E5%90%8C%E6%AD%A5%E6%8F%92%E4%BB%B6/"},{"content":" 回顾大二的数据结构知识。从数组开始。实现了一个可自动扩充容量的泛型数组。\n 头文件:Array.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #ifndef Array_hpp #define Array_hpp  template \u0026lt;class T\u0026gt; class Array{ private: T *base; //数组首地址  int length; //数组中元素  int size; //数组大小,以数组中元素的大小为单位 public: //初始化数组，分配内存  bool init(); //检查内存是否够用，不够用就增加  bool ensureCapcity(); //添加元素到数组尾  bool add(T item); //插入元素到数组的具体位置，位置从1开始  bool insert(int index,T item); //删除指定位置的元素并返回，位置从1开始  T del(int index); //返回指定位置的元素  T objectAt(int index); //打印数组所有元素  void display(); }; #endif /* Array_hpp */   实现:Array.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  #include \u0026#34;Array.hpp\u0026#34;#include \u0026lt;mm_malloc.h\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; template\u0026lt;typename T\u0026gt; bool Array\u0026lt;T\u0026gt;::init(){ base = (T *)malloc(10*sizeof(T)); if(!base){ return false; } size = 10; length = 0; return true; } template\u0026lt;typename T\u0026gt; bool Array\u0026lt;T\u0026gt;::ensureCapcity(){ if(length \u0026gt;= size){ T *newBase = (T*)realloc(base,10 * sizeof(T) + size); if(!newBase){ return false; } base = newBase; size += 10; newBase = nullptr; } return true; } template\u0026lt;typename T\u0026gt; bool Array\u0026lt;T\u0026gt;::add(T item){ if(!ensureCapcity()){ return false; } T *p = base + length; *p = item; length ++; return true; } template\u0026lt;typename T\u0026gt; bool Array\u0026lt;T\u0026gt;::insert(int index,const T item){ if(!ensureCapcity()){ return false; } if(index \u0026lt; 1 || index \u0026gt; length){ return false; } T *q = base + index - 1; T *p = base + length - 1; while( p \u0026gt;= q){ *(p+1) = *p; p--; } *q = item; q = nullptr; p = nullptr; length ++; return true; } template\u0026lt;typename T\u0026gt;T Array\u0026lt;T\u0026gt;::del(int index){ if(index\u0026lt;1 || index \u0026gt; length){ return NULL; } T *q = base + index - 1; T item = *q; ++q; T *p = base + length; while(q \u0026lt;= p){ *(q-1)=*q; ++q; } length --; return item; } template\u0026lt;typename T\u0026gt;T Array\u0026lt;T\u0026gt;::objectAt(int index){ if(index\u0026lt;1 || index \u0026gt; length){ return NULL; } T *q = base; return *(q + index - 1); } template \u0026lt;typename T\u0026gt;void Array\u0026lt;T\u0026gt;::display(){ T *q = base; T *p = base +length - 1; while (q\u0026lt;=p) { cout \u0026lt;\u0026lt; *(q++)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; }   使用:\n1 2 3 4 5 6 7 8 9 10 11 12  #include \u0026lt;iostream\u0026gt;#include \u0026#34;Array.cpp\u0026#34;using namespace std; int main(int argc, const char * argv[]) { Array\u0026lt;int\u0026gt; array = *new Array\u0026lt;int\u0026gt;; array.init(); array.add(1); array.insert(1,2); array.objectAt(1); return 0; }   ","description":"","id":119,"section":"posts","tags":["数组"],"title":"动态数组C++实现","uri":"https://jiyang.site/posts/2017-05-31-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84c++%E5%AE%9E%E7%8E%B0/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #ifndef LinkList_hpp #define LinkList_hpp  typedef struct Node{ int data; Node* next; Node* pre; }Node; class LinkList{ private: Node *head; Node *tail; int length; public: LinkList(); //分配内存，构建节点  Node* makeNode(); //添加节点到链表尾  bool push(int data); //弹出链表最后一个节点，并返回值  int pop(); //通过index来查找链表中的元素  int objectAt(int index); //插入元素到指定位置的前方  bool insert(int index,int data); //打印链表的所有元素  void display(); }; #endif /* LinkList_hpp */  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85  #include \u0026#34;LinkList.hpp\u0026#34;#include \u0026lt;iostream\u0026gt;#include \u0026lt;mm_malloc.h\u0026gt; using namespace std; LinkList::LinkList(){ head = makeNode(); tail = head; length = 0; } Node * LinkList::makeNode(){ Node* node = (Node*)malloc(sizeof(Node)); return node; } bool LinkList::push(int data){ Node *node = makeNode(); if(!node){ return false; } node-\u0026gt;data = data; node-\u0026gt;pre = tail; tail-\u0026gt;next = node; tail = node; length ++; return true; } int LinkList::pop(){ int data = 0; Node* node = head-\u0026gt;next; while (node-\u0026gt;next) { node = node-\u0026gt;next; } data = node-\u0026gt;data; tail = node-\u0026gt;pre; tail-\u0026gt;next = node-\u0026gt;next; length--; free(node); node = NULL; return data; } int LinkList::objectAt(int index){ if(index\u0026lt;1 || index \u0026gt; length){ return 0; } int data = 0; Node* q = head; for(int i=0; i \u0026lt; index;i++){ q = q-\u0026gt;next; } data = q-\u0026gt;data; return data; } bool LinkList::insert(int index, int data){ if(index\u0026lt;1 || index\u0026gt; length){ return false; } Node *p = makeNode(); p-\u0026gt;data = data; Node *q = head; for(int i=0; i \u0026lt; index; i++){ q = q-\u0026gt;next; } p-\u0026gt;pre = q-\u0026gt;pre; p-\u0026gt;next = q; q-\u0026gt;pre-\u0026gt;next = p; q-\u0026gt;pre = p; length ++; return true; } void LinkList::display(){ Node *n = head-\u0026gt;next; cout\u0026lt;\u0026lt;\u0026#34;data:\u0026#34;; while (n) { cout\u0026lt;\u0026lt;n-\u0026gt;data\u0026lt;\u0026lt;\u0026#34; \u0026#34;; n = n-\u0026gt;next; } cout \u0026lt;\u0026lt; endl; }   ","description":"","id":120,"section":"posts","tags":["链表"],"title":"双向链表C++实现","uri":"https://jiyang.site/posts/2017-05-31-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8c++%E5%AE%9E%E7%8E%B0/"},{"content":"如果一个单词通过循环右移获得的单词，我们称这些单词都为一种循环单词。 例如：picture 和 turepic 就是属于同一种循环单词。 现在给出n个单词，需要统计这个n个单词中有多少种循环单词。\n  输入描述:\n 输入包括n+1行： 第一行为单词个数n(1 ≤ n ≤ 50) 接下来的n行，每行一个单词word[i]，长度length(1 ≤ length ≤ 50)。由小写字母构成    输出描述:\t输出循环单词的种数\n  输入例子:\n5 picture turepic icturep word ordw 输出例子:\n2\n Java解决方案:\n  使用队列Queue LinkedList来获取一个单词对应的所有可能的循环单词 使用Set来存储这些循环单词避免重复 使用Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt;来存储所有输入单词的循环单词，确保同一类的循环单词只存在一份  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  import java.util.HashSet; import java.util.LinkedList; import java.util.Queue; import java.util.Scanner; import java.util.Set; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int n = Integer.parseInt(scanner.nextLine()); String[] words = new String[n]; int i = 0; while (i \u0026lt; n) { words[i++] = scanner.nextLine(); } scanner.close(); Set\u0026lt;Set\u0026lt;String\u0026gt;\u0026gt; sSets = new HashSet\u0026lt;\u0026gt;(); for (String string : words) { sSets.add(getWords(string)); } System.out.println(sSets.size()); } static Set\u0026lt;String\u0026gt; getWords(String s) { Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Queue\u0026lt;Character\u0026gt; characters = new LinkedList\u0026lt;\u0026gt;(); char[] cs = s.toCharArray(); for (char c : cs) { characters.offer(c); } for (int i = 0; i \u0026lt; cs.length; i++) { characters.poll(); characters.offer(cs[i]); StringBuilder builder = new StringBuilder(); for (Character character : characters) { builder.append(character); } set.add(builder.toString()); } return set; } }   ","description":"","id":121,"section":"posts","tags":null,"title":"循环单词问题","uri":"https://jiyang.site/posts/2017-07-24-%E5%BE%AA%E7%8E%AF%E5%8D%95%E8%AF%8D%E9%97%AE%E9%A2%98/"},{"content":"斐波拉契数列的第n项 斐波拉契数列:\n a(0) = 0 a(1) = 1 a(2) = 1 a(n) = a(n-1) + a(n-2)  递归实现 1 2 3 4 5 6 7 8  long fab1(int n) { if (n \u0026lt; 3) { return 1; } return fab1(n - 2) + fab1(n - 1); }   「遍历数组」实现 1 2 3 4 5 6 7 8 9 10 11  long fab2(int n) { long nums[n]; nums[0] = 1; nums[1] = 1; for (int i = 2; i \u0026lt; n; i++) { nums[i] = nums[i - 2] + nums[i - 1]; } return nums[n - 1]; }   「滚动数组」实现 1 2 3 4 5 6 7 8 9 10 11 12 13  long fab3(int n) { long first = 1; long second = 1; long current = 1; for (int i = 3; i \u0026lt;= n; i++) { current = first + second; first = second; second = current; } return current; }   测试比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #include \u0026lt;iostream\u0026gt;#include \u0026lt;ctime\u0026gt; using namespace std; void fun_cost(long (*func)(int), int n) { time_t begin, end; time(\u0026amp;begin); long result = (*func)(n); time(\u0026amp;end); double difference = difftime(end, begin); const char *format = \u0026#34;n: %d result: %ld cost: %f\u0026#34;; int len = snprintf(NULL, 0, format, n, result, difference); char *s = (char *)malloc(len + 1); sprintf(s, format, n, result, difference); std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } int main() { fun_cost(fab1, 45); fun_cost(fab2, 45); fun_cost(fab3, 45); return 0; }   结果:    n result 耗时     n: 45 result: 1134903170 cost: 4.000000   n: 45 result: 1134903170 cost: 0.000000   n: 45 result: 1134903170 cost: 0.000000    总结  递归版: 理解相对简单, 但是递归调用遇到大数时, 将会造成很深的调用栈, 耗费内存和运行时间O(n^2) 「遍历数组」: 时间复杂度O(n), 空间复杂度为O(n) 「滚动数组」: 方法最优, 时间复杂度为O(n), 空间复杂度为常量(3)  ","description":"","id":122,"section":"posts","tags":null,"title":"斐波拉契数列","uri":"https://jiyang.site/posts/2017-08-12-%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%95%B0%E5%88%97/"},{"content":"求两个数的最大公约数 1 2 3 4 5 6 7 8  long gcd(long m, long n) { while (n != 0) { long ren = m % n; m = n; n = ren; } return m; }   幂运算 时间复杂度为O(logN)的算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * 求幂运算 * * @param x * 底数 * @param n * 指数 * @return 结果 */ long pow(int x, int n) { if (n == 0) { return 1; } if (n % 2 == 0) { return pow(x * x, n / 2); } else { return pow(x * x, n / 2) * x; } }   阶乘 传统递归版:\n1 2 3  long fab(n) { return n==1 ? 1 : n * fab(n-1); }   尾递归版:\n 尾递归: 避免每一次递归都在堆栈中保存一个局部变量(普通递归会在每个栈中存储中间值n)。性能更优，可防止内存溢出。\n 1 2 3 4 5 6 7 8  long fab(n) { return fab(n,1); } long fab(n,a) { return n==1? a : fab(n-1,n*a); }   ","description":"","id":123,"section":"posts","tags":null,"title":"求最大公约数、幂运算","uri":"https://jiyang.site/posts/2017-10-24-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E5%B9%82%E8%BF%90%E7%AE%97-%E9%98%B6%E4%B9%98/"},{"content":"ThreadPoolExecutor组成 ThreadPoolExecutor的核心构造函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize \u0026lt; 0 || maximumPoolSize \u0026lt;= 0 || maximumPoolSize \u0026lt; corePoolSize || keepAliveTime \u0026lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; }   根据构造方法可以看才ThreadPoolExecutor主要分为以下几个部分:\n corePoolSize：核心线程池能容纳的线程数 maximumPoolSize：线程池最大能容纳的线程数(实际是当核心线程池满了之后会进行扩容maxSize - coreSize) keepAliveTime: 当线程执行完毕之后等待被销毁的时间 workQueue：存放等待执行的 Runnable，是一个BlockingQueue。 ThreadFactory: 线程的构造方法 RejectedExecutionHandler: 线程被拒绝加入线程池时执行的策略  等待队列 BlockingQueue  ArrayBlockingQueue : 基于数组的先进先出队列，构造时必须指明大小; LinkedBlockingDeque : 基于链表的队列，如果构造时没有指明大小，则默认为Integer.MAX_VALUE; SynchronousQueue : 一次只会执行一个元素的队列, 新加入元素的操作会被阻塞到已有元素出队之后;  线程池原理 线程池的策略，当来新线程时：\n 如果线程池中有空闲线程，就复用空闲线程。 如果没有空闲线程，就将新 Runnable 加入等待队列。 如果来的 Runnable 太多，等待队列也满了，就临时扩容到maxPoolSize，相当于使用了一个临时线程池来使用。 如果扩容还是无法满足，就执行拒绝策略。具体的拒绝策略根据创建时的handler决定。 线程池通过Woker中的线程循环从等待队列中获取 Runnable 执行来避免重复创建新线程。  ThreadPoolExecutor用法 1. 直接实例化一个 1 2 3 4 5 6 7 8 9  public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, RejectedExecutionHandler handler) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); }   2. 使用Executors的new****Pool()方法创建ExecutorService: 每一个 newXxxxPool 方法实质也是调用 ThreadPoolExecutor 的构造方法，只是传入的参数是设定好的。\n1 2 3 4 5  public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u0026lt;Runnable\u0026gt;()); }    FixedThreadPool : 核心线程池大小和最大线程池一样，缓存队列为LinkedBlokingQueue,超出线程池满了之后进入的线程都会被加入等待队列。 ScheduledThreadPool : 核心线程池大小用户决定，最大线程池大小为Integer.MAX_VALUE。等待队列为:DelayedWorkQueue。 SingleThreadExecutor : 核心线程池为0，意味着新的线程马上就会被创建。  ThreadPoolExecutor和ExecutorService的区别    Executor ExecutorService          首先Executor和ExecutorService都是接口，ThreadPoolExecutor是类。\n通过Executors.new****Pool创建线程池返回的都是ExecutorService的实例,相当于是调用的ThreadPoolExecutor的构造方法，返回的是它的父类AbstracExecutorService的实例。AbstracExecutorService又是实现了ExecutorService接口的抽象类。\n","description":"","id":124,"section":"posts","tags":null,"title":"线程池ThreadExexutor原理与使用","uri":"https://jiyang.site/posts/2017-08-13-%E7%BA%BF%E7%A8%8B%E6%B1%A0threadexexutor%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"content":" 一个数A，如果按2到A-1进制表达时，各个位数之和的均值是多少? 结果用最简分数表示。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  public class Main{ public static void main(String[] args){ Scanner s = new Scanner(System.in); while(s.hasNextLine()){ int n = s.nextInt(); s.nextLine(); int sum = sum(n); int m = n - 2; int g = gcd(sum,m); sum /= g; m /= g; System.out.println(sum+\u0026#34;/\u0026#34;+m); } } //求从2至n-1进制各个位上数字之和  private static int sum(int n){ int sum = 0, h = n; for(int i=2;i\u0026lt;n;i++){\t//求i进制各个位上数字和  while(h\u0026gt;0){ sum += h%i; h /= i; } h = n; } return sum; } //求最大公约数  private static int gcd(int m,int n){ while(n!=0){ int r = m%n; m = n; n = r; } return m; } }   ","description":"","id":125,"section":"posts","tags":null,"title":"进制均值","uri":"https://jiyang.site/posts/2017-09-08-%E8%BF%9B%E5%88%B6%E5%9D%87%E5%80%BC/"},{"content":"牛牛的好朋友羊羊在纸上写了n+1个整数，羊羊接着抹除掉了一个整数，给牛牛猜他抹除掉的数字是什么。牛牛知道羊羊写的整数神排序之后是一串连续的正整数，牛牛现在要猜出所有可能是抹除掉的整数。例如：\n10 7 12 8 11 那么抹除掉的整数只可能是9\n5 6 7 8 那么抹除掉的整数可能是4也可能是9\n  输入描述:\n 输入包括2行：  第一行为整数n(1 \u0026lt;= n \u0026lt;= 50)，即抹除一个数之后剩下的数字个数 第二行为n个整数num[i] (1 \u0026lt;= num[i] \u0026lt;= 1000000000)      输出描述:\n在一行中输出所有可能是抹除掉的数,从小到大输出,用空格分割,行末无空格。如果没有可能的数，则输出mistake\n  输入例子:\n   2 3 6 输出例子:\nmistake\nimport java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class Main { public static void main(String args[]) { Scanner scanner = new Scanner(System.in); int n = Integer.parseInt(scanner.nextLine()); String[] strings = scanner.nextLine().split(\u0026quot; \u0026quot;); scanner.close(); int[] nums = new int[n]; for (int i = 0; i \u0026lt; n; i++) { nums[i] = Integer.parseInt(strings[i]); } Arrays.sort(nums); //如果序列中差值大于2的间隔数大于1，则该序列不满足条件 if (getMisCount(nums) \u0026gt; 1) { System.out.println(\u0026quot;mistake\u0026quot;); return; } ArrayList\u0026lt;Integer\u0026gt; target = new ArrayList\u0026lt;\u0026gt;(); if (ok(nums)) { int min = nums[0] - 1; int max = nums[n - 1] + 1; if (min \u0026gt; 0) target.add(min); target.add(max); display(target); return; } for (int i = 0; i \u0026lt; n - 1; i++) { int t = nums[i + 1] - nums[i]; if (t == 2) { get(nums[i], nums[i + 1], target); } } if (target.size() == 0) { System.out.println(\u0026quot;mistake\u0026quot;); } else { display(target); } } // 打印数组 static void display(ArrayList\u0026lt;Integer\u0026gt; arrayList) { for (int i = 0; i \u0026lt; arrayList.size(); i++) { System.out.print(arrayList.get(i)); if (i != arrayList.size() - 1) { System.out.print(\u0026quot; \u0026quot;); } } } // 获取两个数之间的序列 static void get(int min, int max, ArrayList\u0026lt;Integer\u0026gt; arrayList) { for (int i = min + 1; i \u0026lt; max; i++) { if (i \u0026gt; 0) arrayList.add(i); } } // 判断序列是否满足差值为1 static boolean ok(int[] nums) { boolean b = true; for (int i = 0; i \u0026lt; nums.length - 1; i++) { int t = nums[i + 1] - nums[i]; if (t != 1) { b = false; } } return b; } static int getMisCount(int[] nums) { int count = 0; for (int i = 0; i \u0026lt; nums.length - 1; i++) { int t = nums[i + 1] - nums[i]; if (t == 2) { count++; } } return count; } } ","description":"","id":126,"section":"posts","tags":null,"title":"连续整数","uri":"https://jiyang.site/posts/2017-07-24-%E8%BF%9E%E7%BB%AD%E6%95%B4%E6%95%B0/"},{"content":"链表逆序 从尾到头打印节点 2018-04-16更新: 递归逆序链表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class LinkNode(object): def __init__(self, val, next=None): self.val = val self.next = next def __str__(self): if self.next is not None: return \u0026#39;{},{}\u0026#39;.format(self.val, self.next) return \u0026#39;{}\u0026#39;.format(self.val) def reverse(cur, pre=None): next = cur.next cur.next = pre if next is None: return cur else: return reverse(next, cur) if __name__ == \u0026#39;__main__\u0026#39;: node = LinkNode(1, LinkNode(2, LinkNode(3, LinkNode(4)))) print(node) head = reverse(node) print(head)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class ListNode { int val; ListNode next; } /** * 链表逆序 * 使用三个指针: pre, cur, next 完成 */ public ListNode reverse(ListNode node) { if (node == null) { return null; } ListNode cur = node; ListNode pre = null; while (cur != null) { // 当前节点为 null 说明遍历结束了  ListNode next = cur.next; // 暂存当前节点的下一个节点  cur.next = pre; // 当前节点的 next 指向前一个节点  pre = cur; // 前一个节点移到当前节点  cur = next; // 当前节点移到下一个节点  } return pre; }   一次操作过程: next=cur.next; pre cur next null [] -\u0026gt; [] -\u0026gt; [] -\u0026gt; [] -\u0026gt; null cur.next = pre; pre cur next null \u0026lt;-[] x [] -\u0026gt; [] -\u0026gt; [] -\u0026gt; null pre = cur; cur = next; pre cur next null \u0026lt;-[] x [] -\u0026gt; [] -\u0026gt; [] -\u0026gt; null 1 2 3 4 5 6 7 8 9 10 11 12  //链表逆序(使用栈做辅助) public ListNode reverseList(ListNode head) { Stack\u0026lt;ListNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); while (head != null) { stack.push(head); head = head.next; } while (!stack.isEmpty()) { head = stack.pop(); } return head; }   1 2 3 4 5 6 7 8 9 10 11 12  //从尾到头打印节点(使用栈做辅助) public ArrayList\u0026lt;Integer\u0026gt; reList(ListNode head) { ArrayList\u0026lt;Integer\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); while (head != null) { stack.push(head.val); } while (!stack.isEmpty()) { arrayList.add(stack.pop()); } return arrayList; }   两个栈实现队列的功能 public class Solution { Stack\u0026lt;Integer\u0026gt; stack1 = new Stack\u0026lt;Integer\u0026gt;(); Stack\u0026lt;Integer\u0026gt; stack2 = new Stack\u0026lt;Integer\u0026gt;(); public void push(int node) { stack1.push(node); } public int pop() { if(!stack2.isEmpty()){ return stack2.pop(); } while (!stack1.isEmpty()) { stack2.push(stack1.pop()); } return stack2.pop(); } } ","description":"","id":127,"section":"posts","tags":["链表"],"title":"链表问题","uri":"https://jiyang.site/posts/2017-08-12-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"}]